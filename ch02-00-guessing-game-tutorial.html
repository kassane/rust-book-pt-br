<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Guessing Game Tutorial - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html" class="active"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch02-00-guessing-game-tutorial.html#jogo-de-adivinha√ß√£o" id="jogo-de-adivinha√ß√£o"><h1>Jogo de Adivinha√ß√£o</h1></a>
<p>Vamos entrar de cabe√ßa no Rust e colocar a m√£o na massa! Este cap√≠tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como us√°-los em um
programa de verdade. Voc√™ vai aprender sobre <code>let</code>, <code>match</code>, m√©todos, fun√ß√µes
associadas, crates externos, e mais! Os cap√≠tulos seguintes v√£o explorar essas
ideias em mais detalhes. Neste cap√≠tulo, voc√™ vai praticar o b√°sico.</p>
<p>Vamos implementar um cl√°ssico problema de programa√ß√£o para iniciantes: um jogo
de adivinha√ß√£o. Eis como ele funciona: o programa vai gerar um n√∫mero inteiro
aleat√≥rio entre 1 e 100. Ent√£o, ele vai pedir ao jogador que digite um palpite.
Ap√≥s darmos nosso palpite, ele vai nos indicar se o palpite √© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parab√©ns e
sair.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, v√° ao seu diret√≥rio de projetos que voc√™ criou no
Cap√≠tulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que fa√ßa um projeto
bin√°rio, similar ao do Cap√≠tulo 1. O segundo comando muda a pasta atual para o
diret√≥rio do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informa√ß√µes sobre o autor, que o Cargo obt√©m do seu ambiente, n√£o
estiverem corretas, fa√ßa os reparos necess√°rios e salve o arquivo.</p>
<p>Assim como no Cap√≠tulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para n√≥s.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e execut√°-lo de uma vez s√≥
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> √© uma boa op√ß√£o quando precisamos iterar rapidamente em um
projeto, que √© o caso neste jogo: n√≥s queremos testar rapidamente cada itera√ß√£o
antes de movermos para a pr√≥xima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso c√≥digo nele.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usu√°rio, processar essa
entrada, e conferir se ela est√° no formato esperado. Pra come√ßar, vamos permitir
que o jogador entre com um palpite. Coloque este c√≥digo no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: C√≥digo para ler um palpite do usu√°rio e
imprim√≠-lo na tela.</span></p>
<p>Esse c√≥digo tem muita informa√ß√£o, vamos ver uma parte de cada vez. Para obter a
entrada do usu√°rio, e ent√£o imprimir o resultado como sa√≠da, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/sa√≠da). A biblioteca <code>io</code> prov√©m da
biblioteca padr√£o (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padr√£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prel√∫dio</em></a><!-- ignore -->. Se um tipo que voc√™ quiser usar n√£o
estiver no prel√∫dio, voc√™ ter√° que import√°-lo explicitamente atrav√©s do <code>use</code>.
A biblioteca <code>std::io</code> oferece v√°rias ferramentas de entrada/sa√≠da, incluindo a
funcionalidade de ler dados de entrada do usu√°rio.</p>
<p>Como visto no Cap√≠tulo 1, a fun√ß√£o <code>main</code> √© o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova fun√ß√£o, o <code>()</code> indica que n√£o h√° par√¢metros, e
o <code>{</code> inicia o corpo da fun√ß√£o.</p>
<p>Como voc√™ tamb√©m j√° aprendeu no Cap√≠tulo 1, <code>println!</code> √© uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o n√∫mero!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este c√≥digo est√° exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usu√°rio.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#armazenando-valores-em-vari√°veis" id="armazenando-valores-em-vari√°veis"><h3>Armazenando Valores em Vari√°veis</h3></a>
<p>Pr√≥ximo passo, vamos criar um local para armazenar a entrada do usu√°rio:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa est√° ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta √© uma declara√ß√£o <code>let</code>, que √© usada para criar
<em>vari√°veis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova vari√°vel chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, vari√°veis s√£o imut√°veis por padr√£o. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da vari√°vel para torn√°-la mut√°vel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imut√°vel
let mut bar = 5; // mut√°vel
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um coment√°rio, que continua at√© o fim da linha.
Rust ignora tudo o que estiver nos coment√°rios.</p>
</blockquote>
<p>Agora voc√™ sabe que <code>let mut palpite</code> vai introduzir uma vari√°vel mut√°vel de
nome <code>palpite</code>. No outro lado do s√≠mbolo <code>=</code> est√° o valor ao qual <code>palpite</code> est√°
vinculado, que √© o resultado da chamada <code>String::new</code>, uma fun√ß√£o que retorna
uma nova inst√¢ncia de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> √© um tipo
fornecido pela biblioteca padr√£o que representa uma cadeia expans√≠vel de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> √© uma <em>fun√ß√£o associada</em> do
tipo <code>String</code>. Uma fun√ß√£o associada √© implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma inst√¢ncia particular de <code>String</code>. Algumas linguagens
d√£o a isso o nome <em>m√©todo est√°tico</em>.</p>
<p>Esta fun√ß√£o <code>new()</code> cria uma nova <code>String</code> vazia. Voc√™ encontrar√° uma fun√ß√£o
<code>new()</code> em muitos tipos, j√° que √© um nome comum para uma fun√ß√£o que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma vari√°vel
mut√°vel que est√° atualmente vinculada a uma nova inst√¢ncia vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que inclu√≠mos a funcionalidade de entrada/sa√≠da da biblioteca
padr√£o por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma fun√ß√£o associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se n√£o tiv√©ssemos a linha <code>use std::io</code> no in√≠cio do programa, poder√≠amos ter
escrito esta chamada como <code>std::io::stdin</code>. A fun√ß√£o <code>stdin</code> retorna uma
inst√¢ncia de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padr√£o do seu terminal.</p>
<p>A pr√≥xima parte do c√≥digo, <code>.read_line(&amp;mut palpite)</code>, chama o m√©todo
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padr√£o para obter
entrada do usu√°rio. Tamb√©m estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da fun√ß√£o <code>read_line</code> √© receber o que o usu√°rio digita na entrada
padr√£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mut√°vel para que o m√©todo consiga
alterar o seu conte√∫do, adicionando a entrada do usu√°rio.</p>
<p>O s√≠mbolo <code>&amp;</code> indica que o argumento √© uma <em>refer√™ncia</em>, o que permite m√∫ltiplas
partes do seu c√≥digo acessar um certo dado sem precisar criar v√°rias c√≥pias dele
na mem√≥ria. Refer√™ncias s√£o uma caracter√≠stica complexa, e uma das maiores
vantagens do Rust √© o qu√£o f√°cil e seguro √© usar refer√™ncias. Voc√™ n√£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O Cap√≠tulo 4 vai
explicar sobre refer√™ncias de forma mais aprofundada. Por enquanto, tudo que
voc√™ precisa saber √© que, assim como as vari√°veis, refer√™ncias s√£o imut√°veis por
padr√£o. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mut√°vel.</p>
<p>Ainda n√£o finalizamos completamente esta linha de c√≥digo. Embora esta seja uma
√∫nica linha de texto, √© apenas a primeira parte de uma linha l√≥gica de c√≥digo. A
segunda parte √© a chamada para este m√©todo:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando voc√™ chama um m√©todo com a sintaxe <code>.foo()</code>, geralmente √© bom introduzir
uma nova linha e outro espa√ßo para ajudar a dividir linhas muito compridas.
Poder√≠amos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Por√©m, uma linha muito comprida fica dif√≠cil de ler. Ent√£o √© melhor dividirmos a
linha em duas, uma para cada m√©todo chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usu√°rio escreve dentro
da string que passamos como argumento, mas tamb√©m retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padr√£o: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
gen√©rico e as vers√µes espec√≠ficas dos subm√≥dulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> s√£o <a href="ch06-00-enums.html"><em>enumera√ß√µes</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumera√ß√£o √© um tipo que pode ter um conjunto fixo de valores,
os quais s√£o chamados de <em>variantes</em> da enum. O Cap√≠tulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes s√£o <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a opera√ß√£o teve
sucesso, e dentro da variante <code>Ok</code> est√° o valor resultante. <code>Err</code> significa que
a opera√ß√£o falhou, e cont√©m informa√ß√µes sobre como ou por que isso ocorreu.</p>
<p>O prop√≥sito destes tipos <code>Result</code> √© codificar informa√ß√µes de manipula√ß√£o de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem m√©todos
definidos. Uma inst√¢ncia de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">m√©todo <code>expect</code></a><!-- ignore -->
que voc√™ pode chamar. Se esta inst√¢ncia de <code>io::Result</code> √© um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que voc√™ passou como argumento
ao <code>expect</code>. Se o m√©todo <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que est√° por tr√°s. Se esta
inst√¢ncia de <code>io::Result</code> √© um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retorn√°-lo para que voc√™ possa us√°-lo. Neste caso, o valor √© o n√∫mero de bytes
dos dados que o usu√°rio inseriu atrav√©s da entrada padr√£o.</p>
<p>Se n√£o chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que n√£o usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um poss√≠vel erro. A maneira correta de suprimir
o aviso √© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. Voc√™
aprender√° sobre recupera√ß√£o de erros no Cap√≠tulo 9.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a fun√ß√£o <code>main</code>, h√° apenas uma linha mais a ser
discutida no c√≥digo que fizemos at√© agora, que √© a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;Voc√™ disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usu√°rio. O
<code>{}</code> √© um curinga que reserva o lugar de um valor. Voc√™ pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
ap√≥s a string de formata√ß√£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir m√∫ltiplos valores em uma s√≥ chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse c√≥digo imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinha√ß√£o. Voc√™ pode execut√°-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
Digite o seu palpite.
6
Voc√™ disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo est√° feita: podemos coletar entrada do
teclado e mostr√°-la na tela.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#gerando-um-n√∫mero-secreto" id="gerando-um-n√∫mero-secreto"><h2>Gerando um N√∫mero Secreto</h2></a>
<p>A seguir, precisamos gerar um n√∫mero secreto que o usu√°rio vai tentar advinhar.
O n√∫mero secreto deve ser diferente a cada execu√ß√£o, para que o jogo tenha gra√ßa
em ser jogado mais de uma vez. Vamos usar um n√∫mero aleat√≥rio entre 1 e 100,
para que o jogo n√£o seja t√£o dif√≠cil. Rust ainda n√£o inclui uma funcionalidade
de gera√ß√£o de n√∫meros aleat√≥rios em sua biblioteca padr√£o. Por√©m, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> √© um pacote de c√≥digo Rust. O projeto que estamos
construindo √© um <em>crate bin√°rio</em>, que √© um execut√°vel. J√° o <code>rand</code> √© um
<em>crate de biblioteca</em>, que cont√©m c√≥digo cujo objetivo √© ser usado por outros
programas.</p>
<p>√â no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o c√≥digo usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma depend√™ncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabe√ßalho da se√ß√£o <code>[dependencies]</code> que o Cargo
criou para voc√™:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabe√ßalho √© parte de uma
se√ß√£o que segue at√© o in√≠cio de outra. A se√ß√£o <code>[dependencies]</code> √© onde voc√™ diz
ao Cargo de quais crates externos o seu projeto depende, e quais vers√µes desses
crates voc√™ exige. Neste caso, especificamos o crate <code>rand</code> com a vers√£o
sem√¢ntica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento Sem√¢ntico</a><!-- ignore -->
(√†s vezes chamado <em>SemVer</em>), um padr√£o para escrever n√∫meros de vers√µes. O
n√∫mero <code>0.3.14</code> √©, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer vers√£o que tenha uma API p√∫blica compat√≠vel com a vers√£o
0.3.14&quot;.</p>
<p>Agora, sem mudar c√≥digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execu√ß√£o de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como depend√™ncia.</span></p>
<p>Talvez pra voc√™ apare√ßam vers√µes diferentes (mas elas s√£o todas compat√≠veis com
o c√≥digo, gra√ßas ao Versionamento Sem√¢ntico!), e as linhas talvez apare√ßam em
ordem diferente.</p>
<p>Agora que temos uma depend√™ncia externa, Cargo busca as vers√µes mais recentes de
tudo no <em>registro</em>, que √© uma c√≥pia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io √© onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>Ap√≥s atualizar o registro, Cargo verifica a se√ß√£o <code>[dependencies]</code> e baixa todas
as que voc√™ n√£o tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como depend√™ncia, o Cargo tamb√©m puxou uma c√≥pia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baix√°-las, o Cargo as compila e
ent√£o compila nosso projeto.</p>
<p>Se, logo em seguida, voc√™ executar <code>cargo build</code> novamente sem fazer mudan√ßas,
n√£o vai aparecer nenhuma mensagem de sa√≠da. O Cargo sabe que j√° baixou e
compilou as depend√™ncias, e voc√™ n√£o alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo tamb√©m sabe que voc√™ n√£o mudou mais nada no seu c√≥digo, e
por isso n√£o o recompila. Sem nada a fazer, ele simplesmente sai. Se voc√™ abrir
<em>src/main.rs</em>, fizer uma modifica√ß√£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo s√≥ atualiza o <em>build</em> com a sua pequena mudan√ßa
no arquivo <em>src/main.rs</em>. Suas depend√™ncias n√£o mudaram, ent√£o o Cargo sabe que
pode reutilizar o que j√° tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do c√≥digo.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#o-arquivo-cargolock-garante-builds-reproduz√≠veis" id="o-arquivo-cargolock-garante-builds-reproduz√≠veis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> Reproduz√≠veis</h4></a>
<p>O Cargo tem um mecanismo que assegura que voc√™ pode reconstruir o mesmo artefato
toda vez que voc√™ ou outra pessoa compilar o seu c√≥digo. O Cargo vai usar apenas
as vers√µes das depend√™ncias que voc√™ especificou, at√© que voc√™ indique o
contr√°rio. Por exemplo, o que acontece se, na semana que vem, sair a vers√£o
<code>v0.3.15</code> contendo uma corre√ß√£o de bug, mas tamb√©m uma regress√£o que n√£o
funciona com o seu c√≥digo?</p>
<p>A resposta para isso est√° no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que voc√™ executou <code>cargo build</code>, e agora est√° no seu diret√≥rio
<em>jogo_de_advinhacao</em>. Quando voc√™ compila o seu projeto pela primeira vez, o
Cargo descobre as vers√µes de todas as depend√™ncias que preenchem os crit√©rios
e ent√£o as escreve no arquivo <em>Cargo.lock</em>. Quando voc√™ compilar o seu projeto
futuramente, o Cargo ver√° que o arquivo <em>Cargo.lock</em> existe e usar√° as vers√µes
especificadas l√°, em vez de refazer todo o trabalho descobrir as vers√µes
novamente. Isto lhe permite ter um <em>build</em> reproduz√≠vel automaticamente. Em
outras palavras, seu projeto vai continuar com a vers√£o <code>0.3.14</code> at√© que voc√™
fa√ßa uma atualiza√ß√£o expl√≠cita, gra√ßas ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#atualizando-um-crate-para-obter-uma-nova-vers√£o" id="atualizando-um-crate-para-obter-uma-nova-vers√£o"><h4>Atualizando um Crate para Obter uma Nova Vers√£o</h4></a>
<p>Quando voc√™ <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as vers√µes mais recentes que
atendem as suas especifica√ß√µes no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas vers√µes no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padr√£o, o Cargo vai procurar as vers√µes maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> j√° tiver lan√ßado duas novas vers√µes, <code>0.3.15</code> e
<code>0.4.0</code>, voc√™ ver√° a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, voc√™ vai notar tamb√©m uma mudan√ßa no seu arquivo <em>Cargo.lock</em>
dizendo que a vers√£o do crate <code>rand</code> que voc√™ est√° usando agora √© a <code>0.3.15</code>.</p>
<p>Se voc√™ quisesse usar a vers√£o <code>0.4.0</code>, ou qualquer vers√£o da s√©rie <code>0.4.x</code> do
<code>rand</code>, voc√™ teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na pr√≥xima vez que voc√™ executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates dispon√≠veis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova vers√£o que voc√™ especificou.</p>
<p>H√° muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no Cap√≠tulo 14,
mas por ora isto √© tudo que voc√™ precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rust√°ceos</em> consigam escrever projetos menores que
s√£o montados a partir de diversos pacotes.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#gerando-um-n√∫mero-aleat√≥rio" id="gerando-um-n√∫mero-aleat√≥rio"><h3>Gerando um N√∫mero Aleat√≥rio</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O pr√≥ximo passo √© atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: Mudan√ßas necess√°rias do c√≥digo para gerar um
n√∫mero aleat√≥rio.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma depend√™ncia externa. Isto tamb√©m √© equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> √© um trait
que define m√©todos a serem implementados pelos geradores de n√∫meros aleat√≥rios,
e esse trait deve estar dentro do escopo para que possamos usar esses m√©todos. O
Cap√≠tulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A fun√ß√£o <code>rand::thread_rng</code> nos
d√° o gerador de n√∫meros aleat√≥rios que vamos usar, um que √© local √† <em>thread</em>
corrente e que √© inicializado pelo sistema operacional. Depois, vamos chamar o
m√©todo <code>gen_range</code> no gerador de n√∫meros aleat√≥rios. Esse m√©todo est√° definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
m√©todo recebe dois argumentos e gera um n√∫mero aleat√≥rio entre eles. Ele inclui
o limite inferior mas exclui o superior, ent√£o precisamos passar <code>1</code> e <code>101</code>
para obter um n√∫mero de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais fun√ß√µes e m√©todos de um crate
devem ser chamados n√£o √© nada trivial. As instru√ß√µes de como usar um crate
est√£o na documenta√ß√£o de cada um. Outra coisa boa do Cargo √© que voc√™ pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documenta√ß√£o
fornecida por todas as suas depend√™ncias e abr√≠-las no seu navegador. Se voc√™
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o n√∫mero secreto. Isto √© √∫til enquanto
estamos desenvolvendo o programa para podermos test√°-lo, mas vamos retir√°-la da
vers√£o final. Um jogo n√£o √© muito interessante se ele mostra a resposta logo no
in√≠cio!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 7
Digite o seu palpite.
4
Voc√™ disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 83
Digite o seu palpite.
5
Voc√™ disse: 5
</code></pre>
<p>Voc√™ j√° deve obter n√∫meros aleat√≥rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#comparando-o-palpite-com-o-n√∫mero-secreto" id="comparando-o-palpite-com-o-n√∫mero-secreto"><h2>Comparando o Palpite com o N√∫mero Secreto</h2></a>
<p>Agora que n√≥s temos a entrada do usu√°rio e o n√∫mero secreto, vamos compar√°-los.
Esta estapa √© mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os poss√≠veis resultados da
compara√ß√£o de dois n√∫meros.</span></p>
<p>A primeira novidade aqui √© outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padr√£o chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> √© outra enum, igual a <code>Result</code>,
mas as suas variantes s√£o <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes s√£o os tr√™s poss√≠veis resultados quando
voc√™ compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
}
</code></pre>
<p>O m√©todo <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma refer√™ncia de qualquer coisa que
voc√™ queira comparar. Neste caso, est√° comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. N√≥s usamos uma express√£o <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo m√©todo <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma express√£o <code>match</code> √© composta de <em>bra√ßos</em>. Um bra√ßo consiste em um <em>padr√£o</em>
mais o c√≥digo que deve ser executado se o valor colocado no in√≠cio do <code>match</code> se
encaixar no padr√£o deste bra√ßo. O Rust pega o valor passado ao <code>match</code> e o
compara com o padr√£o de cada bra√ßo na sequ√™ncia. A express√£o <code>match</code> e os
padr√µes s√£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situa√ß√µes que seu c√≥digo pode encontrar, e ajuda a assegurar que
voc√™ tenha tratado todas elas. Essas ferramentas ser√£o abordadas em detalhes nos
cap√≠tulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na express√£o <code>match</code> usada aqui.
Digamos que o usu√°rio tenha colocado 50 como palpite, e o n√∫mero secreto
aleat√≥rio desta vez √© 38. Quando o c√≥digo compara 50 com 38, o m√©todo <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 √© maior que 38. <code>Ordering::Greater</code> √© o
valor passado ao <code>match</code>. Ele olha para o padr√£o <code>Ordering::Less</code> do primeiro
bra√ßo, mas o valor <code>Ordering::Greater</code> n√£o casa com <code>Ordering::Less</code>, ent√£o ele
ignora o c√≥digo desse bra√ßo e avan√ßa para o pr√≥ximo. J√° o padr√£o do pr√≥ximo
bra√ßo, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O c√≥digo associado a
este bra√ßo vai ser executado e mostrar <code>Muito alto!</code> na tela. A express√£o
<code>match</code> termina porque j√° n√£o tem mais necessidade de verificar o √∫ltimo bra√ßo
nesse caso particular.</p>
<p>Por√©m, o c√≥digo da Listagem 2-4 ainda n√£o vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro est√° dizendo √© que temos <em>tipos incompat√≠veis</em>. Rust tem um
sistema de tipos forte e est√°tico. Por√©m, Rust tamb√©m tem infer√™ncia de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, ent√£o ele n√£o nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, √© de um tipo num√©rico. Existem alguns tipos
num√©ricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que √© um n√∫mero de
32 bits; <code>u32</code>, um n√∫mero de 32 bits sem sinal; <code>i64</code>, um n√∫mero de 64 bits; e
mais alguns outros. O tipo num√©rico padr√£o do Rust √© <code>i32</code>, que √© o tipo do
<code>numero_secreto</code>, a n√£o ser que adicionemos, em algum lugar, uma informa√ß√£o de
tipo que fa√ßa o Rust inferir outro tipo num√©rico. A raz√£o do erro √© que o Rust
n√£o pode comparar uma string e um tipo num√©rico.</p>
<p>Em √∫ltima an√°lise, queremos converter a <code>String</code> que lemos como entrada em um
tipo num√©rico de verdade, de forma que possamos compar√°-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da fun√ß√£o <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um n√∫mero!&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas s√£o:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um n√∫mero!&quot;);
</code></pre>
<p>N√≥s criamos uma vari√°vel chamada <code>palpite</code>. Mas espera, o programa j√° n√£o tinha
uma vari√°vel chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto √© geralmente usado em situa√ß√µes em que voc√™
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos for√ßar a criar dois nomes √∫nicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O Cap√≠tulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>N√≥s vinculamos <code>palpite</code> √† express√£o <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
express√£o, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usu√°rio. O m√©todo <code>trim</code>, em uma inst√¢ncia de <code>String</code>, vai eliminar quaisquer
espa√ßos em branco no in√≠cio e no fim. <code>u32</code> pode conter apenas caracteres
num√©ricos, mas o usu√°rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usu√°rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha √© inserido na
string. Por exemplo, se o usu√°rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O m√©todo <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">m√©todo <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de n√∫mero. Dado que ele pode interpretar uma variedade de tipos
num√©ricos, precisamos dizer ao Rust qual o tipo exato de n√∫mero n√≥s queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
num√©ricos embutidos, o <code>u32</code> visto aqui √© um inteiro de 32 bits sem sinal. √â uma
boa escolha padr√£o para um n√∫mero positivo pequeno. Voc√™ vai aprender sobre
outros tipos num√©ricos no Cap√≠tulo 3. Al√©m disso, a anota√ß√£o <code>u32</code> neste
programa de exemplo e a compara√ß√£o com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> tamb√©m deve ser um <code>u32</code>. Ent√£o agora a
compara√ß√£o vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>Aüëç%</code>, n√£o haveria como converter isto em um n√∫mero. Como ele
pode falhar, o m√©todo <code>parse</code> retorna um <code>Result</code>, assim como o m√©todo
<code>read_line</code>, conforme discutido anteriormente na se√ß√£o &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
m√©todo <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por n√£o conseguir criar um n√∫mero a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um n√∫mero, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o n√∫mero que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 58
Digite o seu palpite.
  76
Voc√™ disse: 76
Muito alto!
</code></pre>
<p>Boa! At√© mesmo colocando alguns espa√ßos antes de digitar o palpite, o programa
ainda descobriu que o palpite do usu√°rio √© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o n√∫mero corretamente, digite um n√∫mero muito alto, e digite um
n√∫mero muito baixo.</p>
<p>Agora j√° temos a maior parte do jogo funcionando, mas o usu√°rio s√≥ consegue dar
um palpite uma vez. Vamos mudar isso adicionando la√ßos!</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#permitindo-m√∫ltiplos-palpites-usando-looping" id="permitindo-m√∫ltiplos-palpites-usando-looping"><h2>Permitindo M√∫ltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos d√° um la√ßo (<em>loop</em>) infinito. Use-a para dar aos
usu√°rios mais chances de advinhar o n√∫mero:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como voc√™ pode ver, movemos tudo para dentro do la√ßo a partir da mensagem
pedindo o palpite do usu√°rio. Certifique-se de indentar essas linhas mais quatro
espa√ßos cada uma, e execute o programa novamente. Repare que h√° um novo
problema, porque o programa est√° fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usu√°rio n√£o consegue sair!</p>
<p>O usu√°rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas h√° uma outra forma de escapar deste
monstro insaci√°vel que mencionamos na discuss√£o do m√©todo <code>parse</code>, na se√ß√£o
&quot;Comparando o Palpite com o N√∫mero Secreto&quot;: se o usu√°rio fornece uma resposta
n√£o-num√©rica, o programa vai sofrer um <em>crash</em>. O usu√°rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 59
Digite o seu palpite.
45
Voc√™ disse: 45
Muito baixo!
Digite o seu palpite.
60
Voc√™ disse: 60
Muito alto!
Digite o seu palpite.
59
Voc√™ disse: 59
Voc√™ acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um n√∫mero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso tamb√©m acontece com qualquer
outra entrada n√£o num√©rica. Por√©m, isto n√£o √© o ideal. Queremos que o jogo
termine automaticamente quando o n√∫mero √© advinhado corretamente.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#saindo-ap√≥s-um-palpite-correto" id="saindo-ap√≥s-um-palpite-correto"><h3>Saindo Ap√≥s um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usu√°rio vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> ap√≥s o <code>Voc√™ acertou!</code>, o programa vai sair do la√ßo
quando o usu√°rio advinhar corretamente o n√∫mero secreto. Sair do la√ßo tamb√©m
significa sair do programa, pois o la√ßo √© a √∫ltima parte da <code>main</code>.</p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#tratando-entradas-inv√°lidas" id="tratando-entradas-inv√°lidas"><h3>Tratando Entradas Inv√°lidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usu√°rio insere uma entrada n√£o num√©rica, vamos fazer o jogo
ignor√°-la para que o usu√°rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> √© convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma express√£o <code>match</code> √© a forma como voc√™
geralmente deixa de causar um <em>crash</em> em um erro e passa a trat√°-lo, de fato.
Lembre-se que o m√©todo <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
cont√©m a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do m√©todo <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um n√∫mero, ele vai retornar um <code>Ok</code>
contendo o n√∫mero resultante. Esse valor <code>Ok</code> vai casar com o padr√£o do primeiro
bra√ßo, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse n√∫mero vai acabar ficando exatamente onde
queremos, na vari√°vel <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>n√£o</em> conseguir converter a string em um n√∫mero, ele vai retornar
um <code>Err</code> que cont√©m mais informa√ß√µes sobre o erro. O valor <code>Err</code> n√£o casa com o
padr√£o <code>Ok(num)</code> do primeiro bra√ßo do <code>match</code>, mas casa com o padr√£o <code>Err(_)</code> do
segundo bra√ßo. O <code>_</code> √© um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, n√£o importa qual informa√ß√£o h√° dentro
deles. Ent√£o o programa vai executar o c√≥digo do segundo bra√ßo, <code>continue</code>, que
significa ir para a pr√≥xima itera√ß√£o do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar execut√°-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 61
Digite o seu palpite.
10
Voc√™ disse: 10
Muito baixo!
Digite o seu palpite.
99
Voc√™ disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Voc√™ disse: 61
Voc√™ acertou!
</code></pre>
<p>Demais! Com apenas um √∫ltimo ajuste, vamos finalizar o jogo de adivinha√ß√£o:
lembre-se que o programa ainda est√° mostrando o n√∫mero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o n√∫mero
secreto. A Listagem 2-5 mostra o c√≥digo final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: C√≥digo completo do jogo de advinha√ß√£o.
</span></p>
<a class="header" href="ch02-00-guessing-game-tutorial.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, voc√™ construiu com sucesso o jogo de adivinha√ß√£o! Parab√©ns!</p>
<p>Este projeto foi uma forma pr√°tica de apresentar v√°rios conceitos novos de Rust:
<code>let</code>, <code>match</code>, m√©todos, fun√ß√µes associadas, uso de crates externos, e outros.
Nos pr√≥ximos cap√≠tulos, voc√™ vai aprender sobre esses conceitos em mais
detalhes. O Cap√≠tulo 3 aborda conceitos que a maioria das linguagens de
programa√ß√£o tem, como vari√°veis, tipos de dados e fun√ß√µes, e mostra como us√°-los
em Rust. O Cap√≠tulo 4 explora posse (<em>ownership</em>), que √© a caracter√≠stica do
Rust mais diferente das outras linguagens. O Cap√≠tulo 5 discute structs e a
sintaxe de m√©todos, e o Cap√≠tulo 6 se dedica a explicar enums.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-02-hello-world.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-00-common-programming-concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch01-02-hello-world.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-00-common-programming-concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
