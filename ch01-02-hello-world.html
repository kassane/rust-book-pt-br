<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>ğŸ‡§ğŸ‡· OlÃ¡, Mundo! - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> ğŸ‡§ğŸ‡· IntroduÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> ğŸ‡§ğŸ‡· InstalaÃ§Ã£o</a></li><li><a href="ch01-02-hello-world.html" class="active"><strong aria-hidden="true">1.2.</strong> ğŸ‡§ğŸ‡· OlÃ¡, Mundo!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> ğŸ‡§ğŸ‡· Jogo de AdivinhaÃ§Ã£o</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> ğŸ‡§ğŸ‡· Conceitos Comuns de ProgramaÃ§Ã£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> ğŸ‡§ğŸ‡· VariÃ¡veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> ğŸ‡§ğŸ‡· Tipos de dados</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> ğŸ‡§ğŸ‡· FunÃ§Ãµes</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> ğŸ‡§ğŸ‡· ComentÃ¡rios</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> ğŸ‡§ğŸ‡· Controle de fluxo</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> ğŸ‡§ğŸ‡· Entendendo Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> ğŸ‡§ğŸ‡· O Que Ã‰ Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> ğŸ‡§ğŸ‡· ReferÃªncias e Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> ğŸ‡§ğŸ‡· Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> ğŸ‡§ğŸ‡· Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> ğŸ‡§ğŸ‡· Enums e Casamento de PadrÃµes</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> ğŸ‡§ğŸ‡· Definindo uma Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> ğŸ‡§ğŸ‡· Operador match</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> ğŸ‡§ğŸ‡· Controle de Fluxo Conciso com if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> ğŸ‡§ğŸ‡· MÃ³dulos</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> ğŸ‡§ğŸ‡· mod e o Sistema de Arquivos</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> ğŸ‡§ğŸ‡· Controlando a Visibilidade com pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> ğŸ‡§ğŸ‡· Importando nomes com use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ğŸ‡§ğŸ‡· Vetores</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> ğŸ‡§ğŸ‡· Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> ğŸ‡§ğŸ‡· Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> ğŸ‡§ğŸ‡· Tratamento de Erros</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> ğŸ‡§ğŸ‡· Erros IrrecuperÃ¡veis com panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> ğŸ‡§ğŸ‡· Erros recuperÃ¡veis com Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> ğŸ‡§ğŸ‡· Entrar em panic! ou NÃ£o Entrar em panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos, Traits, e Tempos de vida (Lifetimes)</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ğŸ‡§ğŸ‡· Tipos GenÃ©ricos de Dados</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> ğŸ‡§ğŸ‡· Traits: Definindo Comportamento Compartilhado</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ğŸ‡§ğŸ‡· Validating References with Lifetimes</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> ğŸ‡§ğŸ‡· Ponteiros Inteligentes (Smart Pointers)</a></li><li><ol class="section"><li><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ğŸ‡§ğŸ‡· Box<T> Aponta para Dados no Heap e Tem Tamanho Conhecido</a></li><li><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> ğŸ‡§ğŸ‡· Tratando Ponteiros Inteligentes como ReferÃªncias Normais com a Trait Deref</a></li><li><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> ğŸ‡§ğŸ‡· A Trait Drop Roda CÃ³digo durante a Limpeza</a></li><li><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> ğŸ‡§ğŸ‡· Rc<T>, o Ponteiro Inteligente com Contagem de ReferÃªncias</a></li><li><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> ğŸ‡§ğŸ‡· RefCell<T> e a Pattern de Mutabilidade Interior</a></li><li><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> ğŸ‡§ğŸ‡· Ciclos de ReferÃªncias Podem Vazar MemÃ³ria</a></li></ol></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> ğŸ‡§ğŸ‡· Rust Ã© uma linguagem orientada a objetos?</a></li><li><ol class="section"><li><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> ğŸ‡§ğŸ‡· O que significa orientado a objetos?</a></li><li><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> ğŸ‡§ğŸ‡· Usando objetos trait que permitem valores de tipos diferentes</a></li><li><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> ğŸ‡§ğŸ‡· Implementando um padrÃ£o de projeto orientado a objetos</a></li></ol></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch01-02-hello-world.html#olÃ¡-mundo" id="olÃ¡-mundo"><h2>OlÃ¡, Mundo!</h2></a>
<p>Agora que Rust jÃ¡ estÃ¡ instalado, vamos escrever nosso primeiro programa. Quando
aprendemos uma nova linguagem de programaÃ§Ã£o, Ã© tradicional escrever um pequeno
programa que imprime &quot;OlÃ¡, mundo!&quot; (<em>â€œHello, world!â€</em>) na tela, e Ã© exatamente
isso que vamos fazer nesta seÃ§Ã£o.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust nÃ£o exige que vocÃª use um determinado editor ou IDE,
ou seja, vocÃª estÃ¡ livre para usar o que bem entender para escrever seu cÃ³digo
Rust.</p>
</blockquote>
<a class="header" href="ch01-02-hello-world.html#criando-um-diretÃ³rio-de-projeto" id="criando-um-diretÃ³rio-de-projeto"><h3>Criando um DiretÃ³rio de Projeto</h3></a>
<p>Primeiramente, crie uma pasta para colocar o seu cÃ³digo Rust. O Rust nÃ£o se
importa onde vocÃª vai armazenar o seu cÃ³digo, mas neste livro, nÃ³s sugerimos
criar um diretÃ³rio chamado <em>projetos</em> e armazenar todos os seus projetos ali.
Abra o seu terminal e digite os seguintes comandos:</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ mkdir ~/projetos
$ cd ~/projetos
$ mkdir ola_mundo
$ cd ola_mundo
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projetos
&gt; cd %USERPROFILE%\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projetos
&gt; cd $env:USERPROFILE\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<a class="header" href="ch01-02-hello-world.html#escrevendo-e-executando-um-programa-em-rust" id="escrevendo-e-executando-um-programa-em-rust"><h3>Escrevendo e Executando um Programa em Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos relacionados Ã  linguagem Rust sempre
terminam com a extensÃ£o <em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra,
use um <em>underscore</em> (<code>_</code>) para separÃ¡-los. Por exemplo, vocÃª deve nomear o seu
arquivo <em>ola_mundo.rs</em> em vez de <em>olamundo.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que vocÃª acabou de criar e digite o seguinte
cÃ³digo:</p>
<p><span class="filename">Arquivo: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;OlÃ¡, mundo!&quot;);
}
</code></pre></pre>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou OSX, digite os seguintes
comandos:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
OlÃ¡, mundo!
</code></pre>
<p>Para executar o seu programa no Windows, digite <code>.\main.exe</code> em vez de <code>./main</code>.
Independente do seu sistema operacional, vocÃª deverÃ¡ ver a mensagem
<code>OlÃ¡, mundo!</code> no seu terminal. Se vocÃª chegou atÃ© aqui, parabÃ©ns! VocÃª escreveu
o seu primeiro programa em Rust. Isso faz de vocÃª um programador Rust! Seja
bem-vindo!</p>
<a class="header" href="ch01-02-hello-world.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;OlÃ¡, mundo!&quot; em detalhes.
Aqui estÃ¡ a primeira peÃ§a do quebra-cabeÃ§a:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma <em>funÃ§Ã£o</em> em Rust. A funÃ§Ã£o <code>main</code> Ã© especial: Ã© a
primeira coisa que Ã© executada em cada programa escrito em Rust. A primeira
linha diz: &quot;Estou declarando uma funÃ§Ã£o chamada <code>main</code> que nÃ£o contÃ©m nenhum
parÃ¢metro e que nÃ£o retorna nada.&quot; Se existissem parÃ¢metros, eles estariam
dentro dos parÃªnteses, <code>(</code> e <code>)</code>.</p>
<p>TambÃ©m repare que o corpo da funÃ§Ã£o estÃ¡ envolvido por duas chaves, <code>{</code> e <code>}</code>.
Rust requer essas chaves no comeÃ§o e no fim do corpo de cada funÃ§Ã£o.
Considera-se boa prÃ¡tica colocar a chave inicial na mesma linha da declaraÃ§Ã£o
da funÃ§Ã£o, com um espaÃ§o entre elas.</p>
<p>Dentro da funÃ§Ã£o <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;OlÃ¡, mundo!&quot;);
#}</code></pre></pre>
<p>Esta linha faz todo o trabalho nesse pequeno programa: imprime um texto na tela.
Existem alguns detalhes a se notar aqui. O primeiro Ã© que o estilo de indentaÃ§Ã£o
do Rust usa quatro espaÃ§os, e nÃ£o um <em>tab</em>.</p>
<p>A segunda parte importante Ã© o <code>println!</code>. Este comando estÃ¡ chamando uma
<em>macro</em>, que Ã© a forma de se fazer metaprogramaÃ§Ã£o em Rust. Se estivÃ©ssemos
chamando uma funÃ§Ã£o, ficaria assim: <code>println</code> (sem o <code>!</code>). Vamos discutir
<em>macros</em> em Rust com mais detalhes no ApÃªndice D, mas por agora, vocÃª sÃ³ precisa
saber que quando usamos um <code>!</code>, significa que estamos chamando uma <em>macro</em> em
vez de uma funÃ§Ã£o.</p>
<p>Em seguida vem <code>&quot;OlÃ¡, mundo!&quot;</code>, que Ã© uma <em>string</em>. NÃ³s passamos esta <em>string</em>
como um argumento para a <em>macro</em> <code>println!</code>, que por sua vez imprime a <em>string</em>
na tela. FÃ¡cil!</p>
<p>A linha termina com um ponto e vÃ­rgula (<code>;</code>). O <code>;</code> indica que esta expressÃ£o
acabou, e que a prÃ³xima estÃ¡ pronta para comeÃ§ar. A maioria das linhas de cÃ³digo
em Rust terminam com um <code>;</code>.</p>
<a class="header" href="ch01-02-hello-world.html#compilaÃ§Ã£o-e-execuÃ§Ã£o-sÃ£o-etapas-diferentes" id="compilaÃ§Ã£o-e-execuÃ§Ã£o-sÃ£o-etapas-diferentes"><h3>CompilaÃ§Ã£o e ExecuÃ§Ã£o SÃ£o Etapas Diferentes</h3></a>
<p>Na seÃ§Ã£o &quot;Escrevendo e Executando um Programa em Rust&quot;, mostramos como vocÃª pode
executar um programa que vocÃª acabou de criar. A partir de agora, vamos dividir
este processo em partes e examinar cada uma delas.</p>
<p>Antes de executar qualquer programa em Rust, vocÃª deve compilÃ¡-lo. VocÃª pode
usar o compilador do Rust utilizando o comando <code>rustc</code>, passando o nome do seu
arquivo fonte conforme o exemplo abaixo:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Se vocÃª jÃ¡ programou em C ou C++, irÃ¡ notar que esta etapa Ã© bem similar ao uso
do <code>gcc</code> ou <code>clang</code>. ApÃ³s a compilaÃ§Ã£o ser realizada com sucesso, o Rust deve
gerar como saÃ­da um binÃ¡rio executÃ¡vel, que vocÃª pode conferir com o comando
<code>ls</code> no seu terminal, se estiver em um ambiente Linux ou OSX:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= a opÃ§Ã£o /B serve para mostrar apenas nomes de arquivos =%
main.exe
main.rs
</code></pre>
<p>Temos aqui dois arquivos: o cÃ³digo-fonte, que termina com a extensÃ£o <em>.rs</em>, e o
arquivo executÃ¡vel (<em>main.exe</em> no Windows, <em>main</em> nos demais sistemas). O que
nos resta fazer Ã© executar o arquivo <em>main</em> ou <em>main.exe</em>, desta forma:</p>
<pre><code class="language-text">$ ./main  # ou .\main.exe no Windows
</code></pre>
<p>Se o arquivo <em>main.rs</em> tiver o cÃ³digo do programa &quot;OlÃ¡, mundo!&quot;, vai aparecer no
seu terminal a mensagem <code>OlÃ¡, mundo!</code>.</p>
<p>Se vocÃª vem de uma linguagem dinÃ¢mica como Ruby, Python, ou JavaScript, vocÃª
provavelmente nÃ£o estÃ¡ acostumado a ver a compilaÃ§Ã£o e a execuÃ§Ã£o como etapas
separadas. Rust Ã© uma linguagem <em>ahead-of-time compiled</em>, isso significa que
vocÃª pode compilar um programa, enviÃ¡-lo para alguÃ©m, e essa pessoa pode
executar o seu programa mesmo que nÃ£o tenha o Rust instalado em seu ambiente. Se
vocÃª enviar a alguÃ©m um arquivo <code>.rb</code>, <code>.py</code>, ou <code>.js</code>, a pessoa vai precisar
ter instalado um interpretador Ruby, Python, ou JavaScript (respectivamente),
mas nesse caso vocÃª sÃ³ precisa de um Ãºnico comando para compilar e executar o
seu programa. Em design de linguagens de programaÃ§Ã£o, tudo Ã© uma relaÃ§Ã£o de
compromisso.</p>
<p>Compilar usando <code>rustc</code> serve bem para programas simples, mas conforme o seu
projeto cresce, com certeza vocÃª vai querer gerenciar todas as opÃ§Ãµes possÃ­veis
para o seu projeto e compartilhar facilmente o seu cÃ³digo com outras pessoas e
projetos. Na sequÃªncia, vamos lhe apresentar uma ferramenta chamada Cargo, que
ajuda a escrever programas em Rust usados no mundo real.</p>
<a class="header" href="ch01-02-hello-world.html#olÃ¡-cargo" id="olÃ¡-cargo"><h2>OlÃ¡, Cargo!</h2></a>
<p>Cargo Ã© o sistema de <em>build</em> e gerenciador de pacotes (<em>package manager</em>) do
Rust. NÃ³s, Rustaceans, usamos Cargo para gerenciar nossos projetos em Rust
porque ele facilita muito as coisas. Por exemplo, Cargo se encarrega do processo
de <em>build</em> do seu cÃ³digo, baixa as bibliotecas das quais seu cÃ³digo depende e
compila essas bibliotecas. As bibliotecas necessÃ¡rias ao seu cÃ³digo nÃ³s chamamos
de <em>dependÃªncias</em>.</p>
<p>Programas simples em Rust, como o que escrevemos a pouco, nÃ£o tÃªm nenhuma
dependÃªncia, entÃ£o por enquanto, vocÃª sÃ³ vai usar a parte do Cargo que cuida do
<em>build</em> do seu cÃ³digo. Ã€ medida que vocÃª escrever programas mais complexos em
Rust, vocÃª vai querer adicionar dependÃªncias, e utilizando o Cargo, serÃ¡ bem
mais fÃ¡cil fazer isso.</p>
<p>Como a vasta maioria dos projetos em Rust usam Cargo, vamos assumir que vocÃª vai
usÃ¡-lo pelo resto do livro. O Cargo jÃ¡ vem instalado com o prÃ³prio Rust, se vocÃª
utilizou algum dos instaladores oficiais abordados na seÃ§Ã£o sobre instalaÃ§Ã£o. Se
vocÃª utilizou outros meios para instalar Rust, vocÃª pode verificar se tem o
Cargo instalado digitando o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Se aparecer um nÃºmero de versÃ£o, Ã³timo! Mas, se aparecer um erro como <code>command not found</code>, vocÃª deve olhar a documentaÃ§Ã£o do mÃ©todo de instalaÃ§Ã£o utilizado,
para verificar como instalar Cargo em seu ambiente.</p>
<a class="header" href="ch01-02-hello-world.html#criando-um-projeto-com-cargo" id="criando-um-projeto-com-cargo"><h3>Criando um Projeto com Cargo</h3></a>
<p>Vamos criar um novo projeto usando Cargo e ver o que muda em relaÃ§Ã£o ao nosso
primeiro projeto <code>ola_mundo</code>. Volte ao seu diretÃ³rio de projetos (ou aonde quer
que vocÃª tenha colocado o seu cÃ³digo):</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ cd ~/projetos
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projetos
</code></pre>
<p>E entÃ£o execute o comando abaixo:</p>
<pre><code class="language-text">$ cargo new ola_cargo --bin
$ cd ola_cargo
</code></pre>
<p>Passamos o argumento <code>--bin</code> para o comando <code>cargo new</code> porque o nosso objetivo
Ã© fazer uma aplicaÃ§Ã£o executÃ¡vel, em vez de uma biblioteca. ExecutÃ¡veis sÃ£o
arquivos binÃ¡rios, muitas vezes chamados apenas de <em>binÃ¡rios</em>. Demos o nome
<code>ola_cargo</code> ao nosso projeto, e o Cargo jÃ¡ criou os arquivos dele em uma nova
pasta com o mesmo nome, que agora podemos acessar.</p>
<p>Se listarmos os arquivos na pasta <em>ola_cargo</em>, podemos ver que o Cargo gerou
dois arquivos e um diretÃ³rio para nÃ³s: um arquivo <em>Cargo.toml</em> e um diretÃ³rio
<em>src</em>, com um arquivo <em>main.rs</em> dentro dele. TambÃ©m automaticamente jÃ¡
inicializou um repositÃ³rio git na pasta <em>ola_cargo</em>, junto com um arquivo
<em>.gitignore</em>. VocÃª pode mudar isso se quiser usar um sistema de controle de
versÃ£o diferente, ou se nÃ£o quiser usar nenhum. Basta usar a flag <code>--vcs</code>.</p>
<p>Abra o arquivo <em>Cargo.toml</em> no seu editor de texto. O conteÃºdo dele Ã© algo
assim:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Este arquivo estÃ¡ no formato <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tomâ€™s Obvious,
Minimal Language</em>). TOML Ã© similar a INI com algumas coisinhas a mais e Ã©
usado como formato de configuraÃ§Ã£o do Cargo.</p>
<p>A primeira linha, <code>[package]</code>, Ã© um cabeÃ§alho de seÃ§Ã£o que indica que o que vem
em seguida estÃ¡ configurando um pacote. Ao passo que adicionamos mais
informaÃ§Ãµes a este arquivo, vamos adicionar outras seÃ§Ãµes a ele.</p>
<p>As prÃ³ximas trÃªs linhas indicam as trÃªs configuraÃ§Ãµes de que o Cargo precisa
para saber como compilar o seu programa: nome, versÃ£o, e o autor. O Cargo
consegue o seu nome e <em>e-mail</em> atravÃ©s do seu ambiente. Se nÃ£o estiver correto,
corrija e depois salve o arquivo.</p>
<p>A Ãºltima linha, <code>[dependencies]</code>, Ã© o comeÃ§o da seÃ§Ã£o em que vocÃª deve listar
quaisquer <em>crates</em> (como chamamos os pacotes de cÃ³digo em Rust) das quais o seu
projeto irÃ¡ depender, assim o Cargo sabe que deve baixar e compilar estes
pacotes tambÃ©m. NÃ£o vamos precisar de nenhum <em>crate</em> para este projeto, mas sim
para o projeto do jogo de advinhaÃ§Ã£o que faremos no prÃ³ximo capÃ­tulo.</p>
<p>Agora vamos dar uma olhada em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>O Cargo gerou um &quot;OlÃ¡, mundo!&quot; para vocÃª, igual ao que escrevemos anteriormente
(porÃ©m em inglÃªs)! Esta parte Ã© a mesma. As diferenÃ§as entre o nosso projeto
anterior e o projeto gerado pelo Cargo, que vimos atÃ© agora, foram:</p>
<ul>
<li>Nosso cÃ³digo fica dentro do diretÃ³rio <em>src</em></li>
<li>A pasta raiz do nosso projeto contÃ©m um arquivo de configuraÃ§Ã£o <em>Cargo.toml</em></li>
</ul>
<p>O Cargo espera que os seus arquivos de cÃ³digo fiquem no diretÃ³rio <em>src</em>, de
maneira que a pasta raiz seja apenas para <em>READMEs</em>, informaÃ§Ãµes a respeito de
licenÃ§a, arquivos de configuraÃ§Ã£o, e tudo mais que nÃ£o for relacionado a cÃ³digo.
Assim, o uso de Cargo lhe ajuda a manter os seus projetos bem organizados. HÃ¡ um
lugar pra cada coisa, e cada coisa fica em seu lugar.</p>
<p>Se vocÃª iniciou um projeto que nÃ£o usa Cargo, como fizemos com nosso projeto na
pasta <em>ola_mundo</em>, vocÃª pode convertÃª-lo em um projeto que usa o Cargo. Basta
mover o seu cÃ³digo para um diretÃ³rio <em>src</em> e criar um arquivo <em>Cargo.toml</em>.</p>
<a class="header" href="ch01-02-hello-world.html#realizando-o-build-e-executando-um-projeto-cargo" id="realizando-o-build-e-executando-um-projeto-cargo"><h3>Realizando o Build e Executando um projeto Cargo</h3></a>
<p>Agora vamos ver o que muda ao compilar e executar o seu projeto &quot;OlÃ¡, Mundo!&quot;
atravÃ©s do Cargo! Para isso, digite os seguintes comandos:</p>
<pre><code class="language-text">$ cargo build
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando deve criar um arquivo executÃ¡vel em <em>target/debug/ola_cargo</em> (ou
<em>target\debug\ola_cargo.exe</em> no Windows), que vocÃª pode executar com o seguinte
comando:</p>
<pre><code class="language-text">$ ./target/debug/ola_cargo # ou .\target\debug\ola_cargo.exe no Windows
Hello, world!
</code></pre>
<p>Bam! Se tudo ocorrer bem, a mensagem <code>Hello, world!</code> deve aparecer no seu terminal.</p>
<p>Executar <code>cargo build</code> pela primeira vez tambÃ©m faz com que Cargo crie um novo
arquivo chamado <em>Cargo.lock</em>, com um conteÃºdo desse tipo:</p>
<p><span class="filename">Arquivo: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>O Cargo usa o arquivo <em>Cargo.lock</em> para rastrear as dependÃªncias da sua
aplicaÃ§Ã£o. Este projeto nÃ£o tem dependÃªncias, entÃ£o o arquivo Ã© um pouco
escasso. Na realidade, vocÃª nem vai precisar mexer neste arquivo, apenas deixe
que o Cargo se encarregue dele.</p>
<p>NÃ³s acabamos de fazer o <em>build</em> de um projeto utilizando o comando
<code>cargo build</code>, e o executamos com o comando <code>./target/debug/ola_cargo</code>, mas
podemos usar tambÃ©m o comando <code>cargo run</code> para compilar e executar em sequÃªncia:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Repare que, desta vez, nÃ£o vimos nenhuma mensagem de <em>output</em> (saÃ­da) nos
dizendo que Cargo estava compilando <code>ola_cargo</code>. O Cargo entendeu que nÃ£o houve
nenhuma mudanÃ§a nos arquivos, entÃ£o ele apenas executou o binÃ¡rio. Se vocÃª
tivesse modificado o seu cÃ³digo-fonte, o Cargo teria recompilado o projeto antes
de executÃ¡-lo, e vocÃª teria visto algo do tipo:</p>
<pre><code class="language-text">$ cargo run
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>EntÃ£o, mais algumas diferenÃ§as que vimos atÃ© agora foram:</p>
<ul>
<li>Em vez de usar <code>rustc</code>, faÃ§a o <em>build</em> do projeto usando <code>cargo build</code> (ou
faÃ§a o build e execute de uma vez sÃ³ utilizando <code>cargo run</code>)</li>
<li>Em vez de colocar o resultado do <em>build</em> no mesmo diretÃ³rio do nosso cÃ³digo, o
Cargo irÃ¡ colocar o resultado do <em>build</em> no diretÃ³rio <em>target/debug</em>.</li>
</ul>
<p>A outra vantagem de usar o Cargo Ã© que os comandos sÃ£o os mesmos, nÃ£o importa em
qual sistema operacional vocÃª esteja. Por conta disso, a partir de agora, nÃ£o
vamos mais fornecer instruÃ§Ãµes especÃ­ficas para Linux e Mac ou Windows.</p>
<a class="header" href="ch01-02-hello-world.html#compilando-para-release" id="compilando-para-release"><h3>Compilando para <em>Release</em></h3></a>
<p>Quando o seu projeto estÃ¡ finalmente pronto para ser lanÃ§ado, vocÃª pode usar o
comando <code>cargo build --release</code> para compilar o seu projeto com otimizaÃ§Ãµes.
Isso vai criar um arquivo executÃ¡vel na pasta <em>target/release</em> em vez de
<em>target/debug</em>. Estas otimizaÃ§Ãµes fazem o seu cÃ³digo Rust executar de maneira
mais rÃ¡pida, mas por outro lado, tambÃ©m fazem o programa levar mais tempo para
compilar. Por isso existem dois perfis diferentes: um para desenvolvimento,
quando vocÃª deseja recompilar rapidamente e com mais frequÃªncia, e outro para
compilar a versÃ£o final do seu programa, que vai ser entregue ao usuÃ¡rio e nÃ£o
serÃ¡ recompilada, e queremos que rode da maneira mais rÃ¡pida possÃ­vel. Se vocÃª
estÃ¡ fazendo um <em>benchmarking</em> do tempo de execuÃ§Ã£o do seu cÃ³digo, certifique-se
de executar o comando <code>cargo build --release</code>, e usar o executÃ¡vel que se
encontra na pasta <em>target/release</em>.</p>
<a class="header" href="ch01-02-hello-world.html#cargo-como-convenÃ§Ã£o" id="cargo-como-convenÃ§Ã£o"><h3>Cargo como ConvenÃ§Ã£o</h3></a>
<p>Em projetos simples, o Cargo nÃ£o oferece tanto valor assim em relaÃ§Ã£o a usar
apenas o <code>rustc</code>, mas vai fazer diferenÃ§a Ã  medida que vocÃª continua. Em
projetos mais complexos, compostos de mÃºltiplos <em>crates</em>, Ã© bem mais fÃ¡cil
deixar o Cargo coordenar o processo de <em>build</em>. Com o Cargo, vocÃª pode apenas
executar o comando <code>cargo build</code>, e tudo deverÃ¡ funcionar da maneira correta.
Mesmo esse projeto sendo simples, ele utiliza muito das ferramentas que vocÃª
irÃ¡ usar pelo resto da sua carreira em Rust. Na verdade, vocÃª pode comeÃ§ar a
trabalhar em praticamente qualquer projeto em Rust usando os seguintes comandos:</p>
<pre><code class="language-text">$ git clone algumaurl.com/algumprojeto
$ cd algumprojeto
$ cargo build
</code></pre>
<blockquote>
<p>Nota: Se vocÃª deseja conhecer o Cargo em mais detalhes, confira o
<a href="http://doc.crates.io/guide.html">Guia oficial do Cargo</a><!-- ignore --> (em inglÃªs), que aborda todas as suas
caracterÃ­sticas.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-01-installation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch02-00-guessing-game-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch01-01-installation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch02-00-guessing-game-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
