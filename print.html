<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introdu√ß√£o" id="introdu√ß√£o"><h1>Introdu√ß√£o</h1></a>
<p>Seja bem vindo(a) ao ‚ÄúLinguagem de Programa√ß√£o Rust‚Äù, um livro introdut√≥rio
sobre Rust. Rust √© uma linguagem de programa√ß√£o focada em seguran√ßa, efici√™ncia
e concorr√™ncia. Seu <em>design</em> lhe permite criar programas com o desempenho e
controle de uma linguagem de baixo n√≠vel, mas com as abstra√ß√µes poderosas de uma
linguagem de alto n√≠vel. Estas propriedades tornam Rust adequado para
programadores que t√™m experi√™ncia em linguagens como C e procuram por uma
alternativa mais segura, bem como para aqueles que v√™m de linguagens como o
Python e que procuram por maneiras de escrever c√≥digo com melhor desempenho sem
sacrificar a expressividade.</p>
<p>Rust executa a maioria das suas verifica√ß√µes de seguran√ßa e decis√µes de
gerenciamento de mem√≥ria em tempo de compila√ß√£o, para que o desempenho de
execu√ß√£o do seu programa n√£o seja impactado. Isso torna a linguagem √∫til em um
n√∫mero de casos para os quais outras linguagens n√£o s√£o adequadas: programas com
requisitos de tempo e espa√ßo previs√≠veis, incorpora√ß√£o de c√≥digo em outras
linguagens e a escrita de c√≥digo de baixo n√≠vel, como <em>drivers</em> de dispositivo e
sistemas operacionais. A linguagem Rust tamb√©m √© fant√°stica para aplica√ß√µes web:
ela est√° por tr√°s do site do registro de pacotes do Rust, <a href="https://crates.io/">crates.io</a>! Estamos
curiosos para saber o que <em>voc√™</em> far√° com Rust.</p>
<p>Este livro tem como p√∫blico-alvo um leitor que j√° sabe como programar em pelo
menos uma linguagem de programa√ß√£o. Ap√≥s ler este livro, voc√™ deve se sentir
confiante para escrever programas em Rust. Ensinaremos Rust atrav√©s de exemplos
focados e pequenos, que se complementam gradualmente para demonstrar o uso de
v√°rias caracter√≠sticas da linguagem Rust, bem como como eles funcionam ‚Äúnos
bastidores‚Äù.</p>
<a class="header" href="print.html#sobre-a-tradu√ß√£o" id="sobre-a-tradu√ß√£o"><h2>Sobre a Tradu√ß√£o</h2></a>
<p>Esta √© uma tradu√ß√£o <em>n√£o oficial</em> da <a href="https://rust-lang.github.io/book">nova vers√£o</a> do livro  ‚ÄúThe Rust
Programming Language‚Äù. V√°rias por√ß√µes desta tradu√ß√£o (assim como do original)
ainda est√£o incompletas. A <a href="https://doc.rust-lang.org/book">vers√£o antiga</a> do livro (em ingl√™s) ainda √© a
leitura de refer√™ncia recomendada da linguagem.</p>
<p>Sempre que poss√≠vel, nos exemplos de c√≥digo, optamos por usar nomes de
vari√°veis, fun√ß√µes e arquivos em portugu√™s. Essa escolha foi feita para fins
did√°ticos, e se limita √†s por√ß√µes de c√≥digo de exemplo apresentadas. Os nomes
provenientes da biblioteca padr√£o da linguagem, bem como de <em>crates</em> j√°
existentes s√£o mantidos no original em ingl√™s, para que o c√≥digo funcione
corretamente. (Ex: <code>Usuario</code> em vez de <code>User</code>, mas manteremos nomes como <code>Box</code>
em ingl√™s). Para fins de compatibilidade, utilizaremos somente caracteres sem
acento e cedilha.</p>
<p>Apesar da escolha did√°tica do livro, recomendamos que, ao escrever c√≥digo ‚Äúde
verdade‚Äù em Rust, utilize sempre que poss√≠vel nomes em ingl√™s, especialmente
para projetos <em>open source</em> a fim de tornar seu c√≥digo acess√≠vel para uma maior
audi√™ncia.</p>
<a class="header" href="print.html#contribuindo-com-o-livro" id="contribuindo-com-o-livro"><h2>Contribuindo com o Livro</h2></a>
<p>Este livro √© <em>open source</em>. Se encontrar um erro, por favor n√£o hesite em abrir
uma <em>issue</em> ou enviar um <em>pull request</em> <a href="https://github.com/rust-br/rust-book-pt-br">no GitHub</a>. Leia
<a href="https://github.com/rust-br/rust-book-pt-br/blob/master/CONTRIBUTING-pt-br.md">CONTRIBUTING-pt-br.md</a> para mais detalhes.</p>
<a class="header" href="print.html#instala√ß√£o" id="instala√ß√£o"><h2>Instala√ß√£o</h2></a>
<p>O primeiro passo para se usar a linguagem Rust √© instal√°-la. Voc√™ vai precisar
de uma conex√£o com a internet para executar os comandos contidos neste
cap√≠tulo, pois vamos baixar o Rust da internet.</p>
<p>Iremos mostrar diversos comandos usando o terminal, e todas as linhas que se
referem ao terminal iniciam com <code>$</code>. Voc√™ n√£o precisa digitar o caractere <code>$</code>,
ele serve apenas para indicar o in√≠cio de cada comando. Voc√™ vai notar que
muitos tutorias dispon√≠veis por a√≠ seguem esta conven√ß√£o: <code>$</code> para comandos que
s√£o executados como um usu√°rio normal, e <code>#</code> para comandos que voc√™ deve
executar como administrador. As linhas que n√£o iniciam com o caractere <code>$</code>
mostram o <em>output</em> (sa√≠da) do comando anterior.</p>
<a class="header" href="print.html#instalando-no-linux-ou-mac" id="instalando-no-linux-ou-mac"><h3>Instalando no Linux ou Mac</h3></a>
<p>Se voc√™ est√° em um ambiente Linux ou Mac, tudo o que voc√™ precisa √© abrir um
terminal e digitar o seguinte comando:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Este comando vai baixar um script e iniciar a instala√ß√£o. Talvez seja solicitado
que voc√™ digite sua senha. Se tudo ocorrer bem, a mensagem abaixo vai aparecer:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>Claro, se voc√™ n√£o aprova o uso do <code>curl | sh</code>, voc√™ pode baixar o <em>script</em>,
inspecion√°-lo e execut√°-lo da maneira que achar melhor.</p>
<p>O <em>script</em> de instala√ß√£o j√° adiciona automaticamente o Rust √† vari√°vel PATH do
seu sistema logo ap√≥s o seu pr√≥ximo <em>login</em>. Se voc√™ quiser usar o Rust
imediatamente, execute o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Outra op√ß√£o √© adicionar a linha abaixo no seu <code>~/.bash_profile</code>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<a class="header" href="print.html#instalando-no-windows" id="instalando-no-windows"><h3>Instalando no Windows</h3></a>
<p>No Windows, visite o <em>site</em>
<a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> e siga as instru√ß√µes para
baixar o arquivo rustup-init.exe. Execute este arquivo e siga as demais
instru√ß√µes que aparecerem na sua tela.</p>
<p>O restante dos comandos espec√≠ficos do Windows neste livro partem da premissa de
que voc√™ est√° utilizando o <code>cmd</code> como o seu <em>shell</em>. Se voc√™ est√° usando um
<em>shell</em> diferente, talvez voc√™ poder√° usar os mesmos comandos que os usu√°rios de
Linux ou Mac usam. Se algum comando n√£o funcionar, consulte a documenta√ß√£o
referente ao <em>shell</em> que voc√™ est√° utilizando.</p>
<a class="header" href="print.html#instala√ß√£o-customizada" id="instala√ß√£o-customizada"><h3>Instala√ß√£o customizada</h3></a>
<p>Se, por alguma raz√£o, voc√™ preferir n√£o usar o rustup.rs, consulte <a href="https://www.rust-lang.org/pt-BR/install.html">a p√°gina de
instala√ß√£o do Rust</a> para outras
op√ß√µes de instala√ß√£o.</p>
<a class="header" href="print.html#atualizando-o-rust" id="atualizando-o-rust"><h3>Atualizando o Rust</h3></a>
<p>Tendo o Rust instalado na sua m√°quina, atualizar para a √∫ltima vers√£o √© f√°cil.
Do seu <em>shell</em>, execute o <em>script</em> de atualiza√ß√£o:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<a class="header" href="print.html#desinstalando" id="desinstalando"><h3>Desinstalando</h3></a>
<p>Desinstalar Rust √© t√£o f√°cil quanto instal√°-lo. Do seu <em>shell</em>, execute o
<em>script</em> de desinstala√ß√£o:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<a class="header" href="print.html#solu√ß√£o-de-problemas" id="solu√ß√£o-de-problemas"><h3>Solu√ß√£o de Problemas</h3></a>
<p>Ap√≥s Rust ser instalado em sua m√°quina, voc√™ pode abrir o seu <em>shell</em>, e digitar
a linha abaixo:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Voc√™ dever√° ver a vers√£o, o <em>hash</em> e a data do <em>commit</em> em um formato
similar ao seguinte, indicando a √∫ltima est√°vel mais recente no momento da
instala√ß√£o:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Se aparecer a mensagem acima, Rust foi instalado com sucesso!
Parab√©ns!</p>
<p>Se n√£o aparecer a mensagem acima e voc√™ est√° em um ambiente Windows, verifique
se o Rust aparece na vari√°vel <code>%PATH%</code> do seu sistema.</p>
<p>Se mesmo assim n√£o funcionar, existem v√°rios lugares onde voc√™ pode pedir ajuda.
A maneira mais f√°cil √© pedir ajuda no
<a href="irc://irc.mozilla.org/#rust">canal IRC #rust do irc.mozilla.org</a><!-- ignore -->, que voc√™ pode acessar
via <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Voc√™ vai falar com v√°rios outros <em>Rustaceans</em> (um apelido
bobo que usamos entre n√≥s) que podem ajud√°-lo em suas d√∫vidas. Voc√™ tamb√©m pode
buscar ajuda no <a href="https://users.rust-lang.org/">f√≥rum do Rust</a> e no <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<a class="header" href="print.html#documenta√ß√£o-local" id="documenta√ß√£o-local"><h3>Documenta√ß√£o local</h3></a>
<p>O instalador tamb√©m inclui uma c√≥pia local da documenta√ß√£o para que voc√™ possa
acess√°-la <em>offline</em>. Execute o comando <code>rustup doc</code> para abrir a documenta√ß√£o
local no seu navegador.</p>
<p>Sempre que voc√™ se deparar com um tipo ou fun√ß√£o fornecido pela biblioteca
padr√£o que voc√™ n√£o tem certeza do que ele faz, use a documenta√ß√£o da API para
descobrir!</p>
<a class="header" href="print.html#ol√°-mundo" id="ol√°-mundo"><h2>Ol√°, Mundo!</h2></a>
<p>Agora que Rust j√° est√° instalado, vamos escrever nosso primeiro programa. Quando
aprendemos uma nova linguagem de programa√ß√£o, √© tradicional escrever um pequeno
programa que imprime &quot;Ol√°, mundo!&quot; (<em>‚ÄúHello, world!‚Äù</em>) na tela, e √© exatamente
isso que vamos fazer nesta se√ß√£o.</p>
<blockquote>
<p>Nota: Este livro assume que o leitor tem um pouco de familiaridade com a
linha de comando. Rust n√£o exige que voc√™ use um determinado editor ou IDE,
ou seja, voc√™ est√° livre para usar o que bem entender para escrever seu c√≥digo
Rust.</p>
</blockquote>
<a class="header" href="print.html#criando-um-diret√≥rio-de-projeto" id="criando-um-diret√≥rio-de-projeto"><h3>Criando um Diret√≥rio de Projeto</h3></a>
<p>Primeiramente, crie uma pasta para colocar o seu c√≥digo Rust. O Rust n√£o se
importa onde voc√™ vai armazenar o seu c√≥digo, mas neste livro, n√≥s sugerimos
criar um diret√≥rio chamado <em>projetos</em> e armazenar todos os seus projetos ali.
Abra o seu terminal e digite os seguintes comandos:</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ mkdir ~/projetos
$ cd ~/projetos
$ mkdir ola_mundo
$ cd ola_mundo
</code></pre>
<p>Windows CMD:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projetos
&gt; cd %USERPROFILE%\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<p>Windows PowerShell:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projetos
&gt; cd $env:USERPROFILE\projetos
&gt; mkdir ola_mundo
&gt; cd ola_mundo
</code></pre>
<a class="header" href="print.html#escrevendo-e-executando-um-programa-em-rust" id="escrevendo-e-executando-um-programa-em-rust"><h3>Escrevendo e Executando um Programa em Rust</h3></a>
<p>Crie um novo arquivo <em>main.rs</em>. Arquivos relacionados √† linguagem Rust sempre
terminam com a extens√£o <em>.rs</em>. Se o nome do seu arquivo tem mais de uma palavra,
use um <em>underscore</em> (<code>_</code>) para separ√°-los. Por exemplo, voc√™ deve nomear o seu
arquivo <em>ola_mundo.rs</em> em vez de <em>olamundo.rs</em>.</p>
<p>Agora abra o arquivo <em>main.rs</em> que voc√™ acabou de criar e digite o seguinte
c√≥digo:</p>
<p><span class="filename">Arquivo: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Ol√°, mundo!&quot;);
}
</code></pre></pre>
<p>Salve o arquivo e volte ao seu terminal. No Linux ou OSX, digite os seguintes
comandos:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Ol√°, mundo!
</code></pre>
<p>Para executar o seu programa no Windows, digite <code>.\main.exe</code> em vez de <code>./main</code>.
Independente do seu sistema operacional, voc√™ dever√° ver a mensagem
<code>Ol√°, mundo!</code> no seu terminal. Se voc√™ chegou at√© aqui, parab√©ns! Voc√™ escreveu
o seu primeiro programa em Rust. Isso faz de voc√™ um programador Rust! Seja
bem-vindo!</p>
<a class="header" href="print.html#anatomia-de-um-programa-em-rust" id="anatomia-de-um-programa-em-rust"><h3>Anatomia de um Programa em Rust</h3></a>
<p>Agora vamos ver o que aconteceu com o seu programa &quot;Ol√°, mundo!&quot; em detalhes.
Aqui est√° a primeira pe√ßa do quebra-cabe√ßa:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Estas linhas definem uma <em>fun√ß√£o</em> em Rust. A fun√ß√£o <code>main</code> √© especial: √© a
primeira coisa que √© executada em cada programa escrito em Rust. A primeira
linha diz: &quot;Estou declarando uma fun√ß√£o chamada <code>main</code> que n√£o cont√©m nenhum
par√¢metro e que n√£o retorna nada.&quot; Se existissem par√¢metros, eles estariam
dentro dos par√™nteses, <code>(</code> e <code>)</code>.</p>
<p>Tamb√©m repare que o corpo da fun√ß√£o est√° envolvido por duas chaves, <code>{</code> e <code>}</code>.
Rust requer essas chaves no come√ßo e no fim do corpo de cada fun√ß√£o.
Considera-se boa pr√°tica colocar a chave inicial na mesma linha da declara√ß√£o
da fun√ß√£o, com um espa√ßo entre elas.</p>
<p>Dentro da fun√ß√£o <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Ol√°, mundo!&quot;);
#}</code></pre></pre>
<p>Esta linha faz todo o trabalho nesse pequeno programa: imprime um texto na tela.
Existem alguns detalhes a se notar aqui. O primeiro √© que o estilo de indenta√ß√£o
do Rust usa quatro espa√ßos, e n√£o um <em>tab</em>.</p>
<p>A segunda parte importante √© o <code>println!</code>. Este comando est√° chamando uma
<em>macro</em>, que √© a forma de se fazer metaprograma√ß√£o em Rust. Se estiv√©ssemos
chamando uma fun√ß√£o, ficaria assim: <code>println</code> (sem o <code>!</code>). Vamos discutir
<em>macros</em> em Rust com mais detalhes no Ap√™ndice D, mas por agora, voc√™ s√≥ precisa
saber que quando usamos um <code>!</code>, significa que estamos chamando uma <em>macro</em> em
vez de uma fun√ß√£o.</p>
<p>Em seguida vem <code>&quot;Ol√°, mundo!&quot;</code>, que √© uma <em>string</em>. N√≥s passamos esta <em>string</em>
como um argumento para a <em>macro</em> <code>println!</code>, que por sua vez imprime a <em>string</em>
na tela. F√°cil!</p>
<p>A linha termina com um ponto e v√≠rgula (<code>;</code>). O <code>;</code> indica que esta express√£o
acabou, e que a pr√≥xima est√° pronta para come√ßar. A maioria das linhas de c√≥digo
em Rust terminam com um <code>;</code>.</p>
<a class="header" href="print.html#compila√ß√£o-e-execu√ß√£o-s√£o-etapas-diferentes" id="compila√ß√£o-e-execu√ß√£o-s√£o-etapas-diferentes"><h3>Compila√ß√£o e Execu√ß√£o S√£o Etapas Diferentes</h3></a>
<p>Na se√ß√£o &quot;Escrevendo e Executando um Programa em Rust&quot;, mostramos como voc√™ pode
executar um programa que voc√™ acabou de criar. A partir de agora, vamos dividir
este processo em partes e examinar cada uma delas.</p>
<p>Antes de executar qualquer programa em Rust, voc√™ deve compil√°-lo. Voc√™ pode
usar o compilador do Rust utilizando o comando <code>rustc</code>, passando o nome do seu
arquivo fonte conforme o exemplo abaixo:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Se voc√™ j√° programou em C ou C++, ir√° notar que esta etapa √© bem similar ao uso
do <code>gcc</code> ou <code>clang</code>. Ap√≥s a compila√ß√£o ser realizada com sucesso, o Rust deve
gerar como sa√≠da um bin√°rio execut√°vel, que voc√™ pode conferir com o comando
<code>ls</code> no seu terminal, se estiver em um ambiente Linux ou OSX:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>No Windows, digite o seguinte:</p>
<pre><code class="language-cmd">&gt; dir /B %= a op√ß√£o /B serve para mostrar apenas nomes de arquivos =%
main.exe
main.rs
</code></pre>
<p>Temos aqui dois arquivos: o c√≥digo-fonte, que termina com a extens√£o <em>.rs</em>, e o
arquivo execut√°vel (<em>main.exe</em> no Windows, <em>main</em> nos demais sistemas). O que
nos resta fazer √© executar o arquivo <em>main</em> ou <em>main.exe</em>, desta forma:</p>
<pre><code class="language-text">$ ./main  # ou .\main.exe no Windows
</code></pre>
<p>Se o arquivo <em>main.rs</em> tiver o c√≥digo do programa &quot;Ol√°, mundo!&quot;, vai aparecer no
seu terminal a mensagem <code>Ol√°, mundo!</code>.</p>
<p>Se voc√™ vem de uma linguagem din√¢mica como Ruby, Python, ou JavaScript, voc√™
provavelmente n√£o est√° acostumado a ver a compila√ß√£o e a execu√ß√£o como etapas
separadas. Rust √© uma linguagem <em>ahead-of-time compiled</em>, isso significa que
voc√™ pode compilar um programa, envi√°-lo para algu√©m, e essa pessoa pode
executar o seu programa mesmo que n√£o tenha o Rust instalado em seu ambiente. Se
voc√™ enviar a algu√©m um arquivo <code>.rb</code>, <code>.py</code>, ou <code>.js</code>, a pessoa vai precisar
ter instalado um interpretador Ruby, Python, ou JavaScript (respectivamente),
mas nesse caso voc√™ s√≥ precisa de um √∫nico comando para compilar e executar o
seu programa. Em design de linguagens de programa√ß√£o, tudo √© uma rela√ß√£o de
compromisso.</p>
<p>Compilar usando <code>rustc</code> serve bem para programas simples, mas conforme o seu
projeto cresce, com certeza voc√™ vai querer gerenciar todas as op√ß√µes poss√≠veis
para o seu projeto e compartilhar facilmente o seu c√≥digo com outras pessoas e
projetos. Na sequ√™ncia, vamos lhe apresentar uma ferramenta chamada Cargo, que
ajuda a escrever programas em Rust usados no mundo real.</p>
<a class="header" href="print.html#ol√°-cargo" id="ol√°-cargo"><h2>Ol√°, Cargo!</h2></a>
<p>Cargo √© o sistema de <em>build</em> e gerenciador de pacotes (<em>package manager</em>) do
Rust. N√≥s, Rustaceans, usamos Cargo para gerenciar nossos projetos em Rust
porque ele facilita muito as coisas. Por exemplo, Cargo se encarrega do processo
de <em>build</em> do seu c√≥digo, baixa as bibliotecas das quais seu c√≥digo depende e
compila essas bibliotecas. As bibliotecas necess√°rias ao seu c√≥digo n√≥s chamamos
de <em>depend√™ncias</em>.</p>
<p>Programas simples em Rust, como o que escrevemos a pouco, n√£o t√™m nenhuma
depend√™ncia, ent√£o por enquanto, voc√™ s√≥ vai usar a parte do Cargo que cuida do
<em>build</em> do seu c√≥digo. √Ä medida que voc√™ escrever programas mais complexos em
Rust, voc√™ vai querer adicionar depend√™ncias, e utilizando o Cargo, ser√° bem
mais f√°cil fazer isso.</p>
<p>Como a vasta maioria dos projetos em Rust usam Cargo, vamos assumir que voc√™ vai
us√°-lo pelo resto do livro. O Cargo j√° vem instalado com o pr√≥prio Rust, se voc√™
utilizou algum dos instaladores oficiais abordados na se√ß√£o sobre instala√ß√£o. Se
voc√™ utilizou outros meios para instalar Rust, voc√™ pode verificar se tem o
Cargo instalado digitando o seguinte comando no seu terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Se aparecer um n√∫mero de vers√£o, √≥timo! Mas, se aparecer um erro como <code>command not found</code>, voc√™ deve olhar a documenta√ß√£o do m√©todo de instala√ß√£o utilizado,
para verificar como instalar Cargo em seu ambiente.</p>
<a class="header" href="print.html#criando-um-projeto-com-cargo" id="criando-um-projeto-com-cargo"><h3>Criando um Projeto com Cargo</h3></a>
<p>Vamos criar um novo projeto usando Cargo e ver o que muda em rela√ß√£o ao nosso
primeiro projeto <code>ola_mundo</code>. Volte ao seu diret√≥rio de projetos (ou aonde quer
que voc√™ tenha colocado o seu c√≥digo):</p>
<p>Linux e Mac:</p>
<pre><code class="language-text">$ cd ~/projetos
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projetos
</code></pre>
<p>E ent√£o execute o comando abaixo:</p>
<pre><code class="language-text">$ cargo new ola_cargo --bin
$ cd ola_cargo
</code></pre>
<p>Passamos o argumento <code>--bin</code> para o comando <code>cargo new</code> porque o nosso objetivo
√© fazer uma aplica√ß√£o execut√°vel, em vez de uma biblioteca. Execut√°veis s√£o
arquivos bin√°rios, muitas vezes chamados apenas de <em>bin√°rios</em>. Demos o nome
<code>ola_cargo</code> ao nosso projeto, e o Cargo j√° criou os arquivos dele em uma nova
pasta com o mesmo nome, que agora podemos acessar.</p>
<p>Se listarmos os arquivos na pasta <em>ola_cargo</em>, podemos ver que o Cargo gerou
dois arquivos e um diret√≥rio para n√≥s: um arquivo <em>Cargo.toml</em> e um diret√≥rio
<em>src</em>, com um arquivo <em>main.rs</em> dentro dele. Tamb√©m automaticamente j√°
inicializou um reposit√≥rio git na pasta <em>ola_cargo</em>, junto com um arquivo
<em>.gitignore</em>. Voc√™ pode mudar isso se quiser usar um sistema de controle de
vers√£o diferente, ou se n√£o quiser usar nenhum. Basta usar a flag <code>--vcs</code>.</p>
<p>Abra o arquivo <em>Cargo.toml</em> no seu editor de texto. O conte√∫do dele √© algo
assim:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Este arquivo est√° no formato <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom‚Äôs Obvious,
Minimal Language</em>). TOML √© similar a INI com algumas coisinhas a mais e √©
usado como formato de configura√ß√£o do Cargo.</p>
<p>A primeira linha, <code>[package]</code>, √© um cabe√ßalho de se√ß√£o que indica que o que vem
em seguida est√° configurando um pacote. Ao passo que adicionamos mais
informa√ß√µes a este arquivo, vamos adicionar outras se√ß√µes a ele.</p>
<p>As pr√≥ximas tr√™s linhas indicam as tr√™s configura√ß√µes de que o Cargo precisa
para saber como compilar o seu programa: nome, vers√£o, e o autor. O Cargo
consegue o seu nome e <em>e-mail</em> atrav√©s do seu ambiente. Se n√£o estiver correto,
corrija e depois salve o arquivo.</p>
<p>A √∫ltima linha, <code>[dependencies]</code>, √© o come√ßo da se√ß√£o em que voc√™ deve listar
quaisquer <em>crates</em> (como chamamos os pacotes de c√≥digo em Rust) das quais o seu
projeto ir√° depender, assim o Cargo sabe que deve baixar e compilar estes
pacotes tamb√©m. N√£o vamos precisar de nenhum <em>crate</em> para este projeto, mas sim
para o projeto do jogo de advinha√ß√£o que faremos no pr√≥ximo cap√≠tulo.</p>
<p>Agora vamos dar uma olhada em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>O Cargo gerou um &quot;Ol√°, mundo!&quot; para voc√™, igual ao que escrevemos anteriormente
(por√©m em ingl√™s)! Esta parte √© a mesma. As diferen√ßas entre o nosso projeto
anterior e o projeto gerado pelo Cargo, que vimos at√© agora, foram:</p>
<ul>
<li>Nosso c√≥digo fica dentro do diret√≥rio <em>src</em></li>
<li>A pasta raiz do nosso projeto cont√©m um arquivo de configura√ß√£o <em>Cargo.toml</em></li>
</ul>
<p>O Cargo espera que os seus arquivos de c√≥digo fiquem no diret√≥rio <em>src</em>, de
maneira que a pasta raiz seja apenas para <em>READMEs</em>, informa√ß√µes a respeito de
licen√ßa, arquivos de configura√ß√£o, e tudo mais que n√£o for relacionado a c√≥digo.
Assim, o uso de Cargo lhe ajuda a manter os seus projetos bem organizados. H√° um
lugar pra cada coisa, e cada coisa fica em seu lugar.</p>
<p>Se voc√™ iniciou um projeto que n√£o usa Cargo, como fizemos com nosso projeto na
pasta <em>ola_mundo</em>, voc√™ pode convert√™-lo em um projeto que usa o Cargo. Basta
mover o seu c√≥digo para um diret√≥rio <em>src</em> e criar um arquivo <em>Cargo.toml</em>.</p>
<a class="header" href="print.html#realizando-o-build-e-executando-um-projeto-cargo" id="realizando-o-build-e-executando-um-projeto-cargo"><h3>Realizando o Build e Executando um projeto Cargo</h3></a>
<p>Agora vamos ver o que muda ao compilar e executar o seu projeto &quot;Ol√°, Mundo!&quot;
atrav√©s do Cargo! Para isso, digite os seguintes comandos:</p>
<pre><code class="language-text">$ cargo build
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>Este comando deve criar um arquivo execut√°vel em <em>target/debug/ola_cargo</em> (ou
<em>target\debug\ola_cargo.exe</em> no Windows), que voc√™ pode executar com o seguinte
comando:</p>
<pre><code class="language-text">$ ./target/debug/ola_cargo # ou .\target\debug\ola_cargo.exe no Windows
Hello, world!
</code></pre>
<p>Bam! Se tudo ocorrer bem, a mensagem <code>Hello, world!</code> deve aparecer no seu terminal.</p>
<p>Executar <code>cargo build</code> pela primeira vez tamb√©m faz com que Cargo crie um novo
arquivo chamado <em>Cargo.lock</em>, com um conte√∫do desse tipo:</p>
<p><span class="filename">Arquivo: Cargo.lock</span></p>
<pre><code class="language-toml">[root]
name = &quot;ola_cargo&quot;
version = &quot;0.1.0&quot;
</code></pre>
<p>O Cargo usa o arquivo <em>Cargo.lock</em> para rastrear as depend√™ncias da sua
aplica√ß√£o. Este projeto n√£o tem depend√™ncias, ent√£o o arquivo √© um pouco
escasso. Na realidade, voc√™ nem vai precisar mexer neste arquivo, apenas deixe
que o Cargo se encarregue dele.</p>
<p>N√≥s acabamos de fazer o <em>build</em> de um projeto utilizando o comando
<code>cargo build</code>, e o executamos com o comando <code>./target/debug/ola_cargo</code>, mas
podemos usar tamb√©m o comando <code>cargo run</code> para compilar e executar em sequ√™ncia:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Repare que, desta vez, n√£o vimos nenhuma mensagem de <em>output</em> (sa√≠da) nos
dizendo que Cargo estava compilando <code>ola_cargo</code>. O Cargo entendeu que n√£o houve
nenhuma mudan√ßa nos arquivos, ent√£o ele apenas executou o bin√°rio. Se voc√™
tivesse modificado o seu c√≥digo-fonte, o Cargo teria recompilado o projeto antes
de execut√°-lo, e voc√™ teria visto algo do tipo:</p>
<pre><code class="language-text">$ cargo run
   Compiling ola_cargo v0.1.0 (file:///projetos/ola_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/ola_cargo`
Hello, world!
</code></pre>
<p>Ent√£o, mais algumas diferen√ßas que vimos at√© agora foram:</p>
<ul>
<li>Em vez de usar <code>rustc</code>, fa√ßa o <em>build</em> do projeto usando <code>cargo build</code> (ou
fa√ßa o build e execute de uma vez s√≥ utilizando <code>cargo run</code>)</li>
<li>Em vez de colocar o resultado do <em>build</em> no mesmo diret√≥rio do nosso c√≥digo, o
Cargo ir√° colocar o resultado do <em>build</em> no diret√≥rio <em>target/debug</em>.</li>
</ul>
<p>A outra vantagem de usar o Cargo √© que os comandos s√£o os mesmos, n√£o importa em
qual sistema operacional voc√™ esteja. Por conta disso, a partir de agora, n√£o
vamos mais fornecer instru√ß√µes espec√≠ficas para Linux e Mac ou Windows.</p>
<a class="header" href="print.html#compilando-para-release" id="compilando-para-release"><h3>Compilando para <em>Release</em></h3></a>
<p>Quando o seu projeto est√° finalmente pronto para ser lan√ßado, voc√™ pode usar o
comando <code>cargo build --release</code> para compilar o seu projeto com otimiza√ß√µes.
Isso vai criar um arquivo execut√°vel na pasta <em>target/release</em> em vez de
<em>target/debug</em>. Estas otimiza√ß√µes fazem o seu c√≥digo Rust executar de maneira
mais r√°pida, mas por outro lado, tamb√©m fazem o programa levar mais tempo para
compilar. Por isso existem dois perfis diferentes: um para desenvolvimento,
quando voc√™ deseja recompilar rapidamente e com mais frequ√™ncia, e outro para
compilar a vers√£o final do seu programa, que vai ser entregue ao usu√°rio e n√£o
ser√° recompilada, e queremos que rode da maneira mais r√°pida poss√≠vel. Se voc√™
est√° fazendo um <em>benchmarking</em> do tempo de execu√ß√£o do seu c√≥digo, certifique-se
de executar o comando <code>cargo build --release</code>, e usar o execut√°vel que se
encontra na pasta <em>target/release</em>.</p>
<a class="header" href="print.html#cargo-como-conven√ß√£o" id="cargo-como-conven√ß√£o"><h3>Cargo como Conven√ß√£o</h3></a>
<p>Em projetos simples, o Cargo n√£o oferece tanto valor assim em rela√ß√£o a usar
apenas o <code>rustc</code>, mas vai fazer diferen√ßa √† medida que voc√™ continua. Em
projetos mais complexos, compostos de m√∫ltiplos <em>crates</em>, √© bem mais f√°cil
deixar o Cargo coordenar o processo de <em>build</em>. Com o Cargo, voc√™ pode apenas
executar o comando <code>cargo build</code>, e tudo dever√° funcionar da maneira correta.
Mesmo esse projeto sendo simples, ele utiliza muito das ferramentas que voc√™
ir√° usar pelo resto da sua carreira em Rust. Na verdade, voc√™ pode come√ßar a
trabalhar em praticamente qualquer projeto em Rust usando os seguintes comandos:</p>
<pre><code class="language-text">$ git clone algumaurl.com/algumprojeto
$ cd algumprojeto
$ cargo build
</code></pre>
<blockquote>
<p>Nota: Se voc√™ deseja conhecer o Cargo em mais detalhes, confira o
<a href="http://doc.crates.io/guide.html">Guia oficial do Cargo</a><!-- ignore --> (em ingl√™s), que aborda todas as suas
caracter√≠sticas.</p>
</blockquote>
<a class="header" href="print.html#jogo-de-adivinha√ß√£o" id="jogo-de-adivinha√ß√£o"><h1>Jogo de Adivinha√ß√£o</h1></a>
<p>Vamos entrar de cabe√ßa no Rust e colocar a m√£o na massa! Este cap√≠tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como us√°-los em um
programa de verdade. Voc√™ vai aprender sobre <code>let</code>, <code>match</code>, m√©todos, fun√ß√µes
associadas, crates externos, e mais! Os cap√≠tulos seguintes v√£o explorar essas
ideias em mais detalhes. Neste cap√≠tulo, voc√™ vai praticar o b√°sico.</p>
<p>Vamos implementar um cl√°ssico problema de programa√ß√£o para iniciantes: um jogo
de adivinha√ß√£o. Eis como ele funciona: o programa vai gerar um n√∫mero inteiro
aleat√≥rio entre 1 e 100. Ent√£o, ele vai pedir ao jogador que digite um palpite.
Ap√≥s darmos nosso palpite, ele vai nos indicar se o palpite √© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parab√©ns e
sair.</p>
<a class="header" href="print.html#preparando-um-novo-projeto" id="preparando-um-novo-projeto"><h2>Preparando um Novo Projeto</h2></a>
<p>Para iniciar um novo projeto, v√° ao seu diret√≥rio de projetos que voc√™ criou no
Cap√≠tulo 1, e execute os comandos do Cargo a seguir:</p>
<pre><code class="language-text">$ cargo new jogo_de_advinhacao --bin
$ cd jogo_de_advinhacao
</code></pre>
<p>O primeiro comando, <code>cargo new</code>, recebe o nome do projeto (<code>jogo_de_advinhacao</code>)
como primeiro argumento. A flag <code>--bin</code> diz ao Cargo que fa√ßa um projeto
bin√°rio, similar ao do Cap√≠tulo 1. O segundo comando muda a pasta atual para o
diret√≥rio do projeto.</p>
<p>Confira o arquivo <em>Cargo.toml</em> gerado:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;jogo_de_advinhacao&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Seu Nome &lt;voce@exemplo.com&gt;&quot;]

[dependencies]
</code></pre>
<p>Se as informa√ß√µes sobre o autor, que o Cargo obt√©m do seu ambiente, n√£o
estiverem corretas, fa√ßa os reparos necess√°rios e salve o arquivo.</p>
<p>Assim como no Cap√≠tulo 1, <code>cargo new</code> gera um programa &quot;Hello, world!&quot; para n√≥s.
Confira em <em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Agora vamos compilar esse programa &quot;Hello, world!&quot; e execut√°-lo de uma vez s√≥
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!
</code></pre>
<p>O comando <code>run</code> √© uma boa op√ß√£o quando precisamos iterar rapidamente em um
projeto, que √© o caso neste jogo: n√≥s queremos testar rapidamente cada itera√ß√£o
antes de movermos para a pr√≥xima.</p>
<p>Abra novamente o arquivo <em>src/main.rs</em>. Escreveremos todo nosso c√≥digo nele.</p>
<a class="header" href="print.html#processando-um-palpite" id="processando-um-palpite"><h2>Processando um Palpite</h2></a>
<p>A primeira parte do programa vai pedir uma entrada ao usu√°rio, processar essa
entrada, e conferir se ela est√° no formato esperado. Pra come√ßar, vamos permitir
que o jogador entre com um palpite. Coloque este c√≥digo no arquivo
<em>src/main.rs</em>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-1: C√≥digo para ler um palpite do usu√°rio e
imprim√≠-lo na tela.</span></p>
<p>Esse c√≥digo tem muita informa√ß√£o, vamos ver uma parte de cada vez. Para obter a
entrada do usu√°rio, e ent√£o imprimir o resultado como sa√≠da, precisaremos trazer
ao escopo a biblioteca <code>io</code> (de entrada/sa√≠da). A biblioteca <code>io</code> prov√©m da
biblioteca padr√£o (chamada de <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Por padr√£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no <a href="../../std/prelude/index.html"><em>prel√∫dio</em></a><!-- ignore -->. Se um tipo que voc√™ quiser usar n√£o
estiver no prel√∫dio, voc√™ ter√° que import√°-lo explicitamente atrav√©s do <code>use</code>.
A biblioteca <code>std::io</code> oferece v√°rias ferramentas de entrada/sa√≠da, incluindo a
funcionalidade de ler dados de entrada do usu√°rio.</p>
<p>Como visto no Cap√≠tulo 1, a fun√ß√£o <code>main</code> √© o ponto de entrada do programa:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>A sintaxe <code>fn</code> declara uma nova fun√ß√£o, o <code>()</code> indica que n√£o h√° par√¢metros, e
o <code>{</code> inicia o corpo da fun√ß√£o.</p>
<p>Como voc√™ tamb√©m j√° aprendeu no Cap√≠tulo 1, <code>println!</code> √© uma macro que imprime
uma string na tela:</p>
<pre><code class="language-rust ignore">println!(&quot;Advinhe o n√∫mero!&quot;);

println!(&quot;Digite o seu palpite.&quot;);
</code></pre>
<p>Este c√≥digo est√° exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usu√°rio.</p>
<a class="header" href="print.html#armazenando-valores-em-vari√°veis" id="armazenando-valores-em-vari√°veis"><h3>Armazenando Valores em Vari√°veis</h3></a>
<p>Pr√≥ximo passo, vamos criar um local para armazenar a entrada do usu√°rio:</p>
<pre><code class="language-rust ignore">let mut palpite = String::new();
</code></pre>
<p>Agora o programa est√° ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta √© uma declara√ß√£o <code>let</code>, que √© usada para criar
<em>vari√°veis</em>. Segue outro exemplo:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Essa linha cria uma nova vari√°vel chamada <code>foo</code>, e a vincula ao valor <code>bar</code>. Em
Rust, vari√°veis s√£o imut√°veis por padr√£o. O exemplo a seguir mostra como usar
<code>mut</code> antes do nome da vari√°vel para torn√°-la mut√°vel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // imut√°vel
let mut bar = 5; // mut√°vel
#}</code></pre></pre>
<blockquote>
<p>Nota: A sintaxe <code>//</code> inicia um coment√°rio, que continua at√© o fim da linha.
Rust ignora tudo o que estiver nos coment√°rios.</p>
</blockquote>
<p>Agora voc√™ sabe que <code>let mut palpite</code> vai introduzir uma vari√°vel mut√°vel de
nome <code>palpite</code>. No outro lado do s√≠mbolo <code>=</code> est√° o valor ao qual <code>palpite</code> est√°
vinculado, que √© o resultado da chamada <code>String::new</code>, uma fun√ß√£o que retorna
uma nova inst√¢ncia de <code>String</code>. <a href="../../std/string/struct.String.html"><code>String</code></a><!-- ignore --> √© um tipo
fornecido pela biblioteca padr√£o que representa uma cadeia expans√≠vel de
caracteres codificados em UTF-8.</p>
<p>A sintaxe <code>::</code> na linha <code>::new</code> indica que <code>new</code> √© uma <em>fun√ß√£o associada</em> do
tipo <code>String</code>. Uma fun√ß√£o associada √© implementada sobre um tipo, neste caso
<code>String</code>, em vez de uma inst√¢ncia particular de <code>String</code>. Algumas linguagens
d√£o a isso o nome <em>m√©todo est√°tico</em>.</p>
<p>Esta fun√ß√£o <code>new()</code> cria uma nova <code>String</code> vazia. Voc√™ encontrar√° uma fun√ß√£o
<code>new()</code> em muitos tipos, j√° que √© um nome comum para uma fun√ß√£o que produz um
novo valor de algum tipo.</p>
<p>Para resumir, a linha <code>let mut palpite = String::new();</code> criou uma vari√°vel
mut√°vel que est√° atualmente vinculada a uma nova inst√¢ncia vazia de uma
<code>String</code>. Ufa!</p>
<p>Lembre-se de que inclu√≠mos a funcionalidade de entrada/sa√≠da da biblioteca
padr√£o por meio do <code>use std::io;</code> na primeira linha do programa. Agora vamos
chamar uma fun√ß√£o associada, <code>stdin</code>, em <code>io</code>:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite)
    .expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Se n√£o tiv√©ssemos a linha <code>use std::io</code> no in√≠cio do programa, poder√≠amos ter
escrito esta chamada como <code>std::io::stdin</code>. A fun√ß√£o <code>stdin</code> retorna uma
inst√¢ncia de <a href="../../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, um tipo que representa
um manipulador (<em>handle</em>) da entrada padr√£o do seu terminal.</p>
<p>A pr√≥xima parte do c√≥digo, <code>.read_line(&amp;mut palpite)</code>, chama o m√©todo
<a href="../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> do <em>handle</em> da entrada padr√£o para obter
entrada do usu√°rio. Tamb√©m estamos passando um argumento para <code>read_line</code>:
<code>&amp;mut palpite</code>.</p>
<p>O trabalho da fun√ß√£o <code>read_line</code> √© receber o que o usu√°rio digita na entrada
padr√£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mut√°vel para que o m√©todo consiga
alterar o seu conte√∫do, adicionando a entrada do usu√°rio.</p>
<p>O s√≠mbolo <code>&amp;</code> indica que o argumento √© uma <em>refer√™ncia</em>, o que permite m√∫ltiplas
partes do seu c√≥digo acessar um certo dado sem precisar criar v√°rias c√≥pias dele
na mem√≥ria. Refer√™ncias s√£o uma caracter√≠stica complexa, e uma das maiores
vantagens do Rust √© o qu√£o f√°cil e seguro √© usar refer√™ncias. Voc√™ n√£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O Cap√≠tulo 4 vai
explicar sobre refer√™ncias de forma mais aprofundada. Por enquanto, tudo que
voc√™ precisa saber √© que, assim como as vari√°veis, refer√™ncias s√£o imut√°veis por
padr√£o. Por isso, precisamos escrever <code>&amp;mut palpite</code>, em vez de apenas
<code>&amp;palpite</code>, para fazer com que o palpite seja mut√°vel.</p>
<p>Ainda n√£o finalizamos completamente esta linha de c√≥digo. Embora esta seja uma
√∫nica linha de texto, √© apenas a primeira parte de uma linha l√≥gica de c√≥digo. A
segunda parte √© a chamada para este m√©todo:</p>
<pre><code class="language-rust ignore">.expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Quando voc√™ chama um m√©todo com a sintaxe <code>.foo()</code>, geralmente √© bom introduzir
uma nova linha e outro espa√ßo para ajudar a dividir linhas muito compridas.
Poder√≠amos ter feito assim:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut palpite).expect(&quot;Falha ao ler entrada&quot;);
</code></pre>
<p>Por√©m, uma linha muito comprida fica dif√≠cil de ler. Ent√£o √© melhor dividirmos a
linha em duas, uma para cada m√©todo chamado. Agora vamos falar sobre o que essa
linha faz.</p>
<a class="header" href="print.html#tratando-potenciais-falhas-com-o-tipo-result" id="tratando-potenciais-falhas-com-o-tipo-result"><h3>Tratando Potenciais Falhas com o Tipo <code>Result</code></h3></a>
<p>Como mencionado anteriormente, <code>read_line</code> coloca o que o usu√°rio escreve dentro
da string que passamos como argumento, mas tamb√©m retorna um valor - neste
caso, um <a href="../../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust tem uma variedade de
tipos com o nome <code>Result</code> em sua biblioteca padr√£o: um <a href="../../std/result/enum.Result.html"><code>Result</code></a>
gen√©rico e as vers√µes espec√≠ficas dos subm√≥dulos, como <code>io::Result</code>.</p>
<p>Os tipos <code>Result</code> s√£o <a href="ch06-00-enums.html"><em>enumera√ß√µes</em></a><!-- ignore -->, comumente chamadas
de <em>enums</em>. Uma enumera√ß√£o √© um tipo que pode ter um conjunto fixo de valores,
os quais s√£o chamados de <em>variantes</em> da enum. O Cap√≠tulo 6 vai abordar enums em
mais detalhes.</p>
<p>Para <code>Result</code>, as variantes s√£o <code>Ok</code> ou <code>Err</code>. <code>Ok</code> indica que a opera√ß√£o teve
sucesso, e dentro da variante <code>Ok</code> est√° o valor resultante. <code>Err</code> significa que
a opera√ß√£o falhou, e cont√©m informa√ß√µes sobre como ou por que isso ocorreu.</p>
<p>O prop√≥sito destes tipos <code>Result</code> √© codificar informa√ß√µes de manipula√ß√£o de
erros. Valores do tipo <code>Result</code>, assim como qualquer tipo, possuem m√©todos
definidos. Uma inst√¢ncia de <code>io::Result</code> tem um <a href="../../std/result/enum.Result.html#method.expect">m√©todo <code>expect</code></a><!-- ignore -->
que voc√™ pode chamar. Se esta inst√¢ncia de <code>io::Result</code> √© um <code>Err</code>, <code>expect</code> vai
terminar o programa com erro e mostrar a mensagem que voc√™ passou como argumento
ao <code>expect</code>. Se o m√©todo <code>read_line</code> retornar um <code>Err</code>, provavelmente seria o
resultado de um erro vindo do sistema operacional que est√° por tr√°s. Se esta
inst√¢ncia de <code>io::Result</code> √© um <code>Ok</code>, <code>expect</code> vai obter o valor contido no <code>Ok</code>
e retorn√°-lo para que voc√™ possa us√°-lo. Neste caso, o valor √© o n√∫mero de bytes
dos dados que o usu√°rio inseriu atrav√©s da entrada padr√£o.</p>
<p>Se n√£o chamarmos <code>expect</code>, nosso programa vai compilar, mas vamos ter um aviso:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust avisa que n√£o usamos o valor <code>Result</code>, retornado por <code>read_line</code>, indicando
que o programa deixou de tratar um poss√≠vel erro. A maneira correta de suprimir
o aviso √© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar <code>expect</code>. Voc√™
aprender√° sobre recupera√ß√£o de erros no Cap√≠tulo 9.</p>
<a class="header" href="print.html#exibindo-valores-com-curingas-do-println" id="exibindo-valores-com-curingas-do-println"><h3>Exibindo Valores com Curingas do <code>println!</code></h3></a>
<p>Tirando a chave que delimita a fun√ß√£o <code>main</code>, h√° apenas uma linha mais a ser
discutida no c√≥digo que fizemos at√© agora, que √© a seguinte:</p>
<pre><code class="language-rust ignore">println!(&quot;Voc√™ disse: {}&quot;, guess);
</code></pre>
<p>Esta linha imprime a string na qual salvamos os dados inseridos pelo usu√°rio. O
<code>{}</code> √© um curinga que reserva o lugar de um valor. Voc√™ pode imprimir mais de um
valor usando <code>{}</code>: o primeiro conjunto de <code>{}</code> guarda o primeiro valor listado
ap√≥s a string de formata√ß√£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir m√∫ltiplos valores em uma s√≥ chamada a <code>println!</code>
seria assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x = {} e y = {}&quot;, x, y);
#}</code></pre></pre>
<p>Esse c√≥digo imprime <code>x = 5 e y = 10</code>.</p>
<a class="header" href="print.html#testando-a-primeira-parte" id="testando-a-primeira-parte"><h3>Testando a Primeira Parte</h3></a>
<p>Vamos testar a primeira parte do jogo de advinha√ß√£o. Voc√™ pode execut√°-lo usando
<code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
Digite o seu palpite.
6
Voc√™ disse: 6
</code></pre>
<p>Nesse ponto, a primeira parte do jogo est√° feita: podemos coletar entrada do
teclado e mostr√°-la na tela.</p>
<a class="header" href="print.html#gerando-um-n√∫mero-secreto" id="gerando-um-n√∫mero-secreto"><h2>Gerando um N√∫mero Secreto</h2></a>
<p>A seguir, precisamos gerar um n√∫mero secreto que o usu√°rio vai tentar advinhar.
O n√∫mero secreto deve ser diferente a cada execu√ß√£o, para que o jogo tenha gra√ßa
em ser jogado mais de uma vez. Vamos usar um n√∫mero aleat√≥rio entre 1 e 100,
para que o jogo n√£o seja t√£o dif√≠cil. Rust ainda n√£o inclui uma funcionalidade
de gera√ß√£o de n√∫meros aleat√≥rios em sua biblioteca padr√£o. Por√©m, a equipe Rust
fornece um <a href="https://crates.io/crates/rand">crate <code>rand</code></a>.</p>
<a class="header" href="print.html#usando-um-crate-para-ter-mais-funcionalidades" id="usando-um-crate-para-ter-mais-funcionalidades"><h3>Usando um Crate para Ter Mais Funcionalidades</h3></a>
<p>Lembre-se que um <em>crate</em> √© um pacote de c√≥digo Rust. O projeto que estamos
construindo √© um <em>crate bin√°rio</em>, que √© um execut√°vel. J√° o <code>rand</code> √© um
<em>crate de biblioteca</em>, que cont√©m c√≥digo cujo objetivo √© ser usado por outros
programas.</p>
<p>√â no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o c√≥digo usando <code>rand</code>, precisamos modificar o arquivo <em>Cargo.toml</em>
para incluir o crate <code>rand</code> como uma depend√™ncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabe√ßalho da se√ß√£o <code>[dependencies]</code> que o Cargo
criou para voc√™:</p>
<p><span class="filename">Arquivo: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>No arquivo <em>Cargo.toml</em>, tudo que vem depois de um cabe√ßalho √© parte de uma
se√ß√£o que segue at√© o in√≠cio de outra. A se√ß√£o <code>[dependencies]</code> √© onde voc√™ diz
ao Cargo de quais crates externos o seu projeto depende, e quais vers√µes desses
crates voc√™ exige. Neste caso, especificamos o crate <code>rand</code> com a vers√£o
sem√¢ntica <code>0.3.14</code>. Cargo compreende <a href="https://semver.org/lang/pt-BR/">Versionamento Sem√¢ntico</a><!-- ignore -->
(√†s vezes chamado <em>SemVer</em>), um padr√£o para escrever n√∫meros de vers√µes. O
n√∫mero <code>0.3.14</code> √©, na verdade, uma forma curta de escrever <code>^0.3.14</code>, que
significa &quot;qualquer vers√£o que tenha uma API p√∫blica compat√≠vel com a vers√£o
0.3.14&quot;.</p>
<p>Agora, sem mudar c√≥digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listagem 2-2: Resultado da execu√ß√£o de <code>cargo build</code>
depois de adicionar o crate <code>rand</code> como depend√™ncia.</span></p>
<p>Talvez pra voc√™ apare√ßam vers√µes diferentes (mas elas s√£o todas compat√≠veis com
o c√≥digo, gra√ßas ao Versionamento Sem√¢ntico!), e as linhas talvez apare√ßam em
ordem diferente.</p>
<p>Agora que temos uma depend√™ncia externa, Cargo busca as vers√µes mais recentes de
tudo no <em>registro</em>, que √© uma c√≥pia dos dados do <a href="https://crates.io">Crates.io</a>.
Crates.io √© onde as pessoas do ecossistema Rust postam seus projetos
<em>open source</em> para que os outros possam usar.</p>
<p>Ap√≥s atualizar o registro, Cargo verifica a se√ß√£o <code>[dependencies]</code> e baixa todas
as que voc√™ n√£o tem ainda. Neste caso, embora tenhamos listado apenas <code>rand</code>
como depend√™ncia, o Cargo tamb√©m puxou uma c√≥pia da <code>libc</code>, porque <code>rand</code>
depende da <code>libc</code> para funcionar. Depois de baix√°-las, o Cargo as compila e
ent√£o compila nosso projeto.</p>
<p>Se, logo em seguida, voc√™ executar <code>cargo build</code> novamente sem fazer mudan√ßas,
n√£o vai aparecer nenhuma mensagem de sa√≠da. O Cargo sabe que j√° baixou e
compilou as depend√™ncias, e voc√™ n√£o alterou mais nada sobre elas no seu arquivo
<em>Cargo.toml</em>. Cargo tamb√©m sabe que voc√™ n√£o mudou mais nada no seu c√≥digo, e
por isso n√£o o recompila. Sem nada a fazer, ele simplesmente sai. Se voc√™ abrir
<em>src/main.rs</em>, fizer uma modifica√ß√£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>Essas linhas mostram que o Cargo s√≥ atualiza o <em>build</em> com a sua pequena mudan√ßa
no arquivo <em>src/main.rs</em>. Suas depend√™ncias n√£o mudaram, ent√£o o Cargo sabe que
pode reutilizar o que j√° tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do c√≥digo.</p>
<a class="header" href="print.html#o-arquivo-cargolock-garante-builds-reproduz√≠veis" id="o-arquivo-cargolock-garante-builds-reproduz√≠veis"><h4>O Arquivo <em>Cargo.lock</em> Garante <em>Builds</em> Reproduz√≠veis</h4></a>
<p>O Cargo tem um mecanismo que assegura que voc√™ pode reconstruir o mesmo artefato
toda vez que voc√™ ou outra pessoa compilar o seu c√≥digo. O Cargo vai usar apenas
as vers√µes das depend√™ncias que voc√™ especificou, at√© que voc√™ indique o
contr√°rio. Por exemplo, o que acontece se, na semana que vem, sair a vers√£o
<code>v0.3.15</code> contendo uma corre√ß√£o de bug, mas tamb√©m uma regress√£o que n√£o
funciona com o seu c√≥digo?</p>
<p>A resposta para isso est√° no arquivo <em>Cargo.lock</em>, que foi criado na primeira
vez que voc√™ executou <code>cargo build</code>, e agora est√° no seu diret√≥rio
<em>jogo_de_advinhacao</em>. Quando voc√™ compila o seu projeto pela primeira vez, o
Cargo descobre as vers√µes de todas as depend√™ncias que preenchem os crit√©rios
e ent√£o as escreve no arquivo <em>Cargo.lock</em>. Quando voc√™ compilar o seu projeto
futuramente, o Cargo ver√° que o arquivo <em>Cargo.lock</em> existe e usar√° as vers√µes
especificadas l√°, em vez de refazer todo o trabalho descobrir as vers√µes
novamente. Isto lhe permite ter um <em>build</em> reproduz√≠vel automaticamente. Em
outras palavras, seu projeto vai continuar com a vers√£o <code>0.3.14</code> at√© que voc√™
fa√ßa uma atualiza√ß√£o expl√≠cita, gra√ßas ao arquivo <em>Cargo.lock</em>.</p>
<a class="header" href="print.html#atualizando-um-crate-para-obter-uma-nova-vers√£o" id="atualizando-um-crate-para-obter-uma-nova-vers√£o"><h4>Atualizando um Crate para Obter uma Nova Vers√£o</h4></a>
<p>Quando voc√™ <em>quiser</em> atualizar um crate, o Cargo tem outro comando, <code>update</code>,
que faz o seguinte:</p>
<ol>
<li>Ignora o arquivo <em>Cargo.lock</em> e descobre todas as vers√µes mais recentes que
atendem as suas especifica√ß√µes no <em>Cargo.toml</em>.</li>
<li>Se funcionar, o Cargo escreve essas vers√µes no arquivo <em>Cargo.lock</em>.</li>
</ol>
<p>Mas, por padr√£o, o Cargo vai procurar as vers√µes maiores que <code>0.3.0</code> e menores
que <code>0.4.0</code>. Se o crate <code>rand</code> j√° tiver lan√ßado duas novas vers√µes, <code>0.3.15</code> e
<code>0.4.0</code>, voc√™ ver√° a seguinte mensagem ao executar <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>Nesse ponto, voc√™ vai notar tamb√©m uma mudan√ßa no seu arquivo <em>Cargo.lock</em>
dizendo que a vers√£o do crate <code>rand</code> que voc√™ est√° usando agora √© a <code>0.3.15</code>.</p>
<p>Se voc√™ quisesse usar a vers√£o <code>0.4.0</code>, ou qualquer vers√£o da s√©rie <code>0.4.x</code> do
<code>rand</code>, voc√™ teria que atualizar o seu <em>Cargo.toml</em> dessa forma:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>Na pr√≥xima vez que voc√™ executar <code>cargo build</code>, o Cargo vai atualizar o registro
de crates dispon√≠veis e reavaliar os seus requisitos sobre o <code>rand</code> de acordo
com a nova vers√£o que voc√™ especificou.</p>
<p>H√° muito mais a ser dito sobre <a href="http://doc.crates.io">Cargo</a><!-- ignore --> e o <a href="http://doc.crates.io/crates-io.html">seu
ecossistema</a><!-- ignore --> que vai ser discutido no Cap√≠tulo 14,
mas por ora isto √© tudo que voc√™ precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os <em>rust√°ceos</em> consigam escrever projetos menores que
s√£o montados a partir de diversos pacotes.</p>
<a class="header" href="print.html#gerando-um-n√∫mero-aleat√≥rio" id="gerando-um-n√∫mero-aleat√≥rio"><h3>Gerando um N√∫mero Aleat√≥rio</h3></a>
<p>Agora vamos <em>usar</em>, de fato, o <code>rand</code>. O pr√≥ximo passo √© atualizar o
<em>src/main.rs</em> conforme mostrado na Listagem 2-3:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);
}
</code></pre>
<p><span class="caption">Listagem 2-3: Mudan√ßas necess√°rias do c√≥digo para gerar um
n√∫mero aleat√≥rio.</span></p>
<p>Estamos adicionando a linha <code>extern crate rand</code> ao topo do arquivo para indicar
ao Rust que estamos usando uma depend√™ncia externa. Isto tamb√©m √© equivalente a
um <code>use rand;</code>, assim podemos chamar qualquer coisa que esteja no crate <code>rand</code>
prefixando-a com <code>rand::</code>.</p>
<p>Em seguida, adicionamos outra linha <code>use</code>: <code>use rand::Rng</code>. <code>Rng</code> √© um trait
que define m√©todos a serem implementados pelos geradores de n√∫meros aleat√≥rios,
e esse trait deve estar dentro do escopo para que possamos usar esses m√©todos. O
Cap√≠tulo 10 vai abordar traits em mais detalhes.</p>
<p>Tem outras duas linhas que adicionamos no meio. A fun√ß√£o <code>rand::thread_rng</code> nos
d√° o gerador de n√∫meros aleat√≥rios que vamos usar, um que √© local √† <em>thread</em>
corrente e que √© inicializado pelo sistema operacional. Depois, vamos chamar o
m√©todo <code>gen_range</code> no gerador de n√∫meros aleat√≥rios. Esse m√©todo est√° definido
pelo trait <code>Rng</code> que trouxemos ao escopo por meio do <code>use rand::Rng</code>. Este
m√©todo recebe dois argumentos e gera um n√∫mero aleat√≥rio entre eles. Ele inclui
o limite inferior mas exclui o superior, ent√£o precisamos passar <code>1</code> e <code>101</code>
para obter um n√∫mero de 1 a 100.</p>
<p>Saber quais traits devem ser usadas e quais fun√ß√µes e m√©todos de um crate
devem ser chamados n√£o √© nada trivial. As instru√ß√µes de como usar um crate
est√£o na documenta√ß√£o de cada um. Outra coisa boa do Cargo √© que voc√™ pode rodar
o comando <code>cargo doc --open</code> que vai construir localmente a documenta√ß√£o
fornecida por todas as suas depend√™ncias e abr√≠-las no seu navegador. Se voc√™
estiver interessado em outras funcionalidades do crate <code>rand</code>, por exemplo,
execute <code>cargo doc --open</code> e clique em <code>rand</code>, no menu ao lado esquerdo.</p>
<p>A segunda linha que adicionamos imprime o n√∫mero secreto. Isto √© √∫til enquanto
estamos desenvolvendo o programa para podermos test√°-lo, mas vamos retir√°-la da
vers√£o final. Um jogo n√£o √© muito interessante se ele mostra a resposta logo no
in√≠cio!</p>
<p>Tente rodar o programa algumas vezes:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 7
Digite o seu palpite.
4
Voc√™ disse: 4
$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 83
Digite o seu palpite.
5
Voc√™ disse: 5
</code></pre>
<p>Voc√™ j√° deve obter n√∫meros aleat√≥rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!</p>
<a class="header" href="print.html#comparando-o-palpite-com-o-n√∫mero-secreto" id="comparando-o-palpite-com-o-n√∫mero-secreto"><h2>Comparando o Palpite com o N√∫mero Secreto</h2></a>
<p>Agora que n√≥s temos a entrada do usu√°rio e o n√∫mero secreto, vamos compar√°-los.
Esta estapa √© mostrada na Listagem 2-4:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listagem 2-4: Tratando os poss√≠veis resultados da
compara√ß√£o de dois n√∫meros.</span></p>
<p>A primeira novidade aqui √© outro <code>use</code>, que traz ao escopo um tipo da biblioteca
padr√£o chamado <code>std::cmp::Ordering</code>. <code>Ordering</code> √© outra enum, igual a <code>Result</code>,
mas as suas variantes s√£o <code>Less</code>, <code>Greater</code> e <code>Equal</code> (elas significam menor,
maior e igual, respectivamente). Estes s√£o os tr√™s poss√≠veis resultados quando
voc√™ compara dois valores.</p>
<p>Depois, adicionamos cinco novas linhas no final que usam o tipo <code>Ordering</code>:</p>
<pre><code class="language-rust ignore">match palpite.cmp(&amp;numero_secreto) {
    Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
    Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
    Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
}
</code></pre>
<p>O m√©todo <code>cmp</code> compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma refer√™ncia de qualquer coisa que
voc√™ queira comparar. Neste caso, est√° comparando o <code>palpite</code> com o
<code>numero_secreto</code>. <code>cmp</code> retorna uma variante do tipo <code>Ordering</code>, que trouxemos
ao escopo com <code>use</code>. N√≥s usamos uma express√£o <a href="ch06-02-match.html"><code>match</code></a><!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de <code>Ordering</code> foi
retornada pelo m√©todo <code>cmp</code>, que foi chamado com os valores <code>palpite</code> e
<code>numero_secreto</code>.</p>
<p>Uma express√£o <code>match</code> √© composta de <em>bra√ßos</em>. Um bra√ßo consiste em um <em>padr√£o</em>
mais o c√≥digo que deve ser executado se o valor colocado no in√≠cio do <code>match</code> se
encaixar no padr√£o deste bra√ßo. O Rust pega o valor passado ao <code>match</code> e o
compara com o padr√£o de cada bra√ßo na sequ√™ncia. A express√£o <code>match</code> e os
padr√µes s√£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situa√ß√µes que seu c√≥digo pode encontrar, e ajuda a assegurar que
voc√™ tenha tratado todas elas. Essas ferramentas ser√£o abordadas em detalhes nos
cap√≠tulos 6 e 18, respectivamente.</p>
<p>Vamos acompanhar um exemplo do que aconteceria na express√£o <code>match</code> usada aqui.
Digamos que o usu√°rio tenha colocado 50 como palpite, e o n√∫mero secreto
aleat√≥rio desta vez √© 38. Quando o c√≥digo compara 50 com 38, o m√©todo <code>cmp</code> vai
retornar <code>Ordering::Greater</code>, porque 50 √© maior que 38. <code>Ordering::Greater</code> √© o
valor passado ao <code>match</code>. Ele olha para o padr√£o <code>Ordering::Less</code> do primeiro
bra√ßo, mas o valor <code>Ordering::Greater</code> n√£o casa com <code>Ordering::Less</code>, ent√£o ele
ignora o c√≥digo desse bra√ßo e avan√ßa para o pr√≥ximo. J√° o padr√£o do pr√≥ximo
bra√ßo, <code>Ordering::Greater</code>, <em>casa</em> com <code>Ordering::Greater</code>! O c√≥digo associado a
este bra√ßo vai ser executado e mostrar <code>Muito alto!</code> na tela. A express√£o
<code>match</code> termina porque j√° n√£o tem mais necessidade de verificar o √∫ltimo bra√ßo
nesse caso particular.</p>
<p>Por√©m, o c√≥digo da Listagem 2-4 ainda n√£o vai compilar. Vamos tentar:</p>
<pre><code class="language-text">$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match palpite.cmp(&amp;numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.
</code></pre>
<p>O que este erro est√° dizendo √© que temos <em>tipos incompat√≠veis</em>. Rust tem um
sistema de tipos forte e est√°tico. Por√©m, Rust tamb√©m tem infer√™ncia de tipos.
Quando escrevemos <code>let palpite = String::new()</code>, Rust foi capaz de inferir que
<code>palpite</code> deveria ser uma <code>String</code>, ent√£o ele n√£o nos faz escrever o tipo. O
<code>numero_secreto</code>, por outro lado, √© de um tipo num√©rico. Existem alguns tipos
num√©ricos capazes de guardar um valor entre 1 e 100: <code>i32</code>, que √© um n√∫mero de
32 bits; <code>u32</code>, um n√∫mero de 32 bits sem sinal; <code>i64</code>, um n√∫mero de 64 bits; e
mais alguns outros. O tipo num√©rico padr√£o do Rust √© <code>i32</code>, que √© o tipo do
<code>numero_secreto</code>, a n√£o ser que adicionemos, em algum lugar, uma informa√ß√£o de
tipo que fa√ßa o Rust inferir outro tipo num√©rico. A raz√£o do erro √© que o Rust
n√£o pode comparar uma string e um tipo num√©rico.</p>
<p>Em √∫ltima an√°lise, queremos converter a <code>String</code> que lemos como entrada em um
tipo num√©rico de verdade, de forma que possamos compar√°-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da fun√ß√£o <code>main</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    println!(&quot;Digite o seu palpite.&quot;);

    let mut palpite = String::new();

    io::stdin().read_line(&amp;mut palpite)
        .expect(&quot;Falha ao ler entrada&quot;);

    let palpite: u32 = palpite.trim().parse()
        .expect(&quot;Por favor, digite um n√∫mero!&quot;);

    println!(&quot;Voc√™ disse: {}&quot;, palpite);

    match palpite.cmp(&amp;numero_secreto) {
        Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
        Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
        Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
    }
}
</code></pre>
<p>As duas linhas novas s√£o:</p>
<pre><code class="language-rust ignore">let palpite: u32 = palpite.trim().parse()
    .expect(&quot;Por favor, digite um n√∫mero!&quot;);
</code></pre>
<p>N√≥s criamos uma vari√°vel chamada <code>palpite</code>. Mas espera, o programa j√° n√£o tinha
uma vari√°vel chamada <code>palpite</code>? Sim, mas o Rust nos permite <em>sombrear</em> o
<code>palpite</code> anterior com um novo. Isto √© geralmente usado em situa√ß√µes em que voc√™
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome <code>palpite</code>, em vez de nos for√ßar a criar dois nomes √∫nicos como
<code>palpite_str</code> e <code>palpite</code>, por exemplo. (O Cap√≠tulo 3 vai cobrir sombreamento em
mais detalhes).</p>
<p>N√≥s vinculamos <code>palpite</code> √† express√£o <code>palpite.trim().parse()</code>. O <code>palpite</code>, na
express√£o, refere-se ao <code>palpite</code> original contendo a <code>String</code> de entrada do
usu√°rio. O m√©todo <code>trim</code>, em uma inst√¢ncia de <code>String</code>, vai eliminar quaisquer
espa√ßos em branco no in√≠cio e no fim. <code>u32</code> pode conter apenas caracteres
num√©ricos, mas o usu√°rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o <code>read_line</code>. Quando o usu√°rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha √© inserido na
string. Por exemplo, se o usu√°rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, <code>palpite</code> ficaria assim: <code>5\n</code>. O
<code>\n</code> representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O m√©todo <code>trim</code> elimina o <code>\n</code>, deixando apenas <code>5</code>.</p>
<p>O <a href="../../std/primitive.str.html#method.parse">m√©todo <code>parse</code> em strings</a><!-- ignore --> converte uma string para
algum tipo de n√∫mero. Dado que ele pode interpretar uma variedade de tipos
num√©ricos, precisamos dizer ao Rust qual o tipo exato de n√∫mero n√≥s queremos, e
para isso usamos <code>let palpite: u32</code>. Os dois pontos (<code>:</code>) depois de <code>palpite</code>
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
num√©ricos embutidos, o <code>u32</code> visto aqui √© um inteiro de 32 bits sem sinal. √â uma
boa escolha padr√£o para um n√∫mero positivo pequeno. Voc√™ vai aprender sobre
outros tipos num√©ricos no Cap√≠tulo 3. Al√©m disso, a anota√ß√£o <code>u32</code> neste
programa de exemplo e a compara√ß√£o com <code>numero_secreto</code> significam que o Rust
vai inferir que <code>numero_secreto</code> tamb√©m deve ser um <code>u32</code>. Ent√£o agora a
compara√ß√£o vai ser feita entre valores do mesmo tipo!</p>
<p>A chamada para <code>parse</code> poderia facilmente causar um erro. Por exemplo, se a
string contiver <code>Aüëç%</code>, n√£o haveria como converter isto em um n√∫mero. Como ele
pode falhar, o m√©todo <code>parse</code> retorna um <code>Result</code>, assim como o m√©todo
<code>read_line</code>, conforme discutido anteriormente na se√ß√£o &quot;Tratando Potenciais
Falhas com o Tipo <code>Result</code>. Vamos tratar este <code>Result</code> da mesma forma usando o
m√©todo <code>expect</code> de novo. Se o <code>parse</code> retornar uma variante <code>Err</code> da enum
<code>Result</code>, por n√£o conseguir criar um n√∫mero a partir da string, a chamada ao
<code>expect</code> vai causar um <em>crash</em> no jogo e exibir a mensagem que passamos a ele.
Se o <code>parse</code> conseguir converter uma string em um n√∫mero, ele vai retornar a
variante <code>Ok</code> da enum <code>Result</code> e <code>expect</code> vai retornar o n√∫mero que queremos
extrair do valor <code>Ok</code>.</p>
<p>Agora vamos executar o programa!</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 58
Digite o seu palpite.
  76
Voc√™ disse: 76
Muito alto!
</code></pre>
<p>Boa! At√© mesmo colocando alguns espa√ßos antes de digitar o palpite, o programa
ainda descobriu que o palpite do usu√°rio √© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o n√∫mero corretamente, digite um n√∫mero muito alto, e digite um
n√∫mero muito baixo.</p>
<p>Agora j√° temos a maior parte do jogo funcionando, mas o usu√°rio s√≥ consegue dar
um palpite uma vez. Vamos mudar isso adicionando la√ßos!</p>
<a class="header" href="print.html#permitindo-m√∫ltiplos-palpites-usando-looping" id="permitindo-m√∫ltiplos-palpites-usando-looping"><h2>Permitindo M√∫ltiplos Palpites Usando <em>Looping</em></h2></a>
<p>A palavra-chave <code>loop</code> nos d√° um la√ßo (<em>loop</em>) infinito. Use-a para dar aos
usu√°rios mais chances de advinhar o n√∫mero:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; println!(&quot;Voc√™ acertou!&quot;),
        }
    }
}
</code></pre>
<p>Como voc√™ pode ver, movemos tudo para dentro do la√ßo a partir da mensagem
pedindo o palpite do usu√°rio. Certifique-se de indentar essas linhas mais quatro
espa√ßos cada uma, e execute o programa novamente. Repare que h√° um novo
problema, porque o programa est√° fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usu√°rio n√£o consegue sair!</p>
<p>O usu√°rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas h√° uma outra forma de escapar deste
monstro insaci√°vel que mencionamos na discuss√£o do m√©todo <code>parse</code>, na se√ß√£o
&quot;Comparando o Palpite com o N√∫mero Secreto&quot;: se o usu√°rio fornece uma resposta
n√£o-num√©rica, o programa vai sofrer um <em>crash</em>. O usu√°rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 59
Digite o seu palpite.
45
Voc√™ disse: 45
Muito baixo!
Digite o seu palpite.
60
Voc√™ disse: 60
Muito alto!
Digite o seu palpite.
59
Voc√™ disse: 59
Voc√™ acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um n√∫mero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)
</code></pre>
<p>Digitar <code>sair</code>, na verdade, sai do jogo, mas isso tamb√©m acontece com qualquer
outra entrada n√£o num√©rica. Por√©m, isto n√£o √© o ideal. Queremos que o jogo
termine automaticamente quando o n√∫mero √© advinhado corretamente.</p>
<a class="header" href="print.html#saindo-ap√≥s-um-palpite-correto" id="saindo-ap√≥s-um-palpite-correto"><h3>Saindo Ap√≥s um Palpite Correto</h3></a>
<p>Vamos programar o jogo para sair quando o usu√°rio vencer, colocando um <code>break</code>:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!(&quot;O n√∫mero secreto √©: {}&quot;, numero_secreto);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = palpite.trim().parse()
            .expect(&quot;Por favor, digite um n√∫mero!&quot;);

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adicionando a linha <code>break</code> ap√≥s o <code>Voc√™ acertou!</code>, o programa vai sair do la√ßo
quando o usu√°rio advinhar corretamente o n√∫mero secreto. Sair do la√ßo tamb√©m
significa sair do programa, pois o la√ßo √© a √∫ltima parte da <code>main</code>.</p>
<a class="header" href="print.html#tratando-entradas-inv√°lidas" id="tratando-entradas-inv√°lidas"><h3>Tratando Entradas Inv√°lidas</h3></a>
<p>Para refinar ainda mais o comportamento do jogo, em vez de causar um <em>crash</em> no
programa quando o usu√°rio insere uma entrada n√£o num√©rica, vamos fazer o jogo
ignor√°-la para que o usu√°rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o <code>palpite</code> √© convertido de <code>String</code> para <code>u32</code>:</p>
<pre><code class="language-rust ignore">let palpite: u32 = match palpite.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Trocando uma chamada a <code>expect</code> por uma express√£o <code>match</code> √© a forma como voc√™
geralmente deixa de causar um <em>crash</em> em um erro e passa a trat√°-lo, de fato.
Lembre-se que o m√©todo <code>parse</code> retorna um valor do tipo <code>Result</code>, uma enum que
cont√©m a variante <code>Ok</code> ou <code>Err</code>. Estamos usando um <code>match</code> aqui, assim como
fizemos com o <code>Ordering</code> resultante do m√©todo <code>cmp</code>.</p>
<p>Se o <code>parse</code> consegue converter a string em um n√∫mero, ele vai retornar um <code>Ok</code>
contendo o n√∫mero resultante. Esse valor <code>Ok</code> vai casar com o padr√£o do primeiro
bra√ßo, e o <code>match</code> vai apenas retornar o valor <code>num</code> produzido pelo <code>parse</code> e
colocado dentro do <code>Ok</code>. Esse n√∫mero vai acabar ficando exatamente onde
queremos, na vari√°vel <code>palpite</code> que estamos criando.</p>
<p>Se o <code>parse</code> <em>n√£o</em> conseguir converter a string em um n√∫mero, ele vai retornar
um <code>Err</code> que cont√©m mais informa√ß√µes sobre o erro. O valor <code>Err</code> n√£o casa com o
padr√£o <code>Ok(num)</code> do primeiro bra√ßo do <code>match</code>, mas casa com o padr√£o <code>Err(_)</code> do
segundo bra√ßo. O <code>_</code> √© um valor &quot;pega tudo&quot;. Neste exemplo, estamos dizendo que
queremos casar todos os valores <code>Err</code>, n√£o importa qual informa√ß√£o h√° dentro
deles. Ent√£o o programa vai executar o c√≥digo do segundo bra√ßo, <code>continue</code>, que
significa ir para a pr√≥xima itera√ß√£o do <code>loop</code> e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o <code>parse</code> vier a encontrar!</p>
<p>Agora, tudo no programa deve funcionar como esperado. Vamos tentar execut√°-lo
usando o comando <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 61
Digite o seu palpite.
10
Voc√™ disse: 10
Muito baixo!
Digite o seu palpite.
99
Voc√™ disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Voc√™ disse: 61
Voc√™ acertou!
</code></pre>
<p>Demais! Com apenas um √∫ltimo ajuste, vamos finalizar o jogo de adivinha√ß√£o:
lembre-se que o programa ainda est√° mostrando o n√∫mero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o <code>println!</code> que revela o n√∫mero
secreto. A Listagem 2-5 mostra o c√≥digo final:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Advinhe o n√∫mero!&quot;);

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Digite o seu palpite.&quot;);

        let mut palpite = String::new();

        io::stdin().read_line(&amp;mut palpite)
            .expect(&quot;Falha ao ler entrada&quot;);

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Voc√™ disse: {}&quot;, palpite);

        match palpite.cmp(&amp;numero_secreto) {
            Ordering::Less =&gt; println!(&quot;Muito baixo!&quot;),
            Ordering::Greater =&gt; println!(&quot;Muito alto!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Voc√™ acertou!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listagem 2-5: C√≥digo completo do jogo de advinha√ß√£o.
</span></p>
<a class="header" href="print.html#resumo" id="resumo"><h2>Resumo</h2></a>
<p>Neste ponto, voc√™ construiu com sucesso o jogo de adivinha√ß√£o! Parab√©ns!</p>
<p>Este projeto foi uma forma pr√°tica de apresentar v√°rios conceitos novos de Rust:
<code>let</code>, <code>match</code>, m√©todos, fun√ß√µes associadas, uso de crates externos, e outros.
Nos pr√≥ximos cap√≠tulos, voc√™ vai aprender sobre esses conceitos em mais
detalhes. O Cap√≠tulo 3 aborda conceitos que a maioria das linguagens de
programa√ß√£o tem, como vari√°veis, tipos de dados e fun√ß√µes, e mostra como us√°-los
em Rust. O Cap√≠tulo 4 explora posse (<em>ownership</em>), que √© a caracter√≠stica do
Rust mais diferente das outras linguagens. O Cap√≠tulo 5 discute structs e a
sintaxe de m√©todos, e o Cap√≠tulo 6 se dedica a explicar enums.</p>
<a class="header" href="print.html#-conceitos-comuns-de-programa√ß√£o" id="-conceitos-comuns-de-programa√ß√£o"><h1>üáßüá∑ Conceitos Comuns de Programa√ß√£o</h1></a>
<a class="header" href="print.html#-vari√°veis-e-mutabilidade" id="-vari√°veis-e-mutabilidade"><h1>üáßüá∑ Vari√°veis e Mutabilidade</h1></a>
<a class="header" href="print.html#data-types" id="data-types"><h1>Data Types</h1></a>
<a class="header" href="print.html#how-functions-work" id="how-functions-work"><h1>How Functions Work</h1></a>
<a class="header" href="print.html#comments" id="comments"><h1>Comments</h1></a>
<a class="header" href="print.html#control-flow" id="control-flow"><h1>Control Flow</h1></a>
<a class="header" href="print.html#understanding-ownership" id="understanding-ownership"><h1>Understanding Ownership</h1></a>
<a class="header" href="print.html#what-is-ownership" id="what-is-ownership"><h1>What is Ownership?</h1></a>
<a class="header" href="print.html#references--borrowing" id="references--borrowing"><h1>References &amp; Borrowing</h1></a>
<a class="header" href="print.html#slices" id="slices"><h1>Slices</h1></a>
<a class="header" href="print.html#usando-structs-para-estruturar-dados-relacionados" id="usando-structs-para-estruturar-dados-relacionados"><h1>Usando Structs para Estruturar Dados Relacionados</h1></a>
<p>Uma <em>struct</em>, ou <em>estrutura</em>, √© um tipo de dados personalizado que nos permite
nomear e criar um conjunto de v√°rios valores relacionados que comp√µem um grupo
de dados. Se voc√™ estiver familiarizado com uma linguagem orientada a objeto,
um <em>struct</em> √© como os atributos de dados de um objeto. Neste cap√≠tulo, vamos
comparar e diferenciar tuplas com structs, demonstrar como usar structs e
discutir como definir os m√©todos e fun√ß√µes associadas √†s structs para
especificar o comportamento associado com os dados de uma struct. Os conceitos
de struct e <em>enum</em> (que ser√° discutido no Cap√≠tulo 6) s√£o os blocos necess√°rios
para a cria√ß√£o de novos tipos para o seu programa, para tirar o m√°ximo proveito
da verifica√ß√£o de tipo no tempo de compila√ß√£o do Rust.</p>
<a class="header" href="print.html#method-syntax" id="method-syntax"><h1>Method Syntax</h1></a>
<a class="header" href="print.html#enums-e-casamento-de-padr√µes-pattern-matching" id="enums-e-casamento-de-padr√µes-pattern-matching"><h1>Enums e Casamento de Padr√µes (<em>Pattern Matching</em>)</h1></a>
<p>Neste cap√≠tulo vamos ver <em>enumera√ß√µes</em>, tamb√©m chamadas de <em>enums</em>. Enums
permitem definir um tipo por meio da enumera√ß√£o de seus poss√≠veis valores.
Primeiro, vamos definir e usar uma enum para mostrar como ela pode atrelar
significado aos nossos dados. Depois, vamos explorar uma enum particularmente
√∫til, chamada <code>Option</code>, que expressa um valor que tanto pode ser algo quanto
pode n√£o ser nada. Em seguida, vamos ver como o casamento de padr√µes por meio
da express√£o <code>match</code> facilita a execu√ß√£o de c√≥digos diferentes para diferentes
valores de uma enum. Por fim, vamos abordar o <code>if let</code>, outra forma concisa e
conveniente que voc√™ pode usar para tratar enums no seu c√≥digo.</p>
<p>Enums s√£o ferramentas que aparecem em muitas linguagens, mas suas
caracter√≠sticas variam de uma para outra. Em Rust, enums s√£o mais parecidas com
os <em>tipos de dados alg√©bricos</em> das linguagens de programa√ß√£o funcional como F#,
OCaml e Haskell.</p>
<a class="header" href="print.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser √∫teis. Digamos que estamos trabalhando com
endere√ßos IP. Atualmente, existem duas vers√µes do protocolo IP que s√£o mais
utilizadas: a quatro e a seis. Estas s√£o as √∫nicas possibilidades para um
endere√ßo IP com que o nosso programa vai trabalhar: n√≥s podemos <em>enumerar</em>
todos os poss√≠veis valores, √© da√≠ que vem o nome enumera√ß√£o.</p>
<p>Um endere√ßo IP qualquer pode ser ou da vers√£o quatro ou da vers√£o seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endere√ßos IP faz com que a
enum seja bem apropriada para este caso, pois enums s√≥ podem assumir o valor de
uma de suas variantes. Os endere√ßos de ambas as vers√µes, seja quatro ou seis,
ainda s√£o, fundamentalmente, endere√ßos IP, e deveriam ser tratados pelo mesmo
tipo no c√≥digo em situa√ß√µes que se aplicam a qualquer vers√£o de endere√ßo IP.</p>
<p>Podemos expressar esse conceito em c√≥digo definindo uma enum <code>VersaoIp</code> e
listando os poss√≠veis tipos de que um endere√ßo IP pode ser: <code>V4</code> e <code>V6</code>. Estas
s√£o as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> √© um tipo de dados que agora n√≥s podemos usar em qualquer lugar no
nosso c√≥digo.</p>
<a class="header" href="print.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar inst√¢ncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso √© √∫til porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> s√£o do mesmo tipo: <code>VersaoIp</code>. Agora n√≥s podemos, por exemplo,
definir uma fun√ß√£o que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta fun√ß√£o passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endere√ßo IP, ainda n√£o temos uma forma de representar o <em>endere√ßo</em> em
si, apenas sabemos qual a <em>vers√£o</em> dele. Tendo em vista o que voc√™ acabou de
aprender sobre structs no Cap√≠tulo 5, voc√™ poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: Representa√ß√£o do endere√ßo e da variante
<code>VersaoIp</code> de um endere√ßo IP usando uma <code>struct</code></span></p>
<p>Aqui n√≥s definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas inst√¢ncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endere√ßo associado igual a <code>127.0.0.1</code>.
A segunda inst√¢ncia, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endere√ßo <code>::1</code> associado a ela. N√≥s usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante est√°
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova defini√ß√£o da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, ter√£o uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim n√£o existe mais
a necessidade de uma struct adicional.</p>
<p>H√° uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endere√ßos IP da vers√£o
quatro t√™m sempre quatro componentes num√©ricas, cada uma com valor de 0 a 255.
Se quis√©ssemos representar endere√ßos <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endere√ßos <code>V6</code> como uma <code>String</code>, n√£o poder√≠amos usar uma
struct. J√° as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poder√≠amos usar para representar
endere√ßos IP das duas vers√µes por meio de uma enum. Acontece que essa
necessidade de representar endere√ßos IP, incluindo sua vers√£o, √© t√£o comum que
a biblioteca padr√£o j√° possui uma defini√ß√£o que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documenta√ß√£o em ingl√™s</a><!-- ignore -->). Vamos ver como a biblioteca
padr√£o define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que n√≥s definimos e usamos anteriormente, mas os dados do endere√ßo s√£o
embutidos dentro das variantes na forma de duas structs separadas, que s√£o
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse c√≥digo mostra que voc√™ pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos num√©ricos ou structs, por exemplo. Voc√™ pode
at√© mesmo incluir outra enum! Al√©m disso, os tipos definidos pela biblioteca
padr√£o n√£o s√£o t√£o mais complicados do que o que talvez voc√™ pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padr√£o, n√≥s ainda
podemos criar e utilizar nossa pr√≥pria defini√ß√£o (com o mesmo nome, inclusive)
sem nenhum conflito, porque n√£o trouxemos a defini√ß√£o da biblioteca padr√£o para
dentro do nosso escopo. Falaremos mais sobre a inclus√£o de tipos em um escopo
no Cap√≠tulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes cont√™m,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> n√£o tem nenhum dado associado.</li>
<li><code>Mover</code> cont√©m uma struct an√¥nima.</li>
<li><code>Escrever</code> cont√©m uma √∫nica <code>String</code>.</li>
<li><code>MudarCor</code> cont√©m tr√™s valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais √†s da Listagem 6-2 √© similar a definir
diferentes tipos de struct, exceto que a enum n√£o usa a palavra-chave <code>struct</code>,
e todas as variantes s√£o agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu pr√≥prio tipo, n√£o vamos
conseguir t√£o facilmente definir uma fun√ß√£o que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo √∫nico.</p>
<p>H√° mais uma similaridade entre enums e structs: da mesma forma como podemos
definir m√©todos em structs usando <code>impl</code>, tamb√©m podemos definir m√©todos em
enums. Aqui est√° um m√©todo chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do m√©todo √© definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;ol√°&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do m√©todo usaria o valor <code>self</code> para obter a mensagem sobre a qual o
m√©todo foi chamado. Neste exemplo, criamos a vari√°vel <code>m</code>, que cont√©m o valor
<code>Mensagem::Escrever(String::from(&quot;ol√°&quot;))</code>, e √© isso que <code>self</code> vai ser no corpo
do m√©todo <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padr√£o que tamb√©m √© muito √∫til e
comum: <code>Option</code>.</p>
<a class="header" href="print.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na se√ß√£o anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informa√ß√£o do que apenas os
dados que queremos representar. Essa se√ß√£o explora um caso de estudo da
<code>Option</code>, que √© outra enum definida pela biblioteca padr√£o. O tipo <code>Option</code> √©
muito utilizado, pois engloba um cen√°rio muito comum, em que um valor pode ser
algo ou pode n√£o ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se voc√™ tratou, ou n√£o, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que s√£o extremamente
comuns em outras linguagens de programa√ß√£o.</p>
<p>O <em>design</em> de uma linguagem de programa√ß√£o √© geralmente tratado em termos de
quais caracter√≠sticas s√£o inclu√≠das, mas as que s√£o exclu√≠das tamb√©m t√™m
import√¢ncia. Rust n√£o tem o valor nulo (<em>null</em>) que outras linguagens t√™m. O
valor nulo quer dizer que n√£o h√° nenhum valor. Em linguagens que t√™m essa
caracter√≠stica, as vari√°veis sempre est√£o em um dos dois estados: nulo ou n√£o
nulo.</p>
<p>Em uma confer√™ncia, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilh√£o de d√≥lares. Naquela √©poca, eu estava
projetando o primeiro sistema abrangente de tipos para refer√™ncias em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
refer√™ncias deveria ser absolutamente seguro, com verifica√ß√£o autom√°tica
feita pelo compilador. Mas n√£o pude resistir √† tenta√ß√£o de colocar uma
refer√™ncia nula, simplesmente porque era t√£o f√°cil de implementar. Isso tem
provocado in√∫meros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilh√£o de d√≥lares de dor e danos nos √∫ltimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos √© que, se voc√™ tentar usar um valor nulo como se
fosse n√£o nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e n√£o nulo ser t√£o sutil, √© extremamente f√°cil cometer esse tipo de
erro.</p>
<p>Por√©m, o conceito que o valor nulo tenta expressar ainda √© √∫til: um valor nulo
representa algo que, por algum motivo, est√° inv√°lido ou ausente no momento.</p>
<p>O problema, na verdade, n√£o est√° no conceito, mas na implementa√ß√£o em
particular. Por isso, Rust n√£o possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum √© a
<code>Option&lt;T&gt;</code>, que est√° definida na biblioteca padr√£o da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documenta√ß√£o em ingl√™s</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> √© t√£o √∫til que ela j√° vem inclusa no prel√∫dio: voc√™ n√£o
precisa traz√™-la explicitamente para o seu escopo. Al√©m disso, o mesmo ocorre
com suas variantes: voc√™ pode usar <code>Some</code> e <code>None</code> diretamente sem prefix√°-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda s√£o variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> √© uma caracter√≠stica do Rust de que n√£o falamos ainda.
Trata-se de um par√¢metro de tipo gen√©rico, vamos abord√°-lo com mais detalhe no
Cap√≠tulo 10. Por ora, tudo que voc√™ precisa saber √© que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui v√£o
alguns exemplos de <code>Option</code> contendo tipos de n√∫mero e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual √© o tipo de
<code>Option&lt;T&gt;</code> que n√≥s temos, porque o compilador n√£o consegue inferir qual tipo
estar√° contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor est√° presente, contido dentro do
<code>Some</code>. J√° quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: n√£o temos um valor que seja v√°lido. Ent√£o por que a <code>Option&lt;T&gt;</code> √©
t√£o melhor que usar um valor nulo?</p>
<p>Em resumo, √© porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) s√£o
tipos diferentes, por isso, o compilador n√£o vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor v√°lido. Por exemplo,
o c√≥digo seguinte n√£o vai compilar, porque ele est√° tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse c√≥digo, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer √© que o Rust n√£o consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles s√£o de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor v√°lido. Podemos prosseguir com confian√ßa, sem ter de
verificar se o valor √© nulo antes de us√°-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de n√£o haver um valor, e o compilador
vai se certificar de que n√≥s estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, voc√™ tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar opera√ß√µes com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo n√£o √© nulo quando,
na verdade, ele √©.</p>
<p>S√≥ de n√£o ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar j√° lhe d√° mais confian√ßa em seu c√≥digo. Pra ter um valor que pode ser
nulo em algum momento, voc√™ precisa, explicitamente, marc√°-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir da√≠, sempre que for usar o valor, voc√™ ser√° obrigado
a tratar, de forma expl√≠cita, o caso do valor sendo nulo. Sempre que houver um
valor que n√£o seja um <code>Option&lt;T&gt;</code>, voc√™ <em>pode</em> assumir, com seguran√ßa, que o
valor n√£o √© nulo. Esta foi uma decis√£o deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a seguran√ßa do c√≥digo.</p>
<p>Ent√£o, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos m√©todos
que s√£o √∫teis em uma variedade de situa√ß√µes, voc√™ pode pesquis√°-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documenta√ß√£o</a><!-- ignore --> (em ingl√™s). Ser√° extremamente √∫til na sua
jornada com Rust se familizarizar com os m√©todos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um c√≥digo que trate cada
uma das variantes. Queremos um c√≥digo que s√≥ ser√° executado quando tivermos um
valor <code>Some(T)</code>, e esse c√≥digo ter√° permiss√£o para usar o valor <code>T</code> que est√°
embutido. Queremos tamb√©m um outro c√≥digo que seja executado se tivermos um
valor <code>None</code>, e esse c√≥digo n√£o ter√° um valor <code>T</code> dispon√≠vel. A express√£o
<code>match</code> √© uma instru√ß√£o de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa c√≥digos diferentes dependendo de qual variante
tiver a enum, e esse c√≥digo poder√° usar os dados contidos na variante
encontrada.</p>
<a class="header" href="print.html#operador-match-de-controle-de-fluxo" id="operador-match-de-controle-de-fluxo"><h2>Operador <code>match</code> de Controle de Fluxo</h2></a>
<p>O Rust tem um excelente operador de controle de fluxo chamado <code>match</code>, que nos
permite comparar um valor com uma s√©rie de padr√µes e executar um c√≥digo com
base no padr√£o que casar. Padr√µes podem ser compostos de valores literais,
vari√°veis, caracteres-curinga e v√°rias outras coisas. O Cap√≠tulo 18 aborda
todos os tipos de padr√µes e o que eles fazem. A grande utilidade do <code>match</code> vem
da expressividade dos padr√µes e das an√°lises feitas pelo compilador, tendo
certeza de que todos os casos poss√≠veis est√£o sendo tratados.</p>
<p>Imagine que express√£o <code>match</code> funciona como uma m√°quina de contar moedas: as
moedas passam por um canal que possui furos de v√°rios tamanhos, e cada moeda
cai no primeiro furo em que ela couber. Da mesma forma, os valores passam por
cada padr√£o de um <code>match</code>, e logo no primeiro padr√£o que o valor &quot;se encaixar&quot;,
o bloco de c√≥digo que estiver associado a ele ser√° executado.</p>
<p>Aproveitando que acabamos de falar sobre moedas, vamos us√°-las como exemplo de
utiliza√ß√£o do <code>match</code>! Podemos escrever uma fun√ß√£o que recebe uma moeda
qualquer dos Estados Unidos e, assim como uma m√°quina, determina qual moeda ela
√© e retorna seu valor em <em>cents</em>, como mostra a Listagem 6-3:</p>
<blockquote>
<p><strong>Nota do tradutor:</strong> diferentemente do que acontece na maioria dos pa√≠ses,
as moedas dos Estados Unidos possuem nomes: as de 1 <em>cent</em> s√£o chamadas de
<em>Penny</em>; as de 5 <em>cents</em>, de <em>Nickel</em>; as de 10 <em>cents</em>, de <em>Dime</em>; e as de 25
<em>cents</em>, de <em>Quarter</em>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-3: Uma enum e uma express√£o <code>match</code> em que os
padr√µes comparados s√£o as variantes da enum.</span></p>
<p>Vamos analisar o <code>match</code> da fun√ß√£o <code>valor_em_cents</code>. Primeiro, usamos a
palavra-chave <code>match</code> seguida de uma express√£o, que neste caso √© o valor
<code>moeda</code>. √â parecido a uma express√£o utilizada com <code>if</code>, mas tem uma grande
diferen√ßa: com <code>if</code>, a express√£o precisa retornar um valor <em>booleano</em>. Aqui,
pode ser de qualquer tipo. O tipo da vari√°vel <code>moeda</code>, neste exemplo, √© a enum
<code>Moeda</code>, que definimos na Listagem 6-3.</p>
<p>Em seguida v√™m os bra√ßos do <code>match</code>. Um bra√ßo √© composto por duas partes: um
padr√£o e algum c√≥digo. O primeiro bra√ßo deste exemplo tem um padr√£o, que √© o
valor <code>Moeda::Penny</code>, e o operador <code>=&gt;</code> que separa o padr√£o do c√≥digo associado
a ele. O c√≥digo, nesse caso, √© apenas o valor <code>1</code>. Os bra√ßos s√£o separados uns
dos outros com uma v√≠rgula.</p>
<p>Quando o <code>match</code> √© executado, ele compara o valor resultante com o padr√£o de
cada bra√ßo, na ordem. Se o valor casar com um determinado padr√£o, o c√≥digo
associado a esse padr√£o ser√° executado. Se o valor n√£o se encaixa nesse padr√£o,
a execu√ß√£o passa para o pr√≥ximo bra√ßo, bem parecido com a m√°quina de contar
moedas. Podemos ter tantos bra√ßos quanto precisamos. No caso da Listagem 6-3,
nosso <code>match</code> tem quatro bra√ßos.</p>
<p>O c√≥digo associado a cada bra√ßo √© uma express√£o, e o seu valor resultante, no
bra√ßo que combinar, √© o que ser√° retornado pela express√£o <code>match</code>.</p>
<p>Tipicamente n√£o se usa chaves se o bra√ßo do <code>match</code> for curto, como √© o caso na
Listagem 6-3, em que cada bra√ßo retorna apenas um valor. Se voc√™ quiser
executar mais de uma linha de c√≥digo em um bra√ßo, voc√™ pode usar chaves para
delimit√°-las. Por exemplo, o c√≥digo seguinte vai escrever na tela &quot;Moeda da
sorte!&quot; sempre que o m√©todo for chamado com uma <code>Moeda::Penny</code>, mas ainda vai
retornar o √∫ltimo valor do bloco, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter,
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; {
            println!(&quot;Moeda da sorte!&quot;);
            1
        },
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter =&gt; 25,
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#padr√µes-atrelados-a-valores" id="padr√µes-atrelados-a-valores"><h3>Padr√µes Atrelados a Valores</h3></a>
<p>Outra caracter√≠stica √∫til dos bra√ßos do <code>match</code> √© que eles podem ser atrelados
a partes dos valores que se encaixam no padr√£o. √â assim que podemos extrair
valores dentro de uma variante de uma enum.</p>
<p>Por exemplo, vamos alterar uma das nossas variantes, inserindo dados dentro
dela. De 1999 at√© 2008, os Estados Unidos cunhou <em>quarters</em> com um <em>design</em>
diferente para cada um dos 50 estados em um dos lados da moeda. Nenhuma outra
moeda tinha essa diferen√ßa no <em>design</em>, apenas os <em>quarters</em>. Podemos adicionar
essa informa√ß√£o √† nossa <code>enum</code> alterando a variante <code>Quarter</code> para incluir o
valor <code>Estado</code>, como √© feito na Listagem 6-4:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)] // Para podermos ver qual √© o estado com mais facilidade
enum Estado {
    Alabama,
    Alaska,
    // ... etc
}

enum Moeda {
    Penny,
    Nickel,
    Dime,
    Quarter(Estado),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-4: Enum <code>Moeda</code>, cuja variante <code>Quarter</code>
tamb√©m guarda o valor <code>Estado</code>.</span></p>
<p>Vamos imaginar que um amigo nosso est√° tentando colecionar todas os <em>quarters</em>
dos 50 estados. Enquanto separamos nosso troco por tipo de moeda, vamos tamb√©m
dizer o nome do estado associado a cada <em>quarter</em>. Se for um dos que o nosso
amigo ainda n√£o tem, ele pode coloc√°-lo na sua cole√ß√£o.</p>
<p>Na express√£o <code>match</code> desse c√≥digo, vamos adicionar uma vari√°vel chamada
<code>estado</code> ao padr√£o que casa com os valores da variante <code>Moeda::Quarter</code>. Quando
uma <code>Moeda::Quarter</code> √© testada, a vari√°vel <code>estado</code> vai ser atrelada ao valor
do estado daquele <em>quarter</em>. Assim vamos poder usar o <code>estado</code> no c√≥digo do
bra√ßo, desse jeito:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
#
fn valor_em_cents(moeda: Moeda) -&gt; u32 {
    match moeda {
        Moeda::Penny =&gt; 1,
        Moeda::Nickel =&gt; 5,
        Moeda::Dime =&gt; 10,
        Moeda::Quarter(estado) =&gt; {
            println!(&quot;Quarter do estado {:?}!&quot;, estado);
            25
        },
    }
}
#}</code></pre></pre>
<p>Se executarmos <code>valor_em_cents(Moeda::Quarter(Estado::Alaska))</code>, <code>moeda</code> seria
<code>Moeda::Quarter(Estado::Alaska)</code>. Quando comparamos esse valor em cada um dos
bra√ßos do <code>match</code>, nenhum deles vai casar enquanto n√£o chegar em
<code>Moeda::Quarter(estado)</code>. Nesse ponto, <code>estado</code> vai estar atrelado ao valor
<code>Estado::Alaska</code>. Podemos, ent√£o, usar esse valor na express√£o <code>println!</code>,
obtendo o estado contido na variante <code>Quarter</code> da enum <code>Moeda</code>.</p>
<a class="header" href="print.html#usando-match-com-optiont" id="usando-match-com-optiont"><h3>Usando <code>match</code> com <code>Option&lt;T&gt;</code></h3></a>
<p>Na se√ß√£o anterior, quer√≠amos obter o valor <code>T</code> contido em um <code>Some</code> quando era
o caso em uma <code>Option&lt;T&gt;</code>. Tamb√©m podemos manipular uma <code>Option&lt;T&gt; usando</code>match<code>, assim como fizemos com a enum</code>Moeda<code>! Em vez de comparar moedas, vamos comparar as variantes de</code>Option<T><code>, mas a forma de trabalhar com a express√£o</code>match` continua a mesma.</p>
<p>Digamos que queremos escrever uma fun√ß√£o que recebe um <code>Option&lt;i32&gt;</code>, e se
houver um valor embutido nele, soma um a esse valor. Se n√£o houver um valor,
a fun√ß√£o deve retornar <code>None</code>, e nem tentar executar nenhuma opera√ß√£o.</p>
<p>Essa fun√ß√£o √© bem f√°cil de implementar, gra√ßas ao <code>match</code>, e vai ficar conforme
visto na Listagem 6-5:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let cinco = Some(5);
let seis = mais_um(cinco);
let nenhum = mais_um(None);
#}</code></pre></pre>
<p><span class="caption">Listagem 6-5: Uma fun√ß√£o que usa um <code>match</code> para tratar
uma <code>Option&lt;i32&gt;</code>.</span></p>
<a class="header" href="print.html#casando-somet" id="casando-somet"><h4>Casando <code>Some(T)</code></h4></a>
<p>Vamos examinar a primeira execu√ß√£o de <code>mais_um</code> em mais detalhes. Quando
chamamos <code>mais_um(cinco)</code>, a vari√°vel <code>x</code> no corpo da fun√ß√£o <code>mais_um</code> vai ter
o valor <code>Some(5)</code>. Ent√£o comparamos ele a cada bra√ßo do <code>match</code>.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>O valor <code>Some(5)</code> n√£o casa com o padr√£o <code>None</code>, ent√£o seguimos para o
pr√≥ximo bra√ßo.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p><code>Some(5) casa com</code>Some(i)<code>? Sim, casa! Temos a mesma variante. O</code>i<code>est√° atrelado ao valor contido em</code>Some<code>, ent√£o</code>i<code>passa a ter o valor</code>5<code>. O c√≥digo desse bra√ßo √© executado, ent√£o somamos um ao valor de</code>i<code>e criamos um novo</code>Some<code>contendo nosso total de</code>6`.</p>
<a class="header" href="print.html#casando-none" id="casando-none"><h4>Casando <code>None</code></h4></a>
<p>Agora vamos considerar a segunda chamada da fun√ß√£o <code>mais_um</code> na Listagem 6-5,
em que <code>x</code> √© <code>None</code>. N√≥s entramos no <code>match</code> e comparamos com o primeiro bra√ßo.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Confere! N√£o h√° nenhum valor para somar, ent√£o o programa p√°ra e retorna o
valor <code>None</code> do lado direito do <code>=&gt;</code>. Como o primeiro bra√ßo j√° casou, nenhum
dos demais ser√° testado.</p>
<p>A combina√ß√£o de enums e a express√£o <code>match</code> √© √∫til em diversas situa√ß√µes. Voc√™
ver√° muito esse padr√£o em Rust: fazer o <code>match</code> de uma enum, associar uma
vari√°vel ao valor embutido, e ent√£o executar um c√≥digo baseado nele. Pode
parecer complicado no come√ßo, mas uma vez que voc√™ se acostume, voc√™ vai querer
que tivesse isso em todas as linguagens. √â, sistematicamente, um favorito dos
usu√°rios.</p>
<a class="header" href="print.html#matches-s√£o-exaustivos" id="matches-s√£o-exaustivos"><h3><em>Matches</em> S√£o Exaustivos</h3></a>
<p>H√° outro aspecto do <code>match</code> que precisamos discutir. Considere essa vers√£o da
nossa fun√ß√£o <code>mais_um</code>:</p>
<pre><code class="language-rust ignore">fn mais_um(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>N√≥s n√£o tratamos o caso <code>None</code>, logo vai ocorrer um <em>bug</em> no nosso c√≥digo. Por
sorte, √© um <em>bug</em> que o Rust sabe detectar. Se tentarmos compilar esse c√≥digo,
vamos ter esse erro:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>O Rust sabe que n√≥s n√£o cobrimos todos os casos poss√≠veis, e sabe at√© de qual
padr√£o nos esquecemos! <em>Matches</em> em Rust s√£o <em>exaustivos</em>: precisamos extinguir
at√© a √∫ltima possibilidade pra que o nosso c√≥digo seja v√°lido. Especialmente no
caso de uma <code>Option&lt;T&gt;</code>, em que o Rust n√£o nos deixa esquecer de tratar
explicitamente o caso <code>None</code>. Ele nos impede de assumir que temos um valor
v√°lido quando possivelmente temos um valor nulo, e portanto, cometer o erro de
um bilh√£o de d√≥lares que vimos mais cedo.</p>
<a class="header" href="print.html#the-_-placeholder" id="the-_-placeholder"><h3>The <code>_</code> Placeholder</h3></a>
<a class="header" href="print.html#o-placeholder-_" id="o-placeholder-_"><h3>O <em>Placeholder</em> <code>_</code></h3></a>
<p>O Rust tamb√©m tem um padr√£o que podemos usar em situa√ß√µes em que n√£o queremos
listar todos os valores poss√≠veis. Por exemplo, um <code>u8</code> pode ter valores
v√°lidos de 0 a 255. Se nos importamos apenas com os valores 1, 3, 5 e 7, n√£o
queremos ser obrigados a listar o 0, 2, 4, 6, 8, 9, e assim por diante at√© 255.
Felizmente, nem precisamos: em vez disso, podemos usar o padr√£o especial <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = 0u8;
match algum_valor_u8 {
    1 =&gt; println!(&quot;um&quot;),
    3 =&gt; println!(&quot;tr√™s&quot;),
    5 =&gt; println!(&quot;cinco&quot;),
    7 =&gt; println!(&quot;sete&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p>O padr√£o <code>_</code> casa com qualquer valor. Colocando ele depois dos demais
bra√ßos, o <code>_</code> vai casar com todos os casos poss√≠veis que n√£o foram
especificados antes dele. O <code>()</code> √© s√≥ o valor-unidade, pra que nada aconte√ßa no
caso <code>_</code>. Como resultado, podemos dizer que n√£o queremos fazer nada com os
poss√≠veis valores que n√£o listamos antes do <em>placeholder</em> <code>_</code>.</p>
<p>Contudo, a express√£o <code>match</code> pode ser um tanto verbosa em uma situa√ß√£o em que
queremos apenas lidar com <em>um</em> dos casos. Pra essa situa√ß√£o, o Rust oferece o
<code>if let</code>.</p>
<a class="header" href="print.html#controle-de-fluxo-conciso-com-if-let" id="controle-de-fluxo-conciso-com-if-let"><h2>Controle de Fluxo Conciso com <code>if let</code></h2></a>
<p>A sintaxe do <code>if let</code> permite combinar <code>if</code> e <code>let</code> em uma forma menos verbosa
de tratar apenas os valores que casam com um padr√£o e ignorar os demais.
Considere o programa da Listagem 6-6, que confere um valor do tipo
<code>Option&lt;u8&gt;</code>, mas s√≥ executa um c√≥digo se houver um valor associado igual a
tr√™s:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_valor_u8 = Some(0u8);
match algum_valor_u8 {
    Some(3) =&gt; println!(&quot;tr√™s&quot;),
    _ =&gt; (),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-6: Um <code>match</code> que s√≥ executa um c√≥digo quando
o valor √© <code>Some(3)</code>.</span></p>
<p>Queremos fazer alguma coisa com o <code>Some(3)</code>, mas n√£o queremos fazer nada com
nenhum outro valor, seja <code>Some&lt;u8&gt;</code> ou <code>None</code>. Pra satisfazer a express√£o
<code>match</code>, temos que colocar <code>_ =&gt; ()</code> ap√≥s processar apenas uma variante, ou
seja, √© muito c√≥digo para pouca coisa.</p>
<p>Em vez disso, poder√≠amos escrever o mesmo c√≥digo de uma forma mais compacta,
usando <code>if let</code>. O c√≥digo seguinte tem o mesmo comportamento do <code>match</code> na
Listagem 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let algum_valor_u8 = Some(0u8);
if let Some(3) = algum_valor_u8 {
    println!(&quot;tr√™s&quot;);
}
#}</code></pre></pre>
<p><code>if let</code> recebe um padr√£o e uma express√£o separados por um <code>=</code>. Isso funciona
da mesma forma que um <code>match</code>, em que a express√£o seria passada para o <code>match</code>,
e o padr√£o apareceria no primeiro bra√ßo.</p>
<p>Usar o <code>if let</code> implica menos c√≥digo pra digitar e menos indenta√ß√£o. Por√©m,
perdemos a verifica√ß√£o exaustiva que √© garantida pelo <code>match</code>. A escolhe entre
<code>match</code> e <code>if let</code> depende do que voc√™ est√° fazendo em uma situa√ß√£o particular,
e se a redu√ß√£o no volume de c√≥digo compensa a perda da verifica√ß√£o exaustiva.</p>
<p>Em outras palavras, voc√™ pode enxergar o <code>if let</code> como um <em>syntax sugar</em> (um
atalho) para um <code>match</code> que s√≥ executa um c√≥digo quando o valor casa com um
√∫nico padr√£o, e ignora todos os outros valores.</p>
<p>Tamb√©m podemos incluir um <code>else</code> em um <code>if let</code>. O bloco de c√≥digo que vai no
<code>else</code> √© o mesmo que iria no caso <code>_</code> da express√£o <code>match</code> equivalente.
Lembre-se da enum <code>Moeda</code> que definimos na Listagem 6-4, cuja variante
<code>Quarter</code> guardava um valor do tipo <code>Estado</code>. Se queremos contar todas as
moedas que n√£o forem <em>quarters</em>, enquanto tamb√©m anunciamos o estado dos
<em>quarters</em>, poder√≠amos fazer isso com uma express√£o <code>match</code> igual a esta:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Coin::Penny;
let mut contagem = 0;
match moeda {
    Moeda::Quarter(estado) =&gt; println!(&quot;Quarter do estado {:?}!&quot;, estado),
    _ =&gt; contagem += 1,
}
#}</code></pre></pre>
<p>Ou poder√≠amos usar um <code>if let</code> e um <code>else</code> desta forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum Estado {
#    Alabama,
#    Alaska,
# }
#
# enum Moeda {
#    Penny,
#    Nickel,
#    Dime,
#    Quarter(Estado),
# }
# let moeda = Moeda::Penny;
let mut contagem = 0;
if let Moeda::Quarter(estado) = moeda {
    println!(&quot;Quarter do estado {:?}!&quot;, estado);
} else {
    contagem += 1;
}
#}</code></pre></pre>
<p>Se a l√≥gica do seu programa fica muito verbosa quando √© expressa por meio de um
<code>match</code>, lembre-se que voc√™ tamb√©m disp√µe do <code>if let</code>.</p>
<a class="header" href="print.html#resumo-1" id="resumo-1"><h2>Resumo</h2></a>
<p>N√≥s acabamos de ver como usar enums para criar tipos customizados a partir de
um conjunto de valores enumerados. Mostramos como o tipo <code>Option&lt;T&gt;</code>, da
biblioteca padr√£o, ajuda voc√™ a usar o sistema de tipos para evitar erros.
Quando as enums cont√™m dados, voc√™ pode usar <code>match</code> ou <code>if let</code> para extrair
e usar esses valores, dependendo de quantos casos voc√™ precisa tratar.</p>
<p>Agora, seus programas em Rust podem expressar conceitos em seu dom√≠nio usando
structs e enums. Criar tipos customizados para a sua <em>API</em> aumenta sua
seguran√ßa: o compilador vai se certificar de que suas fun√ß√µes recebem apenas
os valores que correspondem aos tipos esperados.</p>
<p>Para fornecer uma API bem organizada aos seus usu√°rios, que seja simples de
usar, e que exponha apenas o que √© necess√°rio aos usu√°rios, vamos agora passar
para os m√≥dulos em Rust.</p>
<a class="header" href="print.html#usando-m√≥dulos-para-reutilizar-e-organizar-c√≥digo" id="usando-m√≥dulos-para-reutilizar-e-organizar-c√≥digo"><h1>Usando M√≥dulos para Reutilizar e Organizar C√≥digo</h1></a>
<p>Quando voc√™ come√ßa a escrever programas em Rust, seu c√≥digo pode se manter apenas na
fun√ß√£o <code>main</code>. √Ä medida que seu c√≥digo cresce, voc√™ acabar√° por mover funcionalidades para
outras outras fun√ß√µes a fim de reutilizar c√≥digo e melhorar a organiza√ß√£o. Ao dividir seu c√≥digo em
pequenos peda√ßos, cada peda√ßo √© mais f√°cil de entender por si s√≥. Mas o que acontece
se voc√™ tem muitas fun√ß√µes? Rust possui um sistema de m√≥dulos que permite a reutiliza√ß√£o
de c√≥digo de forma organizada.</p>
<p>Da mesma forma que voc√™ extrai linhas de c√≥digo em uma fun√ß√£o, voc√™ pode extrair
fun√ß√µes (e outros c√≥digos, como structs e enums) em diferentes m√≥dulos. Um
<em>m√≥dulo</em> √© um namespace que cont√©m defini√ß√µes de fun√ß√µes ou tipos, e
voc√™ pode escolher se essas defini√ß√µes s√£o vis√≠veis fora de seu m√≥dulo
(p√∫blico) ou n√£o (privado). Aqui est√° uma vis√£o geral de como os m√≥dulos funcionam:</p>
<ul>
<li>A palavra-chave <code>mod</code> declara um novo m√≥dulo. O c√≥digo dentro do m√≥dulo aparece
¬†¬† imediatamente ap√≥s esta declara√ß√£o dentro de chaves ou em
¬†¬† outro arquivo.</li>
<li>Por padr√£o, as fun√ß√µes, tipos, constantes e m√≥dulos s√£o privados. A palavra-chave <code>pub</code>
¬†¬†  torna um item p√∫blico e, portanto, vis√≠vel fora do seu namespace.</li>
<li>A palavra-chave <code>use</code> traz m√≥dulos, ou as defini√ß√µes dentro dos m√≥dulos, ao
¬†¬† escopo, assim √© mais f√°cil se referir a eles.</li>
</ul>
<p>Examinaremos cada uma dessas partes para ver como elas se encaixam no todo.</p>
<a class="header" href="print.html#mod-e-o-sistema-de-arquivos" id="mod-e-o-sistema-de-arquivos"><h2><code>mod</code> e o Sistema de Arquivos</h2></a>
<p>Vamos iniciar o nosso exemplo de m√≥dulo fazendo um novo projeto com o Cargo, mas em vez de
criar um crate bin√°rio, faremos um crate de biblioteca: um projeto que
as outras pessoas podem puxar para os seus projetos como uma depend√™ncia. Por exemplo, o crate <code>rand</code>
discutido no Cap√≠tulo 2, √© um crate de biblioteca que usamos como uma depend√™ncia no
projeto do jogo de adivinha√ß√£o.</p>
<p>Criaremos um esqueleto de uma biblioteca que fornece algumas funcionalidades gerais
de rede; nos concentraremos na organiza√ß√£o dos m√≥dulos e fun√ß√µes,
mas n√£o nos preocuparemos com o c√≥digo que est√° dentro das fun√ß√µes. Chamaremos
nossa biblioteca de <code>communicator</code>. Por padr√£o, o Cargo criar√° uma biblioteca, a menos que
outro tipo de projeto seja especificado: se omitimos a op√ß√£o <code>--bin</code>, que temos
usado em todos os cap√≠tulos anteriores a este, nosso projeto ser√° um
biblioteca:</p>
<pre><code class="language-text">$ cargo new communicator
$ cd communicator
</code></pre>
<p>Observe que Cargo gerou <em>src/lib.rs</em> em vez de <em>src/main.rs</em>. Dentro de
<em>src/lib.rs</em> encontraremos o seguinte:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Cargo cria um teste de exemplo para nos ajudar a come√ßar nossa biblioteca, em vez de
o bin√°rio ‚ÄúHello, world!‚Äù que recebemos quando usamos a op√ß√£o <code>--bin</code>. Olharemos
a sintaxe <code>#[]</code> e <code>mod tests</code> no ‚ÄúUsando <code>super</code> para Acessar um
M√≥dulo Pai‚Äù mais adiante neste cap√≠tulo, mas por agora, deixe este c√≥digo
na parte inferior de <em>src/lib.rs</em>.</p>
<p>Como n√£o temos um arquivo <em>src/main.rs</em>, n√£o h√° nada para ser executado pelo Cargo
com o comando <code>cargo run</code>. Portanto, usaremos o comando  <code>cargo build</code>
para compilar o c√≥digo da nossa biblioteca.</p>
<p>Examinaremos diferentes op√ß√µes para organizar o c√≥digo da sua biblioteca que ser√£o
adequados em uma variedade de situa√ß√µes, dependendo da inten√ß√£o do c√≥digo.</p>
<a class="header" href="print.html#defini√ß√µes-do-m√≥dulo" id="defini√ß√µes-do-m√≥dulo"><h3>Defini√ß√µes do M√≥dulo</h3></a>
<p>Para a nossa biblioteca de rede <code>communicator</code>, primeiro definiremos um m√≥dulo chamado
<code>network</code> que cont√©m a defini√ß√£o de uma fun√ß√£o chamada<code>connect</code>. Cada
defini√ß√£o de m√≥dulo em Rust come√ßa com a palavra-chave <code>mod</code>. Adicione este c√≥digo ao
in√≠cio do arquivo <em>src/lib.rs</em>, acima do c√≥digo de teste:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Ap√≥s a palavra-chave <code>mod</code>, colocamos o nome do m√≥dulo, <code>network</code> e, em seguida, um
bloco de c√≥digo entre chaves. Tudo dentro deste bloco est√° dentro do
namespace <code>network</code>. Neste caso, temos uma √∫nica fun√ß√£o, <code>connect</code>. Se n√≥s
quisermos chamar essa fun√ß√£o do c√≥digo fora do m√≥dulo <code>network</code>, n√≥s
precisaremos especificar o m√≥dulo e usar a sintaxe do namespace <code>::</code>, assim:
<code>network::connect()</code> em vez de apenas <code>connect()</code>.</p>
<p>Tamb√©m podemos ter m√∫ltiplos m√≥dulos, lado a lado, no mesmo arquivo <em>src/lib.rs</em>.
Por exemplo, para ter mais um m√≥dulo <code>client</code> que possui uma fun√ß√£o chamada <code>connect</code>
, podemos adicion√°-lo como mostrado na Listagem 7-1:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }
}

mod client {
    fn connect() {
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-1: O m√≥dulo <code>network</code> e o m√≥dulo <code>client</code>
definidos lado a lado em <em>src/lib.rs</em> </span></p>
<p>Agora, temos uma fun√ß√£o <code>network::connect</code> e uma fun√ß√£o <code>client::connect</code>.
Estas podem ter funcionalidades completamente diferentes, e os nomes das fun√ß√µes
n√£o est√£o em conflito entre si porque est√£o em m√≥dulos diferentes.</p>
<p>Nesse caso, como estamos construindo uma biblioteca, o arquivo que serve como
ponto de entrada para construir nossa biblioteca √© <em>src/lib.rs</em>. No entanto, em rela√ß√£o a
cria√ß√£o de m√≥dulos, n√£o h√° nada de especial sobre <em>src/lib.rs</em>. Poder√≠amos tamb√©m
criar m√≥dulos em <em>src/main.rs</em> para um crate bin√°rio da mesma forma que n√≥s
criamos m√≥dulos em <em>src/lib.rs</em> para o crate de biblioteca. Na verdade, podemos colocar m√≥dulos
dentro de m√≥dulos, o que pode ser √∫til √† medida que seus m√≥dulos crescem para manter juntas
funcionalidades relacionadas e separar funcionalidades n√£o relacionadas. A
escolha de como voc√™ organiza seu c√≥digo depende do que voc√™ pensa sobre a
rela√ß√£o entre as partes do seu c√≥digo. Por exemplo, o c√≥digo <code>client</code>
e a fun√ß√£o <code>connect</code> podem ter mais sentido para os usu√°rios de nossa biblioteca se
eles estivessem dentro do namespace <code>network</code>, como na Listagem 7-2:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod network {
    fn connect() {
    }

    mod client {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class = "caption"> Listagem 7-2: Movendo o m√≥dulo <code>client</code> para dentro do
m√≥dulo <code>network</code></span></p>
<p>No seu arquivo <em>src/lib.rs</em>, substitua as defini√ß√µes <code>mod network</code> e <code>mod client</code>
pelas da Listagem 7-2, que possuem o m√≥dulo <code>client</code> como um
m√≥dulo interno da <code>network</code>. Agora temos as fun√ß√µes <code>network::connect</code> e
<code>network::client::connect</code>: novamente, as duas fun√ß√µes denominadas <code>connect</code> n√£o conflitam
uma com a outra porque elas est√£o em diferentes namespaces.</p>
<p>Desta forma, os m√≥dulos formam uma hierarquia. O conte√∫do de <em>src/lib.rs</em> est√° no
n√≠vel superior mais alto, e os subm√≥dulos est√£o em n√≠veis mais baixos. Aqui est√°
a nossa organiza√ß√£o quando pensada de forma hier√°rquica na Listagem 7-1:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ network
 ‚îî‚îÄ‚îÄ client
</code></pre>
<p>E aqui est√° a hierarquia correspondente ao exemplo na Listagem 7-2:</p>
<pre><code class="language-text">communicator
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ client
</code></pre>
<p>Conforme a hierarquia mostrada na Listagem 7-2, <code>client</code> √© um filho do m√≥dulo <code>network</code>
em vez de um irm√£o. Projetos mais complicados podem ter muitos m√≥dulos, √© necess√°rio
organiz√°-los logicamente para mant√™-los sob controle. O que &quot;logicamente&quot; significa em
seu projeto fica a seu crit√©rio, e depende do que voc√™ e os usu√°rios da sua biblioteca
pensam sobre o dom√≠nio do seu projeto. Use as t√©cnicas mostradas
aqui para criar m√≥dulos lado a lado e m√≥dulos aninhados em qualquer estrutura que
voc√™ queira.</p>
<a class="header" href="print.html#movendo-m√≥dulos-para-outros-arquivos" id="movendo-m√≥dulos-para-outros-arquivos"><h3>Movendo M√≥dulos para Outros Arquivos</h3></a>
<p>Os m√≥dulos formam uma estrutura hier√°rquica, bem parecida com outra estrutura computacional
que voc√™ conhece: sistemas de arquivos! Podemos usar o sistema de m√≥dulos do Rust juntamente com
v√°rios arquivos para dividir projetos Rust de forma que nem tudo resida em
<em>src/lib.rs</em> ou <em>src/main.rs</em>. Para este exemplo, vamos come√ßar com o c√≥digo em
Listagem 7-3:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod client {
    fn connect() {
    }
}

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
#}</code></pre></pre>
<p><span class="caption">Listagem 7-3: Tr√™s m√≥dulos, <code>client</code>, <code>network</code>, e
<code>network::server</code>, todos definidos em <em>src/lib.rs</em></span></p>
<p>O arquivo <em>src/lib.rs</em> possui esta hierarquia de m√≥dulos:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ server
</code></pre>
<p>Se esses m√≥dulos tivessem muitas fun√ß√µes, e elas estivessem se alongando muito,
seria dif√≠cil percorrer esse arquivo para encontrar o c√≥digo com que queremos
trabalhar. Como as fun√ß√µes est√£o aninhadas dentro de um ou mais blocos <code>mod</code>,
as linhas de c√≥digo dentro das fun√ß√µes come√ßar√£o a se alongar tamb√©m.
Estes seriam bons motivos para separar os m√≥dulos <code>client</code>, <code>network</code>, e <code>server</code>
de <em>src/lib.rs</em> e coloc√°-los em seus pr√≥prios arquivos.</p>
<p>Primeiro, substitua o c√≥digo do m√≥dulo <code>client</code> por apenas a declara√ß√£o do
m√≥dulo <code>client</code>, para que seu <em>src/lib.rs</em> se pare√ßa com o c√≥digo mostrado na Listagem 7-4:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network {
    fn connect() {
    }

    mod server {
        fn connect() {
        }
    }
}
</code></pre>
<p><span class="caption"> Listagem 7-4: Extraindo o conte√∫do do m√≥dulo <code>client</code>, mas deixando a declara√ß√£o em <em>src/lib.rs</em> </span></p>
<p>Ainda estamos <em>declarando</em> o m√≥dulo <code>client</code> aqui, mas ao substituir o bloco
por um ponto e v√≠rgula, estamos dizendo ao Rust para que procure, em outro local, o c√≥digo
definido no escopo do m√≥dulo <code>client</code>. Em outras palavras, a linha <code>mod client;</code> significa:</p>
<pre><code class="language-rust ignore">mod client {
    // conte√∫do de client.rs
}
</code></pre>
<p>Agora precisamos criar o arquivo externo com o nome do m√≥dulo. Crie um
arquivo <em>client.rs</em> em <em>src/</em> e abra-o. Em seguida digite o seguinte,
que √© a fun√ß√£o <code>connect</code> do m√≥dulo <code>client</code> que foi
removida na etapa anterior:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Observe que n√£o precisamos de uma declara√ß√£o <code>mod</code> neste arquivo porque j√° fizemos
a declara√ß√£o do m√≥dulo <code>client</code> com <code>mod</code> em <em>src/lib.rs</em>. Este arquivo apenas
fornece o <em>conte√∫do</em> do m√≥dulo <code>client</code>. Se colocarmos um <code>mod client</code> aqui,
n√≥s estar√≠amos dando ao m√≥dulo <code>client</code> seu pr√≥prio subm√≥dulo chamado <code>client</code>!</p>
<p>Rust s√≥ sabe olhar em <em>src/lib.rs</em> por padr√£o. Se quisermos adicionar mais
arquivos para o nosso projeto, precisamos dizer ao Rust em <em>src/lib.rs</em> para procurar em outros
arquivos; √© por isso que <code>mod client</code> precisa ser definido em <em>src/lib.rs</em> e n√£o pode
ser definido em <em>src/client.rs</em>.</p>
<p>Agora, o projeto deve compilar com sucesso, embora voc√™ obtenha alguns
warnings (avisos). Lembre-se de usar <code>cargo build</code>, em vez de <code>cargo run</code>, porque temos
um crate de biblioteca em vez de um crate bin√°rio:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/lib.rs:4:5
  |
4 | /     fn connect() {
5 | |     }
  | |_____^

warning: function is never used: `connect`
 --&gt; src/lib.rs:8:9
  |
8 | /         fn connect() {
9 | |         }
  | |_________^
</code></pre>
<p>Esses <em>warnings</em> nos dizem que temos fun√ß√µes que nunca s√£o usadas. N√£o se preocupe
com esses <em>warnings</em> por enquanto; vamos abord√°-los mais adiante neste cap√≠tulo, na
se√ß√£o ‚ÄúControlando a visibilidade com <code>pub</code>‚Äù. A boa not√≠cia √© que eles s√£o apenas
<em>warnings</em>; nosso projeto foi constru√≠do com sucesso!</p>
<p>Em seguida, vamos extrair o m√≥dulo <code>network</code> em seu pr√≥prio arquivo usando o mesmo
procedimento. Em <em>src/lib.rs</em>, exclua o corpo do m√≥dulo <code>network</code> e adicione um
ponto e v√≠rgula √† declara√ß√£o, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod client;

mod network;
</code></pre>
<p>Em seguida, crie um novo arquivo <em>src/network.rs</em> e digite o seguinte:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}

mod server {
    fn connect() {
    }
}
#}</code></pre></pre>
<p>Observe que ainda temos uma declara√ß√£o <code>mod</code> dentro deste arquivo de m√≥dulo; isto √©
porque ainda queremos que <code>server</code> seja um subm√≥dulo de <code>network</code>.</p>
<p>Execute <code>cargo build</code> novamente. Sucesso! Temos mais um m√≥dulo para extrair: <code>server</code>.
Como ele √© um subm√≥dulo - ou seja, um m√≥dulo dentro de outro - nossa t√°tica atual de
extrair um m√≥dulo para um arquivo com o nome do m√≥dulo n√£o funcionar√°. Iremos
tentar, de qualquer maneira, para que voc√™ possa ver o erro. Primeiro, altere o arquivo <em>src/network.rs</em> colocando
<code>mod server;</code> no lugar do conte√∫do do m√≥dulo <code>server</code>:</p>
<p><span class="filename">Arquivo: src/network.rs</span></p>
<pre><code class="language-rust ignore">fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, crie um arquivo <em>src/server.rs</em> e insira o conte√∫do do m√≥dulo <code>server</code>
que extra√≠mos:</p>
<p><span class="filename">Arquivo: src/server.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn connect() {
}
#}</code></pre></pre>
<p>Quando tentamos <code>cargo build</code>, obteremos o erro mostrado na Listagem 7-5:</p>
<pre><code class="language-text">$ cargo build
   Compiling communicator v0.1.0 (file:///projects/communicator)
error: cannot declare a new module at this location
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
  |
note: maybe move this module `src/network.rs` to its own directory via `src/network/mod.rs`
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
note: ... or maybe `use` the module `server` instead of possibly redeclaring it
 --&gt; src/network.rs:4:5
  |
4 | mod server;
  |     ^^^^^^
</code></pre>
<p><span class="caption">Listagem 7-5: Erro ao tentar extrair o subm√≥dulo <code>server</code>
em <em>src/server.rs</em> </span></p>
<p>O erro diz que n√£o podemos declarar um novo m√≥dulo neste local (<code>cannot declare a new module at this location</code>)
e est√° apontando para a linha <code>mod server</code>; em <em>src/network.rs</em>. Ent√£o <em>src/network.rs</em> √©
diferente de <em>src/lib.rs</em> de alguma forma: continue lendo para entender o porqu√™.</p>
<p>A nota no meio da Listagem 7-5 √© realmente muito √∫til,
porque ela aponta para algo de que n√£o falamos ainda:</p>
<pre><code class="language-text">note: maybe move this module `network` to its own directory via
`network/mod.rs`
</code></pre>
<p>(<strong>Tradu√ß√£o:</strong> talvez mover este m√≥dulo network para o seu pr√≥prio diret√≥rio via <code>network/mod.rs</code>)</p>
<p>Em vez de continuar a seguir o mesmo padr√£o de nomea√ß√£o de arquivo usado
anteriormente, podemos fazer o que a nota sugere:</p>
<ol>
<li>Crie um novo <em>diret√≥rio</em> chamado <em>network</em>, o nome do m√≥dulo pai.</li>
<li>Mova o arquivo <em>src/network.rs</em> para o novo diret√≥rio <em>network</em> e
¬†¬†¬† renomeie para <em>src/network/mod.rs</em>.</li>
<li>Mova o arquivo de subm√≥dulo <em>src/server.rs</em> para o diret√≥rio <em>network</em>.</li>
</ol>
<p>Aqui est√£o os comandos para executar estas etapas:</p>
<pre><code class="language-text">$ mkdir src/network
$ mv src/network.rs src/network/mod.rs
$ mv src/server.rs src/network
</code></pre>
<p>Agora, quando tentamos executar <code>cargo build</code>, a compila√ß√£o funcionar√° (embora ainda teremos
avisos). O layout dos nossos m√≥dulos ainda √© exatamente o
mesmo de quando t√≠nhamos todo o c√≥digo em <em>src/lib.rs</em> na Listagem 7-3:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ server
</code></pre>
<p>O layout dos arquivos correspondentes agora ficou assim:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ client.rs
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs
‚îÇ   ‚îî‚îÄ‚îÄ network
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îî‚îÄ‚îÄ server.rs
</code></pre>
<p>Quando quer√≠amos extrair o m√≥dulo <code>network::server</code>, por que precis√°vamos
tamb√©m mudar o arquivo <em>src/network.rs</em> para o arquivo <em>src/network/mod.rs</em> e colocar
o c√≥digo de <code>network::server</code> no diret√≥rio <em>network</em> em
<em>src/network/server.rs</em> em vez de apenas extrair o
m√≥dulo <code>network::server</code> em <em>src/server.rs</em>? O motivo √© que Rust n√£o
ser√° capaz de reconhecer que <code>server</code> deveria ser um subm√≥dulo de <code>network</code>
se o arquivo <em>server.rs</em> estiver no diret√≥rio <em>src</em>. Para esclarecer o comportamento de Rust
aqui, consideremos um exemplo diferente com a seguinte hierarquia de m√≥dulos,
onde todas as defini√ß√µes est√£o em <em>src/lib.rs</em>:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ network
     ‚îî‚îÄ‚îÄ client
</code></pre>
<p>Neste exemplo, temos novamente tr√™s m√≥dulos : <code>client</code>,<code>network</code>, e
<code>network::client</code>. Seguindo os mesmos passos anteriores para extrair
m√≥dulos em arquivos, poder√≠amos criar <em>src/client.rs</em> para o m√≥dulo <code>client</code>.
Para o m√≥dulo <code>network</code>, poder√≠amos criar <em>src/network.rs</em>. Mas n√£o ser√≠amos
capazes de extrair o m√≥dulo <code>network::client</code> para um arquivo <em>src/client.rs</em>
porque ele j√° existe para o m√≥dulo <code>client</code> de n√≠vel superior! Se pud√©ssemos colocar
o c√≥digo para <em>ambos</em> os m√≥dulos <code>client</code> e<code>network::client</code> no arquivo
<em>src/client.rs</em>, Rust n√£o teria nenhuma maneira de saber se o c√≥digo era
para <code>client</code> ou para <code>network::client</code>.</p>
<p>Portanto, para extrair um arquivo para o subm√≥dulo <code>network::client</code> do
m√≥dulo <code>network</code>, precisamos criar um diret√≥rio para o m√≥dulo <code>network</code>
em vez de um arquivo <em>src/network.rs</em>. O c√≥digo que est√° no m√≥dulo <code>network</code>
entra no arquivo <em>src/network/mod.rs</em>, e o subm√≥dulo
<code>network::client</code> pode ter seu pr√≥prio arquivo <em>src/network/client.rs</em>. Agora o
o n√≠vel superior <em>src/client.rs</em> √© inequivocamente o c√≥digo que pertence ao
m√≥dulo <code>client</code>.</p>
<a class="header" href="print.html#regras-dos-m√≥dulos-e-seus-arquivos" id="regras-dos-m√≥dulos-e-seus-arquivos"><h3>Regras dos M√≥dulos e Seus Arquivos</h3></a>
<p>Vamos resumir as regras dos m√≥dulos em rela√ß√£o aos arquivos:</p>
<ul>
<li>Se um m√≥dulo chamado <code>foo</code> n√£o possui subm√≥dulos, voc√™ deve colocar as declara√ß√µes
¬†¬† para <code>foo</code> em um arquivo chamado <em>foo.rs</em>.</li>
<li>Se um m√≥dulo chamado <code>foo</code> possui subm√≥dulos, voc√™ deve colocar as declara√ß√µes
¬†¬† para <code>foo</code> em um arquivo chamado <em>foo/mod.rs</em>.</li>
</ul>
<p>Essas regras se aplicam de forma recursiva, ent√£o, se um m√≥dulo chamado <code>foo</code> tiver um subm√≥dulo chamado
<code>bar</code> e<code>bar</code> n√£o possui subm√≥dulos, voc√™ deve ter os seguintes arquivos
no seu diret√≥rio <em>src</em>:</p>
<pre><code class="language-text">‚îú‚îÄ‚îÄ foo
‚îÇ   ‚îú‚îÄ‚îÄ bar.rs (cont√©m as declara√ß√µes em `foo::bar`)
‚îÇ   ‚îî‚îÄ‚îÄ mod.rs (cont√©m as declara√ß√µes em `foo`, incluindo `mod bar`)
</code></pre>
<p>Os m√≥dulos devem ser declarados no arquivo do m√≥dulo pai usando a palavra-chave <code>mod</code>.</p>
<p>Em seguida, vamos falar sobre a palavra-chave <code>pub</code> e nos livrar dessas warnings!</p>
<a class="header" href="print.html#controlando-a-visibilidade-com-pub" id="controlando-a-visibilidade-com-pub"><h2>Controlando a Visibilidade com <code>pub</code></h2></a>
<p>Resolvemos as mensagens de erro mostradas na Listagem 7-5 movendo o c√≥digo de <code>network</code> e
<code>network::server</code> para  os arquivos <em>src/network/mod.rs</em> e
<em>src/network/server.rs</em>, respectivamente. Nesse ponto, <code>cargo build</code> era
capaz de construir nosso projeto, mas ainda recebemos mensagens de <em>warning</em> sobre as
fun√ß√µes <code>client::connect</code>, <code>network::connect</code>, e <code>network::server::connect</code>
n√£o estarem em uso:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/client.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Ent√£o, por que estamos recebendo esses warnings(avisos)? Afinal, estamos construindo uma biblioteca
com fun√ß√µes que se destinam a ser usadas pelos nossos <em>usu√°rios</em>, n√£o necessariamente por
n√≥s dentro de nosso pr√≥prio projeto, por isso n√£o deveria importar que essas fun√ß√µes <code>connect</code>
n√£o sejam utilizadas. O ponto de cri√°-las √© que elas ser√£o usadas por
outro projeto, n√£o o nosso.</p>
<p>Para entender por que esse programa invoca esses warnings(avisos), vamos tentar usar a
biblioteca <code>connect</code> de outro projeto, chamando-a externamente. Para fazer isso,
vamos criar um crate bin√°rio no mesmo diret√≥rio que o nosso crate de biblioteca
inserindo um arquivo <em>src/main.rs</em> que cont√©m esse c√≥digo:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate communicator;

fn main() {
    communicator::client::connect();
}
</code></pre>
<p>Usamos o comando <code>extern crate</code> para trazer o crate de biblioteca <code>communicator</code>
para o escopo. Nosso pacote agora cont√©m <em>duas</em> crates. Cargo trata <em>src/main.rs</em>
como um arquivo raiz de um crate bin√°rio, que √© separado do crate de biblioteca existente
cujo arquivo raiz √© <em>src/lib.rs</em>. Esse padr√£o √© bastante comum para
projetos execut√°veis: a maioria das funcionalidades est√° em um crate de biblioteca e o crate bin√°rio
usa esse crate de biblioteca. Como resultado, outros programas tamb√©m podem usar o
crate de biblioteca, e √© uma boa separa√ß√£o de responsabilidades.</p>
<p>Do ponto de vista de um crate fora da biblioteca <code>communicator</code>
todos os m√≥dulos que criamos est√£o dentro de um m√≥dulo que tem o mesmo
nome como do crate, <code>communicator</code>. Chamamos o m√≥dulo de n√≠vel superior de um
crate de <em>m√≥dulo raiz</em>.</p>
<p>Observe tamb√©m que, mesmo que estejamos usando um crate externo dentro de um subm√≥dulo do nosso
projeto, o <code>extern crate</code> deve entrar em nosso m√≥dulo raiz (ent√£o em <em>src/main.rs</em>
ou <em>src/lib.rs</em>). Ent√£o, em nossos subm√≥dulos, podemos consultar itens de crates externos
como se os itens fossem m√≥dulos de n√≠vel superior.</p>
<p>Agora, nosso crate bin√°rio apenas chama a fun√ß√£o <code>connect</code> da nossa biblioteca do
m√≥dulo <code>client</code>. No entanto, invocar agora <code>cargo build</code> nos dar√° um erro
ap√≥s os <em>warnings</em>:</p>
<pre><code class="language-text">error[E0603]: module `client` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Ah ha! Este erro nos diz que o m√≥dulo <code>client</code> √© privado, que √© o
cerne das advert√™ncias. √â tamb√©m a primeira vez em que nos encontramos com os conceitos de
<em>p√∫blico</em> e <em>privado</em> no contexto do Rust. O estado padr√£o de todos os c√≥digos em
Rust √© privado: ningu√©m mais tem permiss√£o para usar o c√≥digo. Se voc√™ n√£o usar uma
fun√ß√£o privada dentro do seu programa, como ele √© o √∫nico c√≥digo
permitido a usar essa fun√ß√£o, Rust ir√° avis√°-lo de que a fun√ß√£o
n√£o foi utilizada.</p>
<p>Depois de especificar que uma fun√ß√£o como <code>client::connect</code> √© p√∫blica, n√£o s√≥
ser√° permitida a nossa chamada para essa fun√ß√£o a partir de nosso crate bin√°rio, mas o
warning(aviso) de que a fun√ß√£o n√£o √© utilizada ir√° desaparecer. Marcar uma fun√ß√£o como p√∫blica
permite ao Rust saber que a fun√ß√£o ser√° usada por c√≥digo fora do nosso programa.
Rust considera que agora √© poss√≠vel que a
fun√ß√£o esteja &quot;sendo usada&quot;. Assim, quando uma fun√ß√£o √© marcada como p√∫blica, Rust n√£o
exige que seja usada em nosso programa e deixar√° de avisar que a fun√ß√£o
n√£o √© utilizada.</p>
<a class="header" href="print.html#fazendo-uma-fun√ß√£o-p√∫blica" id="fazendo-uma-fun√ß√£o-p√∫blica"><h3>Fazendo uma Fun√ß√£o P√∫blica</h3></a>
<p>Para dizer ao Rust que torne p√∫blica uma fun√ß√£o, adicionamos a palavra-chave <code>pub</code> ao in√≠cio
da declara√ß√£o. Nos focaremos em corrigir o <em>warning</em> que indica
<code>client::connect</code> n√£o foi utilizado por enquanto, assim como o erro <code>module `client` is private</code> (<code>m√≥dulo `client` √© privado</code>) do nosso crate bin√°rio. Modifique <em>src/lib.rs</em> para tornar
o m√≥dulo <code>client</code> p√∫blico, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

mod network;
</code></pre>
<p>A palavra-chave <code>pub</code> √© colocada logo antes do <code>mod</code>. Vamos tentar fazer o build novamente:</p>
<pre><code class="language-text">error[E0603]: function `connect` is private
 --&gt; src/main.rs:4:5
  |
4 |     communicator::client::connect();
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>Opa! Temos um erro diferente! Sim, mensagens diferentes de erro
s√£o motivo para comemorar. O novo erro mostra que que a fun√ß√£o <code>connect</code> √© privada
(function <code>connect</code> is private), ent√£o vamos editar <em>src/client.rs</em> para torn√°-la p√∫blica tamb√©m:</p>
<p><span class="filename">Arquivo: src/client.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn connect() {
}
#}</code></pre></pre>
<p>Agora execute <code>cargo build</code> novamente:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>O c√≥digo compila, e o warning(aviso) sobre <code>client::connect</code> n√£o estar em uso
se foi!</p>
<p>Os avisos de c√≥digo n√£o utilizados nem sempre indicam que um item no seu c√≥digo precisa
se tornar p√∫blico: se voc√™ <em>n√£o</em> quiser que essas fun√ß√µes fa√ßam parte de sua
API p√∫blica, <em>warnings</em> de c√≥digo n√£o utilizado podem alert√°-lo de que esses c√≥digos n√£o s√£o mais necess√°rios,
e que podem ser exclu√≠dos com seguran√ßa. Eles tamb√©m podem estar alertando voc√™ para um bug, caso voc√™ tivesse apenas
acidentalmente removido todos os lugares dentro da sua biblioteca onde esta fun√ß√£o √©
chamada.</p>
<p>Mas neste caso, n√≥s <em>queremos</em> que as outras duas fun√ß√µes fa√ßam parte da nossa
API p√∫blica do crate, ent√£o vamos marc√°-las como <code>pub</code> tamb√©m para nos livrar dos
<em>warnings</em> remanescentes. Modifique <em>src/network/mod.rs</em> dessa forma:</p>
<p><span class="filename">Arquivo: src/network/mod.rs</span></p>
<pre><code class="language-rust ignore">pub fn connect() {
}

mod server;
</code></pre>
<p>Em seguida, compile o c√≥digo:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/mod.rs:1:1
  |
1 | / pub fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default

warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
</code></pre>
<p>Hmmm, ainda estamos recebendo um <em>warning</em> de fun√ß√£o n√£o utilizada, embora
<code>network::connect</code> esteja marcada como <code>pub</code>. A raz√£o √© que a fun√ß√£o √© p√∫blica
dentro do m√≥dulo, mas o m√≥dulo <code>network</code> na qual a fun√ß√£o reside n√£o √©
p√∫blico. Estamos trabalhando a partir do interior da biblioteca desta vez, enquanto que
com <code>client::connect</code> trabalhamos de fora. Precisamos mudar
<em>src/lib.rs</em> para tornar <code>network</code> p√∫blica tamb√©m, assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;
</code></pre>
<p>Agora, quando compilamos, esse aviso desapareceu:</p>
<pre><code class="language-text">warning: function is never used: `connect`
 --&gt; src/network/server.rs:1:1
  |
1 | / fn connect() {
2 | | }
  | |_^
  |
  = note: #[warn(dead_code)] on by default
</code></pre>
<p>Apenas um warning(aviso) permanece. Tente consertar isso por conta pr√≥pria!</p>
<a class="header" href="print.html#regras-de-privacidade" id="regras-de-privacidade"><h3>Regras de Privacidade</h3></a>
<p>No geral, estas s√£o as regras para a visibilidade do item:</p>
<ol>
<li>Se um item for p√∫blico, ele pode ser acessado atrav√©s de qualquer um dos seus m√≥dulos pais.</li>
<li>Se um item √© privado, ele s√≥ pode ser acessado por seu m√≥dulo pai imediato e
¬†¬†¬†qualquer um dos m√≥dulos filhos do pai.</li>
</ol>
<a class="header" href="print.html#exemplos-de-privacidade" id="exemplos-de-privacidade"><h3>Exemplos de Privacidade</h3></a>
<p>Vejamos mais alguns exemplos de privacidade para obter alguma pr√°tica. Crie um novo
projeto de biblioteca e digite o c√≥digo da Listagem 7-6 no arquivo
<em>src/lib.rs</em> desse novo projeto:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod outermost {
    pub fn middle_function() {}

    fn middle_secret_function() {}

    mod inside {
        pub fn inner_function() {}

        fn secret_function() {}
    }
}

fn try_me() {
    outermost::middle_function();
    outermost::middle_secret_function();
    outermost::inside::inner_function();
    outermost::inside::secret_function();
}
</code></pre>
<p><span class="caption">Lista 7-6: Exemplos de fun√ß√µes p√∫blicas e privadas,
alguns dos quais est√£o incorretos</span></p>
<p>Antes de tentar compilar este c√≥digo, tente um palpite sobre quais linhas na
fun√ß√£o <code>try_me</code> ter√° erros. Em seguida, tente compilar o c√≥digo para ver se
voc√™ estava certo e leia sobre a discuss√£o dos erros!</p>
<a class="header" href="print.html#olhando-para-os-erros" id="olhando-para-os-erros"><h4>Olhando para os Erros</h4></a>
<p>A fun√ß√£o <code>try_me</code> est√° no m√≥dulo raiz do nosso projeto. O m√≥dulo chamado
<code>outermost</code> √© privado, mas a segunda regra de privacidade afirma que a fun√ß√£o <code>try_me</code>
pode acessar o m√≥dulo <code>outermost</code> porque <code>outermost</code> est√° no
m√≥dulo atual (raiz), bem como <code>try_me</code>.</p>
<p>A chamada para <code>outermost::middle_function</code> funcionar√° porque <code>middle_function</code> √©
p√∫blica e <code>try_me</code> est√° acessando <code>middle_function</code> atrav√©s do seu m√≥dulo pai
<code>outermost</code>. Determinamos no par√°grafo anterior que este m√≥dulo √©
acess√≠vel.</p>
<p>A chamada para <code>outermost::middle_secret_function</code> causar√° um erro de compila√ß√£o.
<code>middle_secret_function</code> √© privado, ent√£o a segunda regra se aplica. O m√≥dulo raiz
n√£o √© nem o m√≥dulo atual de <code>middle_secret_function</code> (que seria o <code>outermost</code>),
nem um m√≥dulo filho do m√≥dulo atual de <code>middle_secret_function</code>.</p>
<p>O m√≥dulo denominado <code>inside</code> √© privado e n√£o tem m√≥dulos filhos, portanto, ele s√≥ pode
ser acessado pelo seu m√≥dulo atual <code>outermost</code>. Isso significa que a fun√ß√£o <code>try_me</code>
n√£o tem permiss√£o de chamar <code>outermost::inside::inner_function</code> ou
<code>outermost::inside::secret_function</code>.</p>
<a class="header" href="print.html#reparando-os-erros" id="reparando-os-erros"><h4>Reparando os Erros</h4></a>
<p>Aqui est√£o algumas sugest√µes para alterar o c√≥digo na tentativa de corrigir os
erros. Antes de tentar cada uma, tente adivinhar se ela ir√° consertar os
erros e, em seguida, compile o c√≥digo para ver se voc√™ est√° certo ou n√£o, usando as
regras de privacidade para entender o porqu√™.</p>
<ul>
<li>E se o m√≥dulo <code>inside</code> fosse p√∫blico?</li>
<li>E se <code>outermost</code> fosse p√∫blico e <code>inside</code> fosse privado?</li>
<li>E se, no corpo de <code>inner_function</code>, voc√™ chamasse o
¬†¬†<code>::outermost::middle_secret_function()</code>? (Os dois dois pontos no in√≠cio significam
¬†¬† que queremos consultar os m√≥dulos a partir do m√≥dulo raiz.)</li>
</ul>
<p>Sinta-se livre para projetar mais experimentos que lhe vierem √† mente!</p>
<p>Em seguida, vamos falar sobre trazer itens ao escopo com a palavra-chave <code>use</code>.</p>
<a class="header" href="print.html#referindo-se-a-nomes-em-m√≥dulos-diferentes" id="referindo-se-a-nomes-em-m√≥dulos-diferentes"><h2>Referindo-se a Nomes em M√≥dulos Diferentes</h2></a>
<p>Vimos como chamar fun√ß√µes definidas dentro de um m√≥dulo usando o nome do m√≥dulo
como parte da chamada, como na chamada para a fun√ß√£o <code>nested_modules</code> mostrada
aqui na Listagem 7-7:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

fn main() {
    a::series::of::nested_modules();
}
</code></pre></pre>
<p><span class="caption">Listagem 7-7: Chamando uma fun√ß√£o especificando completamente
o caminho do m√≥dulo que a cerca</span></p>
<p>Como voc√™ pode ver, referir-se ao nome totalmente qualificado pode ficar bastante longo.
Felizmente, Rust tem uma palavra-chave para tornar estas chamadas mais concisas.</p>
<a class="header" href="print.html#trazendo-nomes-no-escopo-com-a-palavra-chave-use" id="trazendo-nomes-no-escopo-com-a-palavra-chave-use"><h3>Trazendo Nomes no Escopo com a Palavra-Chave <code>use</code></h3></a>
<p>A palavra-chave <code>use</code> de Rust encurta as chamadas de fun√ß√£o longas, trazendo os m√≥dulos e
a fun√ß√£o que deseja chamar para o escopo. Aqui est√° um exemplo de como trazer o
m√≥dulo <code>a::series::of</code> para dentro do escopo raiz de um crate bin√°rio:</p>
<p><span class="filename">Arquivo: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of;

fn main() {
    of::nested_modules();
}
</code></pre></pre>
<p>A linha <code>use a::series::of;</code> significa que, em vez de usar todo o caminho
<code>a::series::of</code> sempre que quisermos nos referir ao m√≥dulo <code>of</code>, podemos usar
<code>of</code>.</p>
<p>A palavra-chave <code>use</code> traz apenas o que especificamos no escopo: ela n√£o
leva os filhos dos m√≥dulos ao escopo. √â por isso que ainda temos que usar
<code>of::nested_modules</code> quando queremos chamar a fun√ß√£o <code>nested_modules</code>.</p>
<p>Poder√≠amos ter escolhido trazer a fun√ß√£o para o escopo, em vez de especificar a fun√ß√£o
no <code>use</code> da seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod a {
    pub mod series {
        pub mod of {
            pub fn nested_modules() {}
        }
    }
}

use a::series::of::nested_modules;

fn main() {
    nested_modules();
}
</code></pre></pre>
<p>Isso nos permite excluir todos os m√≥dulos e fazer refer√™ncia √† fun√ß√£o
diretamente.</p>
<p>Como as enums tamb√©m formam uma esp√©cie de <em>namespace</em>, assim como os m√≥dulos, podemos trazer
as variantes de uma enum para o escopo com <code>use</code> tamb√©m. Para qualquer tipo de declara√ß√£o de <code>use</code>
se voc√™ estiver trazendo v√°rios itens de um <em>namespace</em> para o escopo, voc√™ pode list√°-los
usando chaves e v√≠rgulas na √∫ltima posi√ß√£o, assim:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::{Red, Yellow};

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = TrafficLight::Green;
}
</code></pre></pre>
<p>N√≥s ainda estamos especificando o <em>namespace</em> <code>TrafficLight</code> para a variante <code>Green</code>
porque n√£o inclu√≠mos <code>Green</code> na declara√ß√£o <code>use</code>.</p>
<a class="header" href="print.html#trazendo-todos-os-nomes-para-o-escopo-com-um-glob" id="trazendo-todos-os-nomes-para-o-escopo-com-um-glob"><h3>Trazendo Todos os Nomes para o Escopo com um Glob</h3></a>
<p>Para trazer todos os itens de um <em>namespace</em> para o escopo ao mesmo tempo, podemos usar a sintaxe <code>*</code>, que √© chamada de <em>operador glob</em>. Este exemplo traz todas as variantes de uma enum ao escopo sem ter que listar cada uma especificamente:</p>
<pre><pre class="playpen"><code class="language-rust">enum TrafficLight {
    Red,
    Yellow,
    Green,
}

use TrafficLight::*;

fn main() {
    let red = Red;
    let yellow = Yellow;
    let green = Green;
}
</code></pre></pre>
<p>O <code>*</code> trar√° para o escopo todos os itens vis√≠veis no <em>namespace</em> <code>TrafficLight</code>.
Voc√™ deve usar globs com modera√ß√£o: eles s√£o convenientes, mas isso pode
tamb√©m trazer mais itens do que se esperava e causar conflitos de nomea√ß√£o.</p>
<a class="header" href="print.html#usando-super-para-acessar-um-m√≥dulo-pai" id="usando-super-para-acessar-um-m√≥dulo-pai"><h3>Usando <code>super</code> para Acessar um M√≥dulo Pai</h3></a>
<p>Como vimos no in√≠cio deste cap√≠tulo, quando voc√™ cria um crate de biblioteca,
o Cargo faz um m√≥dulo <code>tests</code> para voc√™. Vamos ver isso em mais detalhes agora.
No seu projeto <code>communicator</code>, abra <em>src/lib.rs</em>:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub mod client;

pub mod network;

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre>
<p>O Cap√≠tulo 11 explica mais sobre testes, mas algumas partes deste exemplo devem fazer
sentido agora: temos um m√≥dulo chamado <code>tests</code> que se situa ao lado de nossos outros m√≥dulos
e cont√©m uma fun√ß√£o chamada <code>it_works</code>. Embora existam anota√ß√µes especiais,
o m√≥dulo <code>tests</code> √© apenas outro m√≥dulo! Ent√£o nossa hierarquia de m√≥dulos
se parece com isso:</p>
<pre><code class="language-text">communicator
 ‚îú‚îÄ‚îÄ client
 ‚îú‚îÄ‚îÄ network
 |   ‚îî‚îÄ‚îÄ client
 ‚îî‚îÄ‚îÄ tests
</code></pre>
<p>Os testes servem para exercitar o c√≥digo dentro da nossa biblioteca, ent√£o vamos tentar chamar nossa
fun√ß√£o <code>client :: connect</code> a partir da fun√ß√£o<code>it_works</code>, mesmo que n√£o verefiquemos nenhuma
funcionalidade agora. Isso ainda n√£o funcionar√°:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Execute os testes invocando o comando <code>cargo test</code>:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
error[E0433]: failed to resolve. Use of undeclared type or module `client`
 --&gt; src/lib.rs:9:9
  |
9 |         client::connect();
  |         ^^^^^^ Use of undeclared type or module `client`
</code></pre>
<p>A compila√ß√£o falhou, mas por qu√™? N√£o precisamos colocar <code>communicator ::</code> em
frente da fun√ß√£o como fizemos em <em>src/main.rs</em> porque estamos definitivamente
dentro do crate da biblioteca <code>communicator</code> aqui. A raz√£o √© que os caminhos s√£o
sempre relativos ao m√≥dulo atual, que aqui √© <code>tests</code>. A √∫nica
exce√ß√£o est√° em uma instru√ß√£o <code>use</code>, onde os caminhos s√£o relativos √† crate raiz
por padr√£o. Nosso m√≥dulo <code>tests</code> precisa do m√≥dulo <code>client</code> no seu escopo!</p>
<p>Ent√£o, como podemos retroceder um m√≥dulo na hierarquia para chamar a
fun√ß√£o <code>client::connect</code> no m√≥dulo <code>tests</code>? No m√≥dulo <code>tests</code>, temos a op√ß√£o de
usar <code>::</code> na frente para indicar ao Rust que queremos come√ßar a partir da raiz
e listar todo o caminho, assim:</p>
<pre><code class="language-rust ignore">::client::connect();
</code></pre>
<p>Ou, podemos usar <code>super</code> para voltar um m√≥dulo na hierarquia a partir de nosso
m√≥dulo atual, assim:</p>
<pre><code class="language-rust ignore">super::client::connect();
</code></pre>
<p>Essas duas op√ß√µes n√£o parecem t√£o diferentes neste exemplo, mas se voc√™ estiver
mais fundo em uma hierarquia de m√≥dulos, come√ßar sempre a partir da raiz tornaria
seu c√≥digo muito longo. Nesses casos, usar <code>super</code> para ir do m√≥dulo atual aos
m√≥dulos irm√£os √© um bom atalho. Al√©m disso, se voc√™ especificou o caminho a partir da
raiz em muitos lugares do seu c√≥digo e depois vai reorganizar seus m√≥dulos movendo
uma sub-√°rvore para outro lugar, voc√™ acabaria precisando atualizar o caminho em v√°rios
lugares, o que seria tedioso.</p>
<p>Tamb√©m seria chato ter que digitar <code>super ::</code> em cada teste, mas voc√™
j√° viu a ferramenta para essa solu√ß√£o: <code>use</code>! A funcionalidade <code>super ::</code>
altera o caminho que voc√™ d√° para <code>use</code>, tornando-o relativo ao m√≥dulo pai
em vez do m√≥dulo raiz.</p>
<p>Por estas raz√µes, especialmente no m√≥dulo <code>tests</code>, <code>use super::alguma_coisa</code> √©
geralmente a melhor solu√ß√£o. Ent√£o, agora nosso teste ficou assim:</p>
<p><span class="filename">Arquivo: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    use super::client;

    #[test]
    fn it_works() {
        client::connect();
    }
}
#}</code></pre></pre>
<p>Quando executarmos novamente <code>cargo test</code>, o teste passar√° e a primeira parte do
resultado do teste ser√° o seguinte:</p>
<pre><code class="language-text">$ cargo test
   Compiling communicator v0.1.0 (file:///projects/communicator)
     Running target/debug/communicator-92007ddb5330fa5a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<a class="header" href="print.html#resumo-2" id="resumo-2"><h2>Resumo</h2></a>
<p>Agora voc√™ conhece algumas t√©cnicas novas para organizar o seu c√≥digo! Use estas t√©cnicas
para agrupar as funcionalidades relacionadas, evitar que os arquivos tornem-se muito longos, e
apresentar uma API p√∫blica arrumada para os usu√°rios da sua biblioteca.</p>
<p>Em seguida, analisaremos algumas estruturas de dados de cole√ß√µes na biblioteca padr√£o
que voc√™ pode usar em seu c√≥digo limpo e elegante!</p>
<a class="header" href="print.html#fundamental-collections" id="fundamental-collections"><h1>Fundamental Collections</h1></a>
<a class="header" href="print.html#vetores" id="vetores"><h2>Vetores</h2></a>
<p>O primeiro tipo que iremos ver √© <code>Vec&lt;T&gt;</code>, tamb√©m conhecido como <em>vetor</em>. Vetores
permitem guardar mais de um valor na mesma estrutura de dados que coloca todos
os valores um ao lado do outro na mem√≥ria. Vetores s√≥ podem guardar valores do
mesmo tipo. Eles s√£o √∫teis em situa√ß√µes onde h√° uma lista de itens, como
as linha de texto em um arquivo ou pre√ßos de itens em um carrinho de compras.</p>
<a class="header" href="print.html#criando-um-novo-vetor" id="criando-um-novo-vetor"><h3>Criando um Novo Vetor</h3></a>
<p>Para criar um novo vetor, vazio, chamamos a fun√ß√£o <code>Vec::new</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();
#}</code></pre></pre>
<p>Note que adicionamos uma anota√ß√£o de tipo aqui. Como n√£o estamos inserindo nenhum valor
no vetor, Rust n√£o sabe o tipo de elementos que ir√° guardar.
Isto √© um ponto importante. Vetores s√£o homog√™neos: eles podem guardar muitos
valores, mas todos esses valores devem ser do mesmo tipo. Vetores s√£o implementados
usando gen√©ricos, onde o cap√≠tulo 10 ir√° cobrir como usar em seus tipos. Por
agora, tudo o que precisa saber √© que o tipo <code>Vec</code> fornecido pela biblioteca
padr√£o pode conter qualquer tipo, e quando um <code>Vec</code> espec√≠fico possui um tipo espec√≠fico, o
tipo vai dentro de <code>&lt; &gt;</code>. Falamos para Rust que <code>Vec</code> em <code>v</code> guardar√°
elementos do tipo <code>i32</code>.</p>
<p>No c√≥digo real, a Rust pode inferir o tipo de valor que queremos armazenar uma vez que inserimos
valores, ent√£o voc√™ raramente precisa fazer essa anota√ß√£o de tipo. √â mais comum
criar um <code>Vec</code> que possui valores iniciais, e o Rust fornece a macro <code>vec!</code> por
conveni√™ncia. A macro criar√° um novo <code>Vec</code> que cont√©m os valores que damos
. Isso criar√° um novo <code>Vec &lt;i32&gt;</code> que cont√©m os valores <code>1</code>,<code>2</code> e <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];
#}</code></pre></pre>
<p>Como n√≥s damos valores iniciais  <code>i32</code>, Rust pode inferir que o tipo de <code>v</code>
√© <code>Vec &lt;i32&gt;</code>, e a anota√ß√£o de tipo n√£o √© necess√°ria. Vejamos a seguir como
modificar um vetor.</p>
<a class="header" href="print.html#modificando-um-vetor" id="modificando-um-vetor"><h3>Modificando um Vetor</h3></a>
<p>Para criar um vetor e adicionar elementos a ele, podemos usar o m√©todo <code>push</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
#}</code></pre></pre>
<p>Como qualquer vari√°vel que discutimos no Cap√≠tulo 3, se quisermos poder
alterar seu valor, precisamos faz√™-lo mut√°vel com a palavra-chave <code>mut</code>. Os
n√∫meros que inserimos s√£o todos do tipo <code>i32</code>, e Rust infere isso dos
dados, por isso n√£o precisamos da anota√ß√£o <code>Vec &lt;i32&gt;</code>.</p>
<a class="header" href="print.html#descartar-um-vetor-descarta-seus-elementos" id="descartar-um-vetor-descarta-seus-elementos"><h3>Descartar um Vetor Descarta seus Elementos</h3></a>
<p>Como qualquer outro <code>struct</code>, um vetor ser√° liberado quando ele sair do escopo:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let v = vec![1, 2, 3, 4];

    // use as informa√ß√µes em v

} // &lt;- v sai do escopo e √© liberado aqui
#}</code></pre></pre>
<p>Quando o vetor √© descartado, todos os seus conte√∫dos tamb√©m ser√° descartado, o que significa
esses inteiros que ele cont√©m ser√£o limpos. Isso pode parecer um
ponto direto, mas pode ficar um pouco mais complicado quando come√ßamos a
introduzir refer√™ncias aos elementos do vetor. Vamos abordar isso em seguida!</p>
<a class="header" href="print.html#lendo-elementos-do-vetor" id="lendo-elementos-do-vetor"><h3>Lendo Elementos do Vetor</h3></a>
<p>Agora que voc√™ sabe como criar, atualizar e destruir vetores,
saber ler o seu conte√∫do √© um bom passo seguinte. Existem duas maneiras de fazer refer√™ncia a
valores armazenados em um vetor. Nos exemplos, anotamos os tipos de
valores que s√£o retornados dessas fun√ß√µes para maior clareza.</p>
<p>Este exemplo mostra os dois m√©todos de acesso a um valor em um vetor com
sintaxe de indexa√ß√£o ou o m√©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
#}</code></pre></pre>
<p>H√° algumas coisas a serem observadas aqui. Primeiro, que usamos o valor do √≠ndice de <code>2</code>
para obter o terceiro elemento: os vetores s√£o indexados por n√∫mero, come√ßando em zero.
Em segundo lugar, as duas maneiras diferentes de obter o terceiro elemento s√£o: usando <code>&amp;</code> e
<code>[]</code>, que nos d√° uma refer√™ncia, ou usando o m√©todo <code>get</code> com o √≠ndice
passado como um argumento, o que nos d√° uma <code>Option&lt;&amp;T&gt;</code>.</p>
<p>A raz√£o pela qual Rust tem duas maneiras de fazer refer√™ncia a um elemento √© para que voc√™ possa escolher
como o programa se comporta quando voc√™ tenta usar um valor de √≠ndice para o qual
o vetor n√£o tem um elemento correspondente. Por exemplo, o que um programa deve fazer se tiver
um vetor que cont√©m cinco elementos, ent√£o tenta acessar um elemento no √≠ndice 100
dessa maneira:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
#}</code></pre></pre>
<p>Quando voc√™ executar isso, voc√™ ver√° que com o primeiro m√©todo <code>[]</code>, Rust ir√°
causar um <code>panic!</code> quando um elemento inexistente √© referenciado. Este m√©todo seria
prefer√≠vel se voc√™ quiser que seu programa considere uma tentativa de acessar um
elemento, passado o fim do vetor, para ser um erro fatal que deve finalizar o
programa.</p>
<p>Quando √© passado um √≠ndice que est√° fora da matriz para o m√©todo <code>get</code>, ele
retorna <code>None</code> sem entrar em p√¢nico. Voc√™ usaria isso se acessar um elemento
al√©m do alcance do vetor ocorrer√° ocasionalmente sob
circunst√¢ncias normais. Seu c√≥digo pode ent√£o ter l√≥gica para lidar tanto com
<code>Some(&amp;element)</code> ou <code>None</code>, como discutimos no Cap√≠tulo 6. Por exemplo, o
O √≠ndice pode ser proveniente de uma pessoa que digite um n√∫mero. Se eles acidentalmente
insira um n√∫mero que √© muito grande e seu programa recebe um valor <code>None</code>, voc√™ poderia
dizer ao usu√°rio quantos itens est√£o no atual <code>Vec</code> e dar uma nova
chance de inserir um valor v√°lido. Isso seria mais amig√°vel do que quebrar o
programa por um erro de digita√ß√£o!</p>
<a class="header" href="print.html#refer√™ncias-inv√°lidas" id="refer√™ncias-inv√°lidas"><h4>Refer√™ncias Inv√°lidas</h4></a>
<p>Uma vez que o programa tenha uma refer√™ncia v√°lida, o verificador de empr√©stimo (borrow checker) faz valer
as regras de propriedade e empr√©stimo abrangidas no Cap√≠tulo 4 para garantir que essa refer√™ncia e
quaisquer outras refer√™ncias aos conte√∫dos do vetor permane√ßam v√°lidas. Lembre-se da regra
que diz que n√£o podemos ter refer√™ncias mut√°veis e imut√°veis no mesmo escopo.
Essa regra se aplica neste exemplo, onde mantemos uma refer√™ncia imut√°vel ao
primeiro elemento em um vetor e tentamos adicionar um elemento ao final:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Compilar isso nos dar√° esse erro:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<p>Este c√≥digo pode parecer que deveria funcionar: por que uma refer√™ncia ao primeiro
elemento deveria se preocupar com o que muda sobre o final do vetor? A raz√£o porque
este c√≥digo n√£o √© permitido √© devido √† forma como os vetores funcionam. Adicionando um novo elemento
no final do vetor pode exigir a atribui√ß√£o de nova aloca√ß√£o de mem√≥ria e copiar os
elementos antigos para o novo espa√ßo, na circunst√¢ncia de n√£o haver espa√ßo suficiente
para colocar todos os elementos pr√≥ximos um do outro onde o vetor estava. Nesse
caso, a refer√™ncia ao primeiro elemento apontaria para mem√≥ria n√£o alocada.
As regras de empr√©stimo impedem que os programas acabem nessa situa√ß√£o.</p>
<blockquote>
<p>Nota: para mais informa√ß√µes, veja o Rustonomicon em
<em>https://doc.rust-lang.org/stable/nomicon/vec.html</em>.</p>
</blockquote>
<a class="header" href="print.html#usando-um-enum-para-armazenar-v√°rios-tipos" id="usando-um-enum-para-armazenar-v√°rios-tipos"><h3>Usando um Enum para Armazenar V√°rios Tipos</h3></a>
<p>No in√≠cio deste cap√≠tulo, dissemos que os vetores s√≥ podem armazenar valores
que s√£o todos do mesmo tipo. Isso pode ser inconveniente; definitivamente h√° casos
de uso para a necessidade de armazenar uma lista de coisas de diferentes tipos. Felizmente,
as variantes de um enum s√£o todas definidas sob o mesmo tipo de enum, ent√£o, quando precisamos
armazenar elementos de um tipo diferente em um vetor, podemos definir e usar um
enum!</p>
<p>Por exemplo, digamos que queremos obter valores de uma linha em uma planilha, onde
algumas das colunas da linha cont√™m n√∫meros inteiros, alguns n√∫meros de ponto flutuante,
e algumas strings. Podemos definir um enum cujas variantes guardar√£o os diferentes
tipos de valor, e ent√£o todas as variantes de enum ser√£o consideradas do mesmos
tipo, o do enum. Ent√£o, podemos criar um vetor que contenha esse enum e
ent√£o, em √∫ltima inst√¢ncia, possui diferentes tipos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
#}</code></pre></pre>
<p><span class="caption">Listagem 8-1: Definindo um enum para poder guardar
diferentes tipos de dados em um vetor</span></p>
<p>A raz√£o pela qual Rust precisa saber exatamente quais tipos estar√£o no vetor em
tempo de compila√ß√£o √© para que ele saiba exatamente a quantidade de mem√≥ria no heap que ser√°
necess√°ria para armazenar cada elemento. Uma vantagem secund√°ria para isso √© que podemos ser
expl√≠citos sobre quais tipos s√£o permitidos neste vetor. Se Rust permitisse um vetor
guardar qualquer tipo, haveria uma chance de que um ou mais dos tipos
causar erros com as opera√ß√µes realizadas nos elementos do vetor. Usando
um enum mais um <code>match</code> significa que a Rust garantir√° no tempo de compila√ß√£o que n√≥s
sempre lidaremos com todos os casos poss√≠veis, como discutimos no Cap√≠tulo 6.</p>
<p>Se voc√™ n√£o sabe no momento em que voc√™ est√° escrevendo um programa, o conjunto exaustivo
dos tipos que o programa ir√° precisar no tempo de execu√ß√£o para armazenar em um vetor, a t√©cnica de usar
o enum n√£o funcionar√°. Em vez disso, voc√™ pode usar um objeto trait, que abordaremos no
Cap√≠tulo 17.</p>
<p>Agora que examinamos algumas das maneiras mais comuns de usar vetores, certifique-se
para dar uma olhada na documenta√ß√£o da API para todos os muitos m√©todos √∫teis
definidos no <code>Vec</code> pela biblioteca padr√£o. Por exemplo, al√©m de <code>push</code>
existe um m√©todo <code>pop</code> que ir√° remover e retornar o √∫ltimo elemento. Vamos mover
para o pr√≥ximo tipo de cole√ß√£o: <code>String</code>!</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>N√≥s j√° conversamos sobre as strings no cap√≠tulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings s√£o uma √°rea que os novos Rust√°ceos geralmente tem maior
dificuldade. Isto √© devido a uma combina√ß√£o de tr√™s coisas: a propens√£o de Rust de
certificar-se de expor poss√≠veis erros, as strings s√£o estruturas de dados mais complicadas
que muitos programadores lhes d√£o cr√©dito, e UTF-8. Essas coisas
combina de tal forma que parecem dif√≠cil quando se vem de outras linguagens.</p>
<p>A raz√£o pela qual as strings est√£o no cap√≠tulo de cole√ß√µes √© que as strings s√£o
implementadas como uma cole√ß√£o de bytes mais alguns m√©todos para fornecer informa√ß√µes √∫teis e
funcionalidade quando esses bytes s√£o interpretados como texto. Nesta se√ß√£o, iremos
falar sobre as opera√ß√µes em <code>String</code> que todo tipo de cole√ß√£o tem, como
criar, atualizar e ler. Tamb√©m discutiremos as formas em que <code>String</code>
√© diferente das outras cole√ß√µes, a saber, como a indexa√ß√£o em um <code>String</code> √©
complicada pelas diferen√ßas entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="print.html#o-que-√©-string" id="o-que-√©-string"><h3>O que √© String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente s√≥ tem um tipo de string no n√∫cleo
da pr√≥pria linguagem: <code>str</code>, a fatia de string, que geralmente √© vista na forma emprestada
, <code>&amp;str</code>. N√≥s falamos sobre <em>fatias de strings</em> no Cap√≠tulo 4: estas s√£o uma
refer√™ncia a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, s√£o armazenados na sa√≠da bin√°ria do programa e, portanto, s√£o
fatias de string.</p>
<p>O tipo chamado <code>String</code> √© fornecido na biblioteca padr√£o do Rust, em vez de
codificado no n√∫leo da linguagem, e √© um extens√≠vel, mut√°vel, <code>owned</code>, tipo string
codificado UTF-8. Quando Rust√°ceos falam sobre ‚Äústrings‚Äù em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta se√ß√£o, √© em grande parte sobre <code>String</code>, mas ambos esses tipos s√£o usados em grande parte
na biblioteca padr√£o da Rust. Tanto o <code>String</code> como as fatias de string s√£o codificadas em UTF-8.</p>
<p>A biblioteca padr√£o do Rust tamb√©m inclui uma s√©rie de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais op√ß√µes para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codifica√ß√µes ou ser representados na mem√≥ria de
maneira diferente, por exemplo. N√≥s n√£o estaremos falando sobre esse outro tipo de string
neste cap√≠tulo; veja a documenta√ß√£o da API para obter mais informa√ß√µes sobre como us√°-los
e quando cada um √© apropriado.</p>
<a class="header" href="print.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas opera√ß√µes dispon√≠veis com <code>Vec</code> tamb√©m est√£o dispon√≠veis em <code>String</code>,
come√ßando com a fun√ß√£o <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostar√≠amos de j√° colocar na string.
Para isso, usamos o m√©todo <code>to_string</code>, que est√° dispon√≠vel em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o m√©todo tamb√©m funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>Tamb√©m podemos usar a fun√ß√£o <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings s√£o usadas para tantas coisas, existem v√°rias APIs gen√©ricas diferentes
que podem ser usadas para strings, ent√£o h√° muitas op√ß√µes. Algumas delas
podem parecer redundantes, mas todas t√™m seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, ent√£o a que voc√™ escolher √© uma
quest√£o de estilo.</p>
<p>Lembre-se de que as string s√£o codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;;
let hello = &quot;Dobr√Ω den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;;
let hello = &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;;
let hello = &quot;„Åì„Çì„Å´„Å°„ÅØ&quot;;
let hello = &quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;;
let hello = &quot;‰Ω†Â•Ω&quot;;
let hello = &quot;Ol√°&quot;;
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="print.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conte√∫do pode mudar assim como o conte√∫do
de um <code>Vec</code>, empurrando mais dados para ela. Al√©m disso, <code>String</code> tem
opera√ß√µes de concatena√ß√£o implementadas com o operador <code>+</code> por conveni√™ncia.</p>
<a class="header" href="print.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o m√©todo <code>push_str</code> para adicionar uma  seq√º√™ncia de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conter√° ‚Äúfoobar‚Äú ap√≥s essas duas linhas. O m√©todo <code>push_str</code> leva um
fatia de string porque n√£o necessariamente queremos ownership do
par√¢metro. Por exemplo, seria lament√°vel se n√£o pud√©ssemos usar <code>s2</code>
depois de atualizar o seu conte√∫do a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O m√©todo <code>push</code> √© definido para ter um √∫nico caractere como par√¢metro e adicionar
√† <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>Ap√≥s isso, <code>s</code> ir√° conter ‚Äúlol‚Äù.</p>
<a class="header" href="print.html#concatena√ß√£o-com-o-operador--ou-a-macro-format" id="concatena√ß√£o-com-o-operador--ou-a-macro-format"><h4>Concatena√ß√£o com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira √© usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e n√£o pode ser mais usado
#}</code></pre></pre>
<p>Ap√≥s este c√≥digo, a String <code>s3</code> conter√° <code>Hello, world!</code>. O motivo que
<code>s1</code> n√£o √© mais v√°lido ap√≥s a adi√ß√£o e o motivo que usamos uma
refer√™ncia a <code>s2</code> tem a ver com a assinatura do m√©todo que √© chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o m√©todo <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta n√£o √© a assinatura exata que est√° na biblioteca padr√£o; l√° o <code>add</code> √©
definido usando gen√©ricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substitu√≠dos pelos gen√©ricos, o que acontece quando n√≥s
chamamos esse m√©todo com valores <code>String</code>. Vamos discutir gen√©ricos no
Cap√≠tulo 10. Esta assinatura nos d√° as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>refer√™ncia</em> da
segunda string para a primeira string. Isso √© devido ao par√¢metro <code>s</code> na
fun√ß√£o <code>add</code>: s√≥ podemos adicionar um <code>&amp;str</code> √† <code>String</code>, n√£o podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> √© <code>&amp;String</code>, n√£o
<code>&amp;str</code>, conforme especificado no segundo par√¢metro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a fun√ß√£o<code>add</code> √© chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que voc√™ poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na fun√ß√£o <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no Cap√≠tulo 15. Como o <code>add</code> n√£o se apropria
o par√¢metro <code>s2</code> ainda ser√° uma <code>String</code> v√°lida ap√≥s essa opera√ß√£o.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>n√£o</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
ser√° transferido para a chamada <code>add</code> e n√£o ser√° mais v√°lido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que ir√° copiar ambas as strings e criar uma nova,
esta declara√ß√£o realmente adere a <code>s1</code>, acrescenta uma c√≥pia do conte√∫do
de <code>s2</code>, ent√£o retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas c√≥pias, mas n√£o √©: a implementa√ß√£o √© mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar v√°rias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> ser√° ‚Äútic-tac-toe‚Äù neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica dif√≠cil ver o que est√° acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este c√≥digo tamb√©m definir√° <code>s</code> para ‚Äútic-tac-toe‚Äù. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a sa√≠da para a tela, ela
retorna uma <code>String</code> com o conte√∫do. Esta vers√£o √© muito mais f√°cil de ler, e
tamb√©m n√£o incide ownership em nenhum dos seus par√¢metros.</p>
<a class="header" href="print.html#indexa√ß√£o-em-strings" id="indexa√ß√£o-em-strings"><h3>Indexa√ß√£o em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por √≠ndice √© uma opera√ß√£o v√°lida e comum. Em Rust, no entanto, se
n√≥s tentamos acessar partes de uma <code>String</code> usando sintaxe de indexa√ß√£o, vamos ter um erro.
Ou seja, este c√≥digo:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultar√° neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a hist√≥ria: as strings em Rust n√£o suportam a indexa√ß√£o. Assim
a pr√≥xima pergunta √©, por que n√£o? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na mem√≥ria.</p>
<a class="header" href="print.html#representa√ß√£o-interna" id="representa√ß√£o-interna"><h4>Representa√ß√£o Interna</h4></a>
<p>Uma <code>String</code> √© um inv√≥lucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> ter√° valor de quatro, o que significa que o<code>Vec</code> armazena a string
‚ÄùHola‚Äù tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
√© 24. Este √© o n√∫mero de bytes que √© necess√°rio para codificar ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äú em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um √≠ndice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode v√°lido.</p>
<p>Para demonstrar, considere este c√≥digo inv√°lido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>–ó</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>–ó</code> √© <code>208</code>, e o segundo √© <code>151</code>, ent√£o
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> n√£o √© um caractere v√°lido em
si. Retornar <code>208</code> provavelmente n√£o √© o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse √© o √∫nico dado que Rust tem no byte
de √≠ndice 0. O retorno do valor do byte provavelmente n√£o √© o que as pessoas querem, mesmo com
caracteres contendo acentua√ß√£o: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, n√£o<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem n√£o ser descobertos
imediatamente, Rust escolhe n√£o compilar este c√≥digo e previne
mal-entendidos anteriormente.</p>
<a class="header" href="print.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente tr√™s maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais pr√≥xima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù escrita na escrita Devanagari, √©
em √∫ltima inst√¢ncia, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso √© 18 bytes, e √© como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que s√£o o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto n√£o s√£o letras,
Eles s√£o diacr√≠ticos que n√£o fazem sentido por conta pr√≥pria. Finalmente, se olharmos para
eles como clusters de grafemas, ter√≠amos o que uma pessoa chamaria as quatro letras
que comp√µem esta palavra:</p>
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpreta√ß√£o que necessite, n√£o importa
em que idioma humano os dados est√£o.</p>
<p>Uma raz√£o final do Rust n√£o permitir que voc√™ indexe uma <code>String</code> para obter um
caracter √© que as opera√ß√µes de indexa√ß√£o sempre esperam um tempo constante
(O(1)). N√£o √© poss√≠vel garantir que o desempenho com uma <code>String</code>,
entretanto, j√° que o Rust teria que percorrer todo o conte√∫do desde o in√≠cio
at√© o √≠ndice para determinar quantos caracteres v√°lidos havia.</p>
<a class="header" href="print.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque n√£o est√° claro qual seria o tipo de retorno da indexa√ß√£o de string, e
muitas vezes √© uma m√° id√©ia indexar uma string, Rust dissuade-o de faz√™-lo
pedindo que voc√™ seja mais espec√≠fico se voc√™ realmente precisar disso. Do jeito que voc√™ pode ser
mais espec√≠fico que a indexa√ß√£o usando <code>[]</code> com um √∫nico n√∫mero √© usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes espec√≠ficos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> ser√° um <code>&amp;str</code> que cont√©m os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> ser√° ‚Äú–ó–¥‚Äù.</p>
<p>O que aconteceria se fiz√©ssemos <code>&amp;hello[0..1]</code>? A resposta: entrar√° em p√¢nico
em tempo de execu√ß√£o, da mesma maneira que acessar um √≠ndice inv√°lido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Voc√™ deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="print.html#m√©todos-para-interagir-sobre-strings" id="m√©todos-para-interagir-sobre-strings"><h3>M√©todos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar opera√ß√µes em valores escalares Unicode individuais, a melhor
maneira de fazer isso √© usar o m√©todo <code>chars</code>. Chamando <code>chars</code> em ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù
√© separado e retorna seis valores do tipo <code>char</code>, e voc√™ pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este c√≥digo ir√° imprimir:</p>
<pre><code class="language-text">‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
</code></pre>
<p>O m√©todo <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
dom√≠nio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este c√≥digo imprimir√° os 18 bytes que comp√µem esse <code>String</code>, come√ßando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode v√°lidos podem ser constitu√≠dos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings √© complexo, ent√£o esta funcionalidade n√£o √©
fornecida pela biblioteca padr√£o. Existem crates dispon√≠veis em crates.io se
Esta √© a funcionalidade que voc√™ precisa.</p>
<a class="header" href="print.html#as-strings-n√£o-s√£o-t√£o-simples" id="as-strings-n√£o-s√£o-t√£o-simples"><h3>As Strings N√£o s√£o t√£o Simples</h3></a>
<p>Para resumir, as strings s√£o complicadas. Diferentes linguagens de programa√ß√£o fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padr√£o
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff exp√µe mais da complexidade
de strings do que outras linguagens de programa√ß√£o, mas isso ir√° impedi-lo de
ter que lidar com erros envolvendo caracteres n√£o-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>
<a class="header" href="print.html#hash-maps" id="hash-maps"><h2>Hash Maps</h2></a>
<p>A √∫ltima das nossas cole√ß√µes comuns √© o <em>hash map</em>. O tipo <code>HashMap &lt;K, V&gt;</code>
armazena um mapeamento de chaves do tipo <code>K</code> para valores do tipo<code>V</code>. Ele faz isso atrav√©s de um
<em>hashing function</em>, que determina como ele coloca essas chaves e valores em
mem√≥ria. Muitas linguagens de programa√ß√£o diferentes suportam este tipo de
estrutura de dados, mas muitas vezes com um nome diferente: hash, map, object, hash table ou
associative array, apenas para citar alguns.</p>
<p>Os Hash maps s√£o √∫teis para quando voc√™ deseja poder procurar dados sem uso de
√≠ndice, como voc√™ pode com vetores, mas usando uma chave que pode ser de qualquer tipo. Por
exemplo, em um jogo, voc√™ poderia acompanhar a pontua√ß√£o de cada equipe em um hash map
onde cada chave √© o nome de uma equipe e os valores s√£o cada pontua√ß√£o da equipe. Dado um
nome da equipe, voc√™ pode recuperar sua pontua√ß√£o.</p>
<p>Examinaremos a API b√°sica dos hash map neste cap√≠tulo, mas h√° muitos
mais coisas escondidas nas fun√ß√µes definidas no <code>HashMap</code> pela biblioteca
padr√£o. Como sempre, verifique a documenta√ß√£o da biblioteca padr√£o para mais
informa√ß√£o.</p>
<a class="header" href="print.html#criando-um-novo-hash-map" id="criando-um-novo-hash-map"><h3>Criando um novo Hash Map</h3></a>
<p>Podemos criar um <code>HashMap</code> vazio com <code>new</code>, e adicionar elementos com <code>insert</code>.
Aqui, estamos acompanhando as pontua√ß√µes de duas equipes cujos nomes s√£o Blue e
Yellow. A equipe blue come√ßar√° com 10 pontos e a equipe yellow come√ßa com
50:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
#}</code></pre></pre>
<p>Observe que precisamos primeiro <code>use</code> o <code>HashMap</code> da parte de cole√ß√µes da
biblioteca padr√£o. De nossas tr√™s cole√ß√µes comuns, esta √© a de menor
frequencia de uso, por isso n√£o est√° inclusa nos recursos importados automaticamente no
prel√∫dio. Os Hash maps tamb√©m t√™m menos suporte da biblioteca padr√£o; n√£o h√°
macro embutida para constru√≠-los, por exemplo.</p>
<p>Assim como os vetores, os mapas hash armazenam seus dados no heap. Este <code>HashMap</code> tem
chaves do tipo <code>String</code> e valores do tipo <code>i32</code>. Como vetores, os hash maps s√£o
homog√™neos: todas as chaves devem ter o mesmo tipo e todos os valores
devem ter o mesmo tipo.</p>
<p>Outra maneira de construir um hash map √© usando o m√©todo <code>collect</code> em um
vetor de tuplas, onde cada tupla consiste de uma chave e seu valor. O
m√©todo <code>collect</code> re√∫ne dados em v√°rios tipos de cole√ß√£o, incluindo
<code>HashMap</code>. Por exemplo, se tiv√©ssemos os nomes das equipes e as pontua√ß√µes iniciais em dois
vetores separados, podemos usar o m√©todo <code>zip</code> para criar um vetor de tuplas
onde ‚ÄúBlue‚Äù √© emparelhado com 10, e assim por diante. Ent√£o podemos usar o m√©todo <code>collect</code>
para transformar esse vetor de tuplas em um <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
#}</code></pre></pre>
<p>A anota√ß√£o de tipo <code>HashMap &lt;_, _&gt;</code> √© necess√°ria aqui porque √© poss√≠vel
<code>collect</code> em muitas estruturas de dados diferentes, e Rust n√£o sabe qual voc√™
deseja, a menos que voc√™ especifique. Para os par√¢metros de tipo, para os tipos de chave e valor,
no entanto, usamos underscores e Rust pode inferir os tipos que o hash map
cont√©m com base nos tipos de dados no vetor.</p>
<a class="header" href="print.html#hash-maps-e-ownership" id="hash-maps-e-ownership"><h3>Hash Maps e Ownership</h3></a>
<p>Para os tipos que implementam a <code>Copy</code> trait, como <code>i32</code>, os valores s√£o copiados
no hash map. Para valores owned como <code>String</code>, os valores ser√£o movidos e
o hash map ser√° o owner desses valores:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name e field_value s√£o inv√°lidos neste ponto
#}</code></pre></pre>
<p>N√£o poder√≠amos usar as liga√ß√µes <code>field_name</code> e<code>field_value</code> depois
que foram transferidos para o hash map com a chamada para <code>insert</code>.</p>
<p>Se inserimos refer√™ncias a valores no hash map, os pr√≥prios valores
n√£o ser√£o movido para o hash map. Os valores que as refer√™ncias apontam devem ser
v√°lido pelo menos enquanto o hash map seja v√°lido, no entanto. Falaremos mais
sobre esses problemas na se√ß√£o Lifetimes do Cap√≠tulo 10.</p>
<a class="header" href="print.html#acessando-valores-em-um-hash-map" id="acessando-valores-em-um-hash-map"><h3>Acessando Valores em um Hash Map</h3></a>
<p>Podemos obter um valor do hash map fornecendo a chave para o m√©todo <code>get</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
#}</code></pre></pre>
<p>Aqui, <code>score</code> ter√° o valor que est√° associado √† equipe Blue, e o
resultado ser√° <code>Some(&amp;10)</code>. O resultado est√° envolvido em <code>Some</code> porque <code>get</code>
retorna <code>Option&lt;&amp;V&gt;</code>; se n√£o houver valor para essa chave no hash map, <code>get</code>
retornar√° <code>None</code>. O programa precisar√° lidar com <code>Option</code> em uma das
formas que abordamos no Cap√≠tulo 6.</p>
<p>Podemos iterar sobre cada par chave/valor em um hash map de uma maneira similar √† que
fazemos com vetores, usando um loop <code>for</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<p>Isso imprimir√° cada par, em uma ordem arbitr√°ria:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<a class="header" href="print.html#atualizando-um-hash-map" id="atualizando-um-hash-map"><h3>Atualizando um Hash Map</h3></a>
<p>Embora o n√∫mero de chaves e valores sejam crescentes, cada chave individual pode apenas
tem um valor associado a ele por vez. Quando queremos mudar os dados em
um hash map, temos que decidir como lidar com o caso quando uma chave j√° possui uma
valor atribu√≠do. Poder√≠amos optar por substituir o valor antigo pelo novo valor,
desconsiderando completamente o valor antigo. Poder√≠amos escolher manter o valor antigo
e ignorar o novo valor, e apenas adicione o novo valor se a chave ainda <em>n√£o</em>
tem um valor. Ou podemos combinar o valor antigo ao valor novo.
Vejamos como fazer cada um desses!</p>
<a class="header" href="print.html#sobrescrevendo-um-valor" id="sobrescrevendo-um-valor"><h4>Sobrescrevendo um Valor</h4></a>
<p>Se inserimos uma chave e um valor em um hash map, ent√£o  se inserir essa mesma chave com
um valor diferente, o valor associado a essa chave ser√° substitu√≠do. Eembora
o seguinte c√≥digo chame <code>insert</code> duas vezes, o hash map s√≥ conter√°
um par de chave/valor porque inserimos o valor da chave da equipe Blue
ambas as vezes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>Isso imprimir√° <code>{&quot;Blue&quot;: 25}</code>. O valor original de 10 foi substitu√≠do.</p>
<a class="header" href="print.html#insira-apenas-se-a-chave-n√£o-possui-valor" id="insira-apenas-se-a-chave-n√£o-possui-valor"><h4>Insira Apenas se a Chave N√£o Possui Valor</h4></a>
<p>√â comum querer verificar se uma determinada chave tem um valor e, se
n√£o tiver, inserir um valor para ela. Os Hash maps possuem uma API especial para isso, chamada
<code>entry</code>, que leva a chave que queremos verificar como um argumento. O valor de retorno
da fun√ß√£o <code>entry</code> √© um enum, <code>Entry</code>, que representa um valor que pode
ou n√£o existir. Digamos que queremos verificar se a chave para o time Yellow
tem um valor associado a ela. Se n√£o tiver, queremos inserir o valor
50, e o mesmo para a equipe Blue. Com a API de entrada, o c√≥digo ir√° parecer
com:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<p>O m√©todo <code>or_insert</code> em <code>Entry</code> retorna o valor para o <code>Entry</code> correspondente
se a chave existir, e se n√£o, insere seu argumento como o novo valor para
esta chave e retorna a <code>Entry</code> modificada. Isso √© muito mais limpo do que escrever
a l√≥gica por n√≥s mesmos e, al√©m disso, trabalha-se de forma mais limpa com o borrow checker.</p>
<p>Este c√≥digo imprimir√° <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. A primeira chamada para <code>entry</code>
ir√° inserir a chave para a equipe Yellow com o valor 50, uma vez que o time Yellow
j√° n√£o possua um valor. A segunda chamada para <code>entry</code> n√£o vai mudar
o hash map pois o time Blue j√° possui o valor 10.</p>
<a class="header" href="print.html#atualize-um-valor-com-base-no-valor-antigo" id="atualize-um-valor-com-base-no-valor-antigo"><h4>Atualize um Valor com Base no Valor Antigo</h4></a>
<p>Outro caso de uso comum para hash maps √© procurar o valor de uma chave e, em seguida, atualiza-la
, com base no valor antigo. Por exemplo, se quisermos contar quantas vezes
cada palavra apareceu em algum texto, podemos usar um hash map com as palavras como chaves
e incrementar o valor para acompanhar quantas vezes vimos essa palavra.
Se esta √© a primeira vez que vimos uma palavra, primeiro inseriremos o valor <code>0</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>Isso imprimir√° <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. O m√©todo <code>or_insert</code>
na verdade retorna uma refer√™ncia mut√°vel (<code>&amp; mutV</code>) para o valor desta
chave. Aqui n√≥s armazenamos essa refer√™ncia mut√°vel na vari√°vel <code>count</code>, ent√£o,
para poder atribuir esse valor, devemos primeiro desreferenciar <code>count</code> usando o asterisco
(<code>*</code>). A refer√™ncia mut√°vel fica fora do escopo no final do loop <code>for</code>, ent√£o
todas essas mudan√ßas s√£o seguras e permitidas pelas regras de borrow.</p>
<a class="header" href="print.html#fun√ß√µes-hashing" id="fun√ß√µes-hashing"><h3>Fun√ß√µes Hashing</h3></a>
<p>Por padr√£o, <code>HashMap</code> usa uma fun√ß√£o de hashing criptogr√°ficamente segura que pode
fornecer resist√™ncia aos ataques de Nega√ß√£o de Servi√ßo (DoS). Este n√£o √© o algoritmo
mais r√°pido de hashing por a√≠, mas a compensa√ß√£o por uma melhor seguran√ßa que vem
com a queda na performance vale a pena. Se voc√™ testar a velocidade do seu c√≥digo e encontrar
que a fun√ß√£o de hash padr√£o √© muito lenta para seus prop√≥sitos, voc√™ pode mudar para
outra fun√ß√£o especificando um <em>hasher</em> diferente. Um hasher √© um tipo que
implementa a trait <code>BuildHasher</code>. Vamos falar sobre traits e como
implement√°-los no Cap√≠tulo 10. Voc√™ n√£o precisa necessariamente implementar o seu pr√≥prio
hasher do zero; crates.io tem bibliotecas de hashers de uso comum que
outras pessoas compartilharam l√°.</p>
<a class="header" href="print.html#sum√°rio" id="sum√°rio"><h2>Sum√°rio</h2></a>
<p>Vetores, strings e hash maps ir√£o lev√°-lo longe em programas onde voc√™ precisa
armazenar, acessar e modificar dados. Aqui est√£o alguns exerc√≠cios que voc√™ deve estar
capacitado para resolver:</p>
<ul>
<li>Dada uma lista de inteiros, use um vetor e retorne a m√©dia, a mediana
¬†¬† (quando classificado, o valor na posi√ß√£o do meio) e modo (o valor que
¬†¬† ocorre com mais frequ√™ncia; um hash map ser√° √∫til aqui) da lista.</li>
<li>Converta strings para Pig Latin, onde a primeira consoante de cada palavra √© movida
¬†¬† para o final da palavra adicionado um &quot;ay&quot; , ent√£o ‚Äúfirst‚Äù se torna ‚Äúirst-fay‚Äù.
¬†¬† Palavras que come√ßam com uma vogal recebem ‚Äúhay‚Äù adicionado ao final (‚Äúapple‚Äù
¬†¬† torna-se ‚Äúapple-hay‚Äù). Lembre-se sobre a codifica√ß√£o UTF-8!</li>
<li>Usando um hash map e vetores, crie uma interface de texto para permitir que um usu√°rio adicione
¬†¬† nomes de funcion√°rios para um departamento da empresa. Por exemplo, ‚ÄúAdd Sally to
Engineering‚Äù ou ‚ÄúAdd Amir to Sales‚Äù. Em seguida, deixe o usu√°rio recuperar uma lista de todas
¬†¬† as pessoas de um departamento ou todas as pessoas na empresa por departamento, ordenadas
¬†¬† alfabeticamente.</li>
</ul>
<p>A documenta√ß√£o da API da biblioteca padr√£o descreve m√©todos que esses tipos possuem
que ser√° √∫til para esses exerc√≠cios!</p>
<p>Estamos entrando em programas mais complexos onde as opera√ß√µes podem falhar, o que significa
que √© um momento perfeito para passar pelo tratamento de erros em seguida!</p>
<a class="header" href="print.html#error-handling" id="error-handling"><h1>Error Handling</h1></a>
<a class="header" href="print.html#unrecoverable-errors-with-panic" id="unrecoverable-errors-with-panic"><h1>Unrecoverable Errors with panic!</h1></a>
<a class="header" href="print.html#recoverable-errors-with-result" id="recoverable-errors-with-result"><h1>Recoverable Errors with Result</h1></a>
<a class="header" href="print.html#to-panic-or-not-to-panic" id="to-panic-or-not-to-panic"><h1>To panic! or Not To panic!</h1></a>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<a class="header" href="print.html#syntax" id="syntax"><h1>Syntax</h1></a>
<a class="header" href="print.html#traits" id="traits"><h1>Traits</h1></a>
<a class="header" href="print.html#lifetime-syntax" id="lifetime-syntax"><h1>Lifetime syntax</h1></a>
<a class="header" href="print.html#testing" id="testing"><h1>Testing</h1></a>
<a class="header" href="print.html#writing-tests" id="writing-tests"><h1>Writing tests</h1></a>
<a class="header" href="print.html#running-tests" id="running-tests"><h1>Running tests</h1></a>
<a class="header" href="print.html#test-organization" id="test-organization"><h1>Test Organization</h1></a>
<a class="header" href="print.html#an-io-project" id="an-io-project"><h1>An I/O Project</h1></a>
<a class="header" href="print.html#accepting-command-line-arguments" id="accepting-command-line-arguments"><h1>Accepting Command Line Arguments</h1></a>
<a class="header" href="print.html#reading-a-file" id="reading-a-file"><h1>Reading a File</h1></a>
<a class="header" href="print.html#improving-error-handling-and-modularity" id="improving-error-handling-and-modularity"><h1>Improving Error Handling and Modularity</h1></a>
<a class="header" href="print.html#testing-the-librarys-functionality" id="testing-the-librarys-functionality"><h1>Testing the Library's Functionality</h1></a>
<a class="header" href="print.html#working-with-environment-variables" id="working-with-environment-variables"><h1>Working with Environment Variables</h1></a>
<a class="header" href="print.html#writing-to-stderr-instead-of-stdout" id="writing-to-stderr-instead-of-stdout"><h1>Writing to stderr instead of stdout</h1></a>
<a class="header" href="print.html#functional-language-features-in-rust" id="functional-language-features-in-rust"><h1>Functional Language Features in Rust</h1></a>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<a class="header" href="print.html#iterators" id="iterators"><h1>Iterators</h1></a>
<a class="header" href="print.html#improving-our-io-project" id="improving-our-io-project"><h1>Improving our I/O Project</h1></a>
<a class="header" href="print.html#performance" id="performance"><h1>Performance</h1></a>
<a class="header" href="print.html#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio"><h1>More about Cargo and Crates.io</h1></a>
<a class="header" href="print.html#release-profiles" id="release-profiles"><h1>Release Profiles</h1></a>
<a class="header" href="print.html#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio"><h1>Publishing a Crate to Crates.io</h1></a>
<a class="header" href="print.html#cargo-workspaces" id="cargo-workspaces"><h1>Cargo Workspaces</h1></a>
<a class="header" href="print.html#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install"><h1>Installing Binaries from Crates.io with cargo install</h1></a>
<a class="header" href="print.html#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands"><h1>Extending Cargo with Custom Commands</h1></a>
<a class="header" href="print.html#smart-pointers" id="smart-pointers"><h1>Smart Pointers</h1></a>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#is-rust-oop" id="is-rust-oop"><h1>Is Rust OOP?</h1></a>
<a class="header" href="print.html#patterns" id="patterns"><h1>Patterns</h1></a>
<a class="header" href="print.html#more-lifetimes" id="more-lifetimes"><h1>More Lifetimes</h1></a>
<a class="header" href="print.html#advanced-type-system-features" id="advanced-type-system-features"><h1>Advanced Type System Features</h1></a>
<a class="header" href="print.html#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="print.html#keywords" id="keywords"><h1>Keywords</h1></a>
<a class="header" href="print.html#operators" id="operators"><h1>Operators</h1></a>
<a class="header" href="print.html#derivable-traits" id="derivable-traits"><h1>Derivable Traits</h1></a>
<a class="header" href="print.html#nightly-rust" id="nightly-rust"><h1>Nightly Rust</h1></a>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
