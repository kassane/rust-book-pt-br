<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Defining an Enum - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html" class="active"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch06-01-defining-an-enum.html#definindo-uma-enum" id="definindo-uma-enum"><h2>Definindo uma Enum</h2></a>
<p>Vamos ver um caso em que enums podem ser mais apropriadas do que structs e
descobrir como elas podem ser √∫teis. Digamos que estamos trabalhando com
endere√ßos IP. Atualmente, existem duas vers√µes do protocolo IP que s√£o mais
utilizadas: a quatro e a seis. Estas s√£o as √∫nicas possibilidades para um
endere√ßo IP com que o nosso programa vai trabalhar: n√≥s podemos <em>enumerar</em>
todos os poss√≠veis valores, √© da√≠ que vem o nome enumera√ß√£o.</p>
<p>Um endere√ßo IP qualquer pode ser ou da vers√£o quatro ou da vers√£o seis, mas
nunca das duas ao mesmo tempo. Esta propriedade dos endere√ßos IP faz com que a
enum seja bem apropriada para este caso, pois enums s√≥ podem assumir o valor de
uma de suas variantes. Os endere√ßos de ambas as vers√µes, seja quatro ou seis,
ainda s√£o, fundamentalmente, endere√ßos IP, e deveriam ser tratados pelo mesmo
tipo no c√≥digo em situa√ß√µes que se aplicam a qualquer vers√£o de endere√ßo IP.</p>
<p>Podemos expressar esse conceito em c√≥digo definindo uma enum <code>VersaoIp</code> e
listando os poss√≠veis tipos de que um endere√ßo IP pode ser: <code>V4</code> e <code>V6</code>. Estas
s√£o as chamadas <em>variantes</em> da enum:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}
#}</code></pre></pre>
<p><code>VersaoIp</code> √© um tipo de dados que agora n√≥s podemos usar em qualquer lugar no
nosso c√≥digo.</p>
<a class="header" href="ch06-01-defining-an-enum.html#valores-de-uma-enum" id="valores-de-uma-enum"><h3>Valores de uma Enum</h3></a>
<p>Podemos criar inst√¢ncias de cada uma das duas variantes de <code>VersaoIp</code>, da
seguinte forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
let quatro = VersaoIp::V4;
let seis = VersaoIp::V6;
#}</code></pre></pre>
<p>Repare que as variantes pertencem ao <em>namespace</em> da enum, e se usa <code>::</code> para
separar os dois. Isso √© √∫til porque agora ambos os valores <code>VersaoIp::V4</code> e
<code>VersaoIp::V6</code> s√£o do mesmo tipo: <code>VersaoIp</code>. Agora n√≥s podemos, por exemplo,
definir uma fun√ß√£o que usa qualquer <code>VersaoIp</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
fn rotear(versao_ip: VersaoIp) { }
#}</code></pre></pre>
<p>E podemos ainda chamar esta fun√ß√£o passando qualquer uma das variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum VersaoIp {
#     V4,
#     V6,
# }
#
# fn rotear(versao_ip: VersaoIp) { }
#
rotear(VersaoIp::V4);
rotear(VersaoIp::V6);
#}</code></pre></pre>
<p>O uso de enums tem ainda mais vantagens. Pensando mais a fundo sobre o nosso
tipo de endere√ßo IP, ainda n√£o temos uma forma de representar o <em>endere√ßo</em> em
si, apenas sabemos qual a <em>vers√£o</em> dele. Tendo em vista o que voc√™ acabou de
aprender sobre structs no Cap√≠tulo 5, voc√™ poderia abordar esse problema assim
como visto na Listagem 6-1:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum VersaoIp {
    V4,
    V6,
}

struct EnderecoIp {
    versao: VersaoIp,
    endereco: String,
}

let local = EnderecoIp {
    versao: VersaoIp::V4,
    endereco: String::from(&quot;127.0.0.1&quot;),
};

let loopback = EnderecoIp {
    versao: VersaoIp::V6,
    endereco: String::from(&quot;::1&quot;),
};
#}</code></pre></pre>
<p><span class="caption">Listagem 6-1: Representa√ß√£o do endere√ßo e da variante
<code>VersaoIp</code> de um endere√ßo IP usando uma <code>struct</code></span></p>
<p>Aqui n√≥s definimos uma struct <code>EnderecoIp</code> que tem dois membros: <code>versao</code>, do
tipo <code>VersaoIp</code> (que definimos anteriormente) e <code>endereco</code>, do tipo <code>String</code>.
Temos duas inst√¢ncias dessa struct. A primeira, <code>local</code>, tem o valor
<code>VersaoIp::V4</code> como sua <code>versao</code>, e um endere√ßo associado igual a <code>127.0.0.1</code>.
A segunda inst√¢ncia, <code>loopback</code>, tem como sua <code>versao</code> a outra variante de
<code>VersaoIp</code>, <code>V6</code>, e o endere√ßo <code>::1</code> associado a ela. N√≥s usamos uma struct
para encapsular os valores de <code>versao</code> e <code>endereco</code>, agora a variante est√°
associada ao valor.</p>
<p>Podemos representar o mesmo conceito de uma forma mais concisa usando apenas
uma enum, em vez de uma enum dentro de uma struct, colocando dados dentro de
cada variante da enum, diretamente. Esta nova defini√ß√£o da enum <code>EnderecoIp</code>
diz que ambas as variantes, <code>V4</code> e <code>V6</code>, ter√£o uma <code>String</code> associada:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(String),
    V6(String),
}

let local = EnderecoIp::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Podemos anexar dados a cada variante da enum diretamente, assim n√£o existe mais
a necessidade de uma struct adicional.</p>
<p>H√° uma outra vantagem de se usar uma enum em vez de uma struct: cada variante
pode conter dados de diferentes tipos e quantidades. Os endere√ßos IP da vers√£o
quatro t√™m sempre quatro componentes num√©ricas, cada uma com valor de 0 a 255.
Se quis√©ssemos representar endere√ßos <code>V4</code> como quatro valores <code>u8</code>, e ao mesmo
tempo manter os endere√ßos <code>V6</code> como uma <code>String</code>, n√£o poder√≠amos usar uma
struct. J√° as enums podem facilmente atender a este caso:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum EnderecoIp {
    V4(u8, u8, u8, u8),
    V6(String),
}

let local = EnderecoIp::V4(127, 0, 0, 1);

let loopback = EnderecoIp::V6(String::from(&quot;::1&quot;));
#}</code></pre></pre>
<p>Acabamos de ver algumas possibilidades que poder√≠amos usar para representar
endere√ßos IP das duas vers√µes por meio de uma enum. Acontece que essa
necessidade de representar endere√ßos IP, incluindo sua vers√£o, √© t√£o comum que
a biblioteca padr√£o j√° possui uma defini√ß√£o que podemos usar! (<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">Veja a
documenta√ß√£o em ingl√™s</a><!-- ignore -->). Vamos ver como a biblioteca
padr√£o define <code>IpAddr</code>: ele tem basicamente a mesma enum e as mesmas variantes
que n√≥s definimos e usamos anteriormente, mas os dados do endere√ßo s√£o
embutidos dentro das variantes na forma de duas structs separadas, que s√£o
definidas de um jeito diferente pra cada variante.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Ipv4Addr {
    // detalhes omitidos
}

struct Ipv6Addr {
    // detalhes omitidos
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
#}</code></pre></pre>
<p>Esse c√≥digo mostra que voc√™ pode colocar qualquer tipo de dados dentro de uma
variante de enum: strings, tipos num√©ricos ou structs, por exemplo. Voc√™ pode
at√© mesmo incluir outra enum! Al√©m disso, os tipos definidos pela biblioteca
padr√£o n√£o s√£o t√£o mais complicados do que o que talvez voc√™ pensaria em fazer.</p>
<p>Repare que, mesmo havendo um <code>IpAddr</code>definido pela biblioteca padr√£o, n√≥s ainda
podemos criar e utilizar nossa pr√≥pria defini√ß√£o (com o mesmo nome, inclusive)
sem nenhum conflito, porque n√£o trouxemos a defini√ß√£o da biblioteca padr√£o para
dentro do nosso escopo. Falaremos mais sobre a inclus√£o de tipos em um escopo
no Cap√≠tulo 7.</p>
<p>Vamos ver outro exemplo de uma enum na Listagem 6-2: esta tem uma grande
variedade de tipos embutidos nas suas variantes:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Mensagem {
    Sair,
    Mover { x: i32, y: i32 },
    Escrever(String),
    MudarCor(i32, i32, i32),
}
#}</code></pre></pre>
<p><span class="caption">Listagem 6-2: Enum <code>Mensagem</code>, cujas variantes cont√™m,
cada uma, diferentes tipos e quantidades de dados</span></p>
<p>Esta enum tem quatro variantes de diferentes tipos:</p>
<ul>
<li><code>Sair</code> n√£o tem nenhum dado associado.</li>
<li><code>Mover</code> cont√©m uma struct an√¥nima.</li>
<li><code>Escrever</code> cont√©m uma √∫nica <code>String</code>.</li>
<li><code>MudarCor</code> cont√©m tr√™s valores do tipo <code>i32</code>.</li>
</ul>
<p>Definir uma enum com variantes iguais √†s da Listagem 6-2 √© similar a definir
diferentes tipos de struct, exceto que a enum n√£o usa a palavra-chave <code>struct</code>,
e todas as variantes s√£o agrupadas dentro do tipo <code>Mensagem</code>. As structs
seguintes podem guardar os mesmos dados que as variantes da enum anterior:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MensagemSair; // unit struct
struct MensagemMover {
    x: i32,
    y: i32,
}
struct MensagemEscrever(String); // tuple struct
struct MensagemMudarCor(i32, i32, i32); // tuple struct
#}</code></pre></pre>
<p>Mas se usarmos structs diferentes, cada uma tendo seu pr√≥prio tipo, n√£o vamos
conseguir t√£o facilmente definir uma fun√ß√£o que possa receber qualquer um
desses tipos de mensagens, assim como fizemos com a enum <code>Mensagem</code>, definida
na Listagem 6-2, que consiste em um tipo √∫nico.</p>
<p>H√° mais uma similaridade entre enums e structs: da mesma forma como podemos
definir m√©todos em structs usando <code>impl</code>, tamb√©m podemos definir m√©todos em
enums. Aqui est√° um m√©todo chamado <code>invocar</code>, que poderia ser definido na nossa
enum <code>Mensagem</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Mensagem {
#     Sair,
#     Mover { x: i32, y: i32 },
#     Escrever(String),
#     MudarCor(i32, i32, i32),
# }
#
impl Mensagem {
    fn invocar(&amp;self) {
        // o corpo do m√©todo √© definido aqui
    }
}

let m = Mensagem::Escrever(String::from(&quot;ol√°&quot;));
m.invocar();
#}</code></pre></pre>
<p>O corpo do m√©todo usaria o valor <code>self</code> para obter a mensagem sobre a qual o
m√©todo foi chamado. Neste exemplo, criamos a vari√°vel <code>m</code>, que cont√©m o valor
<code>Mensagem::Escrever(String::from(&quot;ol√°&quot;))</code>, e √© isso que <code>self</code> vai ser no corpo
do m√©todo <code>invocar</code> quando <code>m.invocar()</code> for executado.</p>
<p>Vamos ver agora outra enum da biblioteca padr√£o que tamb√©m √© muito √∫til e
comum: <code>Option</code>.</p>
<a class="header" href="ch06-01-defining-an-enum.html#a-enum-option-e-suas-vantagens-sobre-valores-nulos" id="a-enum-option-e-suas-vantagens-sobre-valores-nulos"><h3>A Enum <code>Option</code> e Suas Vantagens Sobre Valores Nulos</h3></a>
<p>Na se√ß√£o anterior, vimos como a enum <code>EnderecoIp</code> nos permite usar o sistema de
tipos do Rust para codificar em nosso programa mais informa√ß√£o do que apenas os
dados que queremos representar. Essa se√ß√£o explora um caso de estudo da
<code>Option</code>, que √© outra enum definida pela biblioteca padr√£o. O tipo <code>Option</code> √©
muito utilizado, pois engloba um cen√°rio muito comum, em que um valor pode ser
algo ou pode n√£o ser nada. Expressar esse conceito por meio do sistema de tipos
significa que o compilador pode verificar se voc√™ tratou, ou n√£o, todos os
casos que deveriam ser tratados, podendo evitar <em>bugs</em> que s√£o extremamente
comuns em outras linguagens de programa√ß√£o.</p>
<p>O <em>design</em> de uma linguagem de programa√ß√£o √© geralmente tratado em termos de
quais caracter√≠sticas s√£o inclu√≠das, mas as que s√£o exclu√≠das tamb√©m t√™m
import√¢ncia. Rust n√£o tem o valor nulo (<em>null</em>) que outras linguagens t√™m. O
valor nulo quer dizer que n√£o h√° nenhum valor. Em linguagens que t√™m essa
caracter√≠stica, as vari√°veis sempre est√£o em um dos dois estados: nulo ou n√£o
nulo.</p>
<p>Em uma confer√™ncia, Tony Hoare, inventor do valor nulo, disse o seguinte:</p>
<blockquote>
<p>Eu o chamo meu erro de um bilh√£o de d√≥lares. Naquela √©poca, eu estava
projetando o primeiro sistema abrangente de tipos para refer√™ncias em uma
linguagem orientada a objetos. Meu objetivo era garantir que todo uso de
refer√™ncias deveria ser absolutamente seguro, com verifica√ß√£o autom√°tica
feita pelo compilador. Mas n√£o pude resistir √† tenta√ß√£o de colocar uma
refer√™ncia nula, simplesmente porque era t√£o f√°cil de implementar. Isso tem
provocado in√∫meros erros, vulnerabilidades, e falhas de sistemas que
provavelmente causaram um bilh√£o de d√≥lares de dor e danos nos √∫ltimos
quarenta anos.</p>
</blockquote>
<p>O problema com valores nulos √© que, se voc√™ tentar usar um valor nulo como se
fosse n√£o nulo, vai acontecer algum tipo de erro. Pelo fato dessa propriedade
de nulo e n√£o nulo ser t√£o sutil, √© extremamente f√°cil cometer esse tipo de
erro.</p>
<p>Por√©m, o conceito que o valor nulo tenta expressar ainda √© √∫til: um valor nulo
representa algo que, por algum motivo, est√° inv√°lido ou ausente no momento.</p>
<p>O problema, na verdade, n√£o est√° no conceito, mas na implementa√ß√£o em
particular. Por isso, Rust n√£o possui valores nulos, mas sim uma enum que
engloba o conceito de um valor estar presente ou ausente. Esta enum √© a
<code>Option&lt;T&gt;</code>, que est√° definida na biblioteca padr√£o da seguinte forma:
(<a href="https://doc.rust-lang.org/std/option/enum.Option.html">Veja a documenta√ß√£o em ingl√™s</a><!-- ignore -->).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T), // algum valor
    None, // nenhum valor
}
#}</code></pre></pre>
<p>A enum <code>Option&lt;T&gt;</code> √© t√£o √∫til que ela j√° vem inclusa no prel√∫dio: voc√™ n√£o
precisa traz√™-la explicitamente para o seu escopo. Al√©m disso, o mesmo ocorre
com suas variantes: voc√™ pode usar <code>Some</code> e <code>None</code> diretamente sem prefix√°-las
com <code>Option::</code>. <code>Option&lt;T&gt;</code> continua sendo uma enum como qualquer outra, e
<code>Some(T)</code> e <code>None</code> ainda s√£o variantes do tipo <code>Option&lt;T&gt;</code>.</p>
<p>A sintaxe do <code>&lt;T&gt;</code> √© uma caracter√≠stica do Rust de que n√£o falamos ainda.
Trata-se de um par√¢metro de tipo gen√©rico, vamos abord√°-lo com mais detalhe no
Cap√≠tulo 10. Por ora, tudo que voc√™ precisa saber √© que <code>&lt;T&gt;</code> significa que a
variante <code>Some</code> da enum <code>Option</code> pode conter um dado de qualquer tipo. Aqui v√£o
alguns exemplos de <code>Option</code> contendo tipos de n√∫mero e texto:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let algum_numero = Some(5);
let algum_texto = Some(&quot;um texto&quot;);

let numero_ausente: Option&lt;i32&gt; = None;
#}</code></pre></pre>
<p>Se usamos <code>None</code> em vez de <code>Some</code>, precisamos dizer ao Rust qual √© o tipo de
<code>Option&lt;T&gt;</code> que n√≥s temos, porque o compilador n√£o consegue inferir qual tipo
estar√° contido na variante <code>Some</code> apenas olhando para um valor <code>None</code>.</p>
<p>Quando temos um <code>Some</code>, sabemos que um valor est√° presente, contido dentro do
<code>Some</code>. J√° quando temos um <code>None</code>, de certa forma, significa o mesmo que um
valor nulo: n√£o temos um valor que seja v√°lido. Ent√£o por que a <code>Option&lt;T&gt;</code> √©
t√£o melhor que usar um valor nulo?</p>
<p>Em resumo, √© porque <code>Option&lt;T&gt;</code> e <code>T</code> (podendo <code>T</code> ser de qualquer tipo) s√£o
tipos diferentes, por isso, o compilador n√£o vai permitir usar um valor do tipo
<code>Option&lt;T&gt;</code> como se ele definitivamente tivesse um valor v√°lido. Por exemplo,
o c√≥digo seguinte n√£o vai compilar, porque ele est√° tentando somar um <code>i8</code> a um
<code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let soma = x + y;
</code></pre>
<p>Quando executamos esse c√≥digo, temos uma mensagem de erro como essa:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intenso! O que essa mensagem quer dizer √© que o Rust n√£o consegue entender como
somar um <code>i8</code> e um <code>Option&lt;i8&gt;</code>, porque eles s√£o de tipos diferentes. Quando
temos um valor de um tipo como <code>i8</code> em Rust, o compilador tem certeza de que
temos sempre um valor v√°lido. Podemos prosseguir com confian√ßa, sem ter de
verificar se o valor √© nulo antes de us√°-lo. Somente quando temos um
<code>Option&lt;i8&gt;</code> (ou qualquer que seja o tipo com que estamos trabalhando), vamos
ter de nos preocupar com a possibilidade de n√£o haver um valor, e o compilador
vai se certificar de que n√≥s estamos tratando este caso antes de usar o valor.</p>
<p>Em outras palavras, voc√™ tem que converter um <code>Option&lt;T&gt;</code> em um <code>T</code> antes de
poder executar opera√ß√µes com ele. Geralmente, isso ajuda a detectar um dos
problemas mais comuns com valores nulos: assumir que algo n√£o √© nulo quando,
na verdade, ele √©.</p>
<p>S√≥ de n√£o ter que se preocupar com a possibilidade de ter deixado um valor nulo
escapar j√° lhe d√° mais confian√ßa em seu c√≥digo. Pra ter um valor que pode ser
nulo em algum momento, voc√™ precisa, explicitamente, marc√°-lo como sendo do
tipo <code>Option&lt;T&gt;</code>. A partir da√≠, sempre que for usar o valor, voc√™ ser√° obrigado
a tratar, de forma expl√≠cita, o caso do valor sendo nulo. Sempre que houver um
valor que n√£o seja um <code>Option&lt;T&gt;</code>, voc√™ <em>pode</em> assumir, com seguran√ßa, que o
valor n√£o √© nulo. Esta foi uma decis√£o deliberada de projeto do Rust para
limitar as sutilezas dos valores nulos e aumentar a seguran√ßa do c√≥digo.</p>
<p>Ent√£o, como obter o valor <code>T</code> da variante <code>Some</code> quando se tem um <code>Option&lt;T&gt;</code>,
para que se possa usar seu valor? A enum <code>Option&lt;T&gt;</code> possui diversos m√©todos
que s√£o √∫teis em uma variedade de situa√ß√µes, voc√™ pode pesquis√°-los na
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">documenta√ß√£o</a><!-- ignore --> (em ingl√™s). Ser√° extremamente √∫til na sua
jornada com Rust se familizarizar com os m√©todos da enum <code>Option&lt;T&gt;</code>.</p>
<p>Em geral, pra usar um valor <code>Option&lt;T&gt;</code>, queremos ter um c√≥digo que trate cada
uma das variantes. Queremos um c√≥digo que s√≥ ser√° executado quando tivermos um
valor <code>Some(T)</code>, e esse c√≥digo ter√° permiss√£o para usar o valor <code>T</code> que est√°
embutido. Queremos tamb√©m um outro c√≥digo que seja executado se tivermos um
valor <code>None</code>, e esse c√≥digo n√£o ter√° um valor <code>T</code> dispon√≠vel. A express√£o
<code>match</code> √© uma instru√ß√£o de controle de fluxo que faz exatamente isso quando
usada com enums: ela executa c√≥digos diferentes dependendo de qual variante
tiver a enum, e esse c√≥digo poder√° usar os dados contidos na variante
encontrada.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
