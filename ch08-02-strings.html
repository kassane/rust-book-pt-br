<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Strings - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> üáßüá∑ Introdu√ß√£o</a></li><li><ol class="section"><li><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li></ol></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> üáßüá∑ Conceitos Comuns de Programa√ß√£o</a></li><li><ol class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> üáßüá∑ Vari√°veis e Mutabilidade</a></li><li><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Structs</a></li><li><ol class="section"><li><a href="ch05-01-method-syntax.html"><strong aria-hidden="true">5.1.</strong> Method Syntax</a></li></ol></li><li><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Operator</a></li><li><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li><a href="ch07-00-modules.html"><strong aria-hidden="true">7.</strong> Modules</a></li><li><ol class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong aria-hidden="true">7.1.</strong> mod and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong aria-hidden="true">7.2.</strong> Controlling Visibility with pub</a></li><li><a href="ch07-03-importing-names-with-use.html"><strong aria-hidden="true">7.3.</strong> Importing Names with use</a></li></ol></li><li><a href="ch08-00-fundamental-collections.html"><strong aria-hidden="true">8.</strong> Fundamental Collections</a></li><li><ol class="section"><li><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html" class="active"><strong aria-hidden="true">8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Hash Maps</a></li></ol></li><li><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><ol class="section"><li><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Lifetime syntax</a></li></ol></li><li><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Testing</a></li><li><ol class="section"><li><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project</a></li><li><ol class="section"><li><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Improving Error Handling and Modularity</a></li><li><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Testing the Library's Functionality</a></li><li><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing to stderr instead of stdout</a></li></ol></li><li><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features in Rust</a></li><li><ol class="section"><li><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures</a></li><li><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Iterators</a></li><li><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving our I/O Project</a></li><li><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performance</a></li></ol></li><li><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Release Profiles</a></li><li><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Concurrency</a></li><li><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Is Rust OOP?</a></li><li><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns</a></li><li><a href="ch19-00-more-lifetimes.html"><strong aria-hidden="true">19.</strong> More Lifetimes</a></li><li><a href="ch20-00-advanced-types.html"><strong aria-hidden="true">20.</strong> Advanced Type System Features</a></li><li><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> Derivable Traits</a></li><li><a href="appendix-04-nightly-rust.html"><strong aria-hidden="true">21.4.</strong> Nightly Rust</a></li><li><a href="appendix-05-macros.html"><strong aria-hidden="true">21.5.</strong> Macros</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="submenu">
                                <li><button class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li><button class="theme" id="rust">Rust</button></li>
                                <li><button class="theme" id="coal">Coal</button></li>
                                <li><button class="theme" id="navy">Navy</button></li>
                                <li><button class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title"></h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch08-02-strings.html#strings" id="strings"><h2>Strings</h2></a>
<p>N√≥s j√° conversamos sobre as strings no cap√≠tulo 4, mas vamos dar uma olhada mais
em profundidade agora. As strings s√£o uma √°rea que os novos Rust√°ceos geralmente tem maior
dificuldade. Isto √© devido a uma combina√ß√£o de tr√™s coisas: a propens√£o de Rust de
certificar-se de expor poss√≠veis erros, as strings s√£o estruturas de dados mais complicadas
que muitos programadores lhes d√£o cr√©dito, e UTF-8. Essas coisas
combina de tal forma que parecem dif√≠cil quando se vem de outras linguagens.</p>
<p>A raz√£o pela qual as strings est√£o no cap√≠tulo de cole√ß√µes √© que as strings s√£o
implementadas como uma cole√ß√£o de bytes mais alguns m√©todos para fornecer informa√ß√µes √∫teis e
funcionalidade quando esses bytes s√£o interpretados como texto. Nesta se√ß√£o, iremos
falar sobre as opera√ß√µes em <code>String</code> que todo tipo de cole√ß√£o tem, como
criar, atualizar e ler. Tamb√©m discutiremos as formas em que <code>String</code>
√© diferente das outras cole√ß√µes, a saber, como a indexa√ß√£o em um <code>String</code> √©
complicada pelas diferen√ßas entre como as pessoas e os computadores interpretam
dados <code>String</code>.</p>
<a class="header" href="ch08-02-strings.html#o-que-√©-string" id="o-que-√©-string"><h3>O que √© String?</h3></a>
<p>Antes de podermos explorar esses aspectos, precisamos falar sobre o que exatamente
significa o termo <em>string</em>. Rust realmente s√≥ tem um tipo de string no n√∫cleo
da pr√≥pria linguagem: <code>str</code>, a fatia de string, que geralmente √© vista na forma emprestada
, <code>&amp;str</code>. N√≥s falamos sobre <em>fatias de strings</em> no Cap√≠tulo 4: estas s√£o uma
refer√™ncia a alguns dados de string codificados em UTF-8 armazenados em outro lugar. Literais de strings,
por exemplo, s√£o armazenados na sa√≠da bin√°ria do programa e, portanto, s√£o
fatias de string.</p>
<p>O tipo chamado <code>String</code> √© fornecido na biblioteca padr√£o do Rust, em vez de
codificado no n√∫leo da linguagem, e √© um extens√≠vel, mut√°vel, <code>owned</code>, tipo string
codificado UTF-8. Quando Rust√°ceos falam sobre ‚Äústrings‚Äù em Rust, geralmente significa
tanto os tipos <code>String</code> quanto os tipos de string<code>&amp;str</code>, normalmente ambos.
Esta se√ß√£o, √© em grande parte sobre <code>String</code>, mas ambos esses tipos s√£o usados em grande parte
na biblioteca padr√£o da Rust. Tanto o <code>String</code> como as fatias de string s√£o codificadas em UTF-8.</p>
<p>A biblioteca padr√£o do Rust tamb√©m inclui uma s√©rie de outros tipos de string, como
<code>OsString</code>,<code>OsStr</code>, <code>CString</code> e<code>CStr</code>. Bibliotecas crates podem fornecer
mais op√ß√µes para armazenar dados de string. Semelhante ao nome <code>*String</code>/<code>*Str</code>,
elas geralmente fornecem uma variante owned e borrowed, assim como <code>String</code>/<code>&amp;str</code>.
Esses tipos de string podem armazenar diferentes codifica√ß√µes ou ser representados na mem√≥ria de
maneira diferente, por exemplo. N√≥s n√£o estaremos falando sobre esse outro tipo de string
neste cap√≠tulo; veja a documenta√ß√£o da API para obter mais informa√ß√µes sobre como us√°-los
e quando cada um √© apropriado.</p>
<a class="header" href="ch08-02-strings.html#criando-uma-nova-string" id="criando-uma-nova-string"><h3>Criando uma Nova String</h3></a>
<p>Muitas das mesmas opera√ß√µes dispon√≠veis com <code>Vec</code> tamb√©m est√£o dispon√≠veis em <code>String</code>,
come√ßando com a fun√ß√£o <code>new</code> para criar uma string, assim:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::new();
#}</code></pre></pre>
<p>Isso cria uma nova string vazia chamada <code>s</code> na qual podemos carregar dados.</p>
<p>Muitas vezes, teremos alguns dados iniciais que gostar√≠amos de j√° colocar na string.
Para isso, usamos o m√©todo <code>to_string</code>, que est√° dispon√≠vel em qualquer tipo
que implementa a trait <code>Display</code>, como as strings literais:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data = &quot;initial contents&quot;;

let s = data.to_string();

// o m√©todo tamb√©m funciona em literais diretamente
let s = &quot;initial contents&quot;.to_string();
#}</code></pre></pre>
<p>Isso cria uma string contendo <code>initial contents</code>.</p>
<p>Tamb√©m podemos usar a fun√ß√£o <code>String :: from</code> para criar uma<code>String</code> de uma string
literal. Isso equivale a usar <code>to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;initial contents&quot;);
#}</code></pre></pre>
<p>Como as strings s√£o usadas para tantas coisas, existem v√°rias APIs gen√©ricas diferentes
que podem ser usadas para strings, ent√£o h√° muitas op√ß√µes. Algumas delas
podem parecer redundantes, mas todas t√™m seu lugar! Nesse caso, <code>String :: from</code>
e <code>.to_string</code> acabam fazendo exatamente o mesmo, ent√£o a que voc√™ escolher √© uma
quest√£o de estilo.</p>
<p>Lembre-se de que as string s√£o codificadas em UTF-8, para que possamos incluir qualquer dados apropriadamente codificados
neles:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ&quot;;
let hello = &quot;Dobr√Ω den&quot;;
let hello = &quot;Hello&quot;;
let hello = &quot;◊©÷∏◊Å◊ú◊ï÷π◊ù&quot;;
let hello = &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;;
let hello = &quot;„Åì„Çì„Å´„Å°„ÅØ&quot;;
let hello = &quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;;
let hello = &quot;‰Ω†Â•Ω&quot;;
let hello = &quot;Ol√°&quot;;
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let hello = &quot;Hola&quot;;
#}</code></pre></pre>
<a class="header" href="ch08-02-strings.html#atualizando-uma-string" id="atualizando-uma-string"><h3>Atualizando uma String</h3></a>
<p>Uma <code>String</code> pode crescer em tamanho e seu conte√∫do pode mudar assim como o conte√∫do
de um <code>Vec</code>, empurrando mais dados para ela. Al√©m disso, <code>String</code> tem
opera√ß√µes de concatena√ß√£o implementadas com o operador <code>+</code> por conveni√™ncia.</p>
<a class="header" href="ch08-02-strings.html#anexando-a-uma-string-com-push" id="anexando-a-uma-string-com-push"><h4>Anexando a uma String com Push</h4></a>
<p>Podemos criar uma <code>String</code> usando o m√©todo <code>push_str</code> para adicionar uma  seq√º√™ncia de caracteres:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
#}</code></pre></pre>
<p><code>s</code> conter√° ‚Äúfoobar‚Äú ap√≥s essas duas linhas. O m√©todo <code>push_str</code> leva um
fatia de string porque n√£o necessariamente queremos ownership do
par√¢metro. Por exemplo, seria lament√°vel se n√£o pud√©ssemos usar <code>s2</code>
depois de atualizar o seu conte√∫do a <code>s1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s1 = String::from(&quot;foo&quot;);
let s2 = String::from(&quot;bar&quot;);
s1.push_str(&amp;s2);
#}</code></pre></pre>
<p>O m√©todo <code>push</code> √© definido para ter um √∫nico caractere como par√¢metro e adicionar
√† <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;lo&quot;);
s.push('l');
#}</code></pre></pre>
<p>Ap√≥s isso, <code>s</code> ir√° conter ‚Äúlol‚Äù.</p>
<a class="header" href="ch08-02-strings.html#concatena√ß√£o-com-o-operador--ou-a-macro-format" id="concatena√ß√£o-com-o-operador--ou-a-macro-format"><h4>Concatena√ß√£o com o Operador + ou a macro <code>format!</code></h4></a>
<p>Muitas vezes, queremos combinar duas strings existentes. Uma maneira √© usar
o operador <code>+</code> dessa forma:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // Note que s1 foi movido aqui e n√£o pode ser mais usado
#}</code></pre></pre>
<p>Ap√≥s este c√≥digo, a String <code>s3</code> conter√° <code>Hello, world!</code>. O motivo que
<code>s1</code> n√£o √© mais v√°lido ap√≥s a adi√ß√£o e o motivo que usamos uma
refer√™ncia a <code>s2</code> tem a ver com a assinatura do m√©todo que √© chamado
quando usamos o operador <code>+</code>. O operador <code>+</code> usa o m√©todo <code>add</code>, cuja
assinatura parece algo assim:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Esta n√£o √© a assinatura exata que est√° na biblioteca padr√£o; l√° o <code>add</code> √©
definido usando gen√©ricos. Aqui, estamos olhando a assinatura do <code>add</code> com
tipos de concreto substitu√≠dos pelos gen√©ricos, o que acontece quando n√≥s
chamamos esse m√©todo com valores <code>String</code>. Vamos discutir gen√©ricos no
Cap√≠tulo 10. Esta assinatura nos d√° as pistas que precisamos para entender o complicado
operador <code>+</code>.</p>
<p>Antes de tudo, <code>s2</code> tem um <code>&amp;</code>, o que significa que estamos adicionando uma <em>refer√™ncia</em> da
segunda string para a primeira string. Isso √© devido ao par√¢metro <code>s</code> na
fun√ß√£o <code>add</code>: s√≥ podemos adicionar um <code>&amp;str</code> √† <code>String</code>, n√£o podemos adicionar dois
valores <code>String</code> juntos. Mas espere - o tipo de <code>&amp;s2</code> √© <code>&amp;String</code>, n√£o
<code>&amp;str</code>, conforme especificado no segundo par√¢metro para<code>add</code>. Por que nosso exemplo
compila? Podemos usar <code>&amp;s2</code> na chamada para <code>add</code> porque um <code>&amp;String</code>
o argumento pode ser <em>coerced</em> em um <code>&amp;str</code> - quando a fun√ß√£o<code>add</code> √© chamada,
Rust usa algo chamado de <em>deref coercion</em>, o que voc√™ poderia pensar aqui como
virando <code>&amp;s2</code> para<code>&amp;s2[..]</code> para uso na fun√ß√£o <code>add</code>. Vamos discutir deref
coercion  em maior profundidade no Cap√≠tulo 15. Como o <code>add</code> n√£o se apropria
o par√¢metro <code>s2</code> ainda ser√° uma <code>String</code> v√°lida ap√≥s essa opera√ß√£o.</p>
<p>Em segundo lugar, podemos ver na assinatura que <code>add</code> toma posse de<code>self</code>,
porque <code>self</code> <em>n√£o</em> tem <code>&amp;</code>. Isso significa <code>s1</code> no exemplo acima
ser√° transferido para a chamada <code>add</code> e n√£o ser√° mais v√°lido depois disso. Por enquanto
<code>let s3 = s1 + &amp;s2;</code> parece que ir√° copiar ambas as strings e criar uma nova,
esta declara√ß√£o realmente adere a <code>s1</code>, acrescenta uma c√≥pia do conte√∫do
de <code>s2</code>, ent√£o retorna ownership do resultado. Em outras palavras, parece
estar fazendo muitas c√≥pias, mas n√£o √©: a implementa√ß√£o √© mais eficiente
do que copiar.</p>
<p>Se precisarmos concatenar v√°rias strings, o comportamento de <code>+</code> fica complicado:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
#}</code></pre></pre>
<p><code>s</code> ser√° ‚Äútic-tac-toe‚Äù neste momento. Com todos os <code>+</code> e <code>&quot;</code>,
fica dif√≠cil ver o que est√° acontecendo. Para strings mais complicadas
, podemos usar o macro <code>format!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
#}</code></pre></pre>
<p>Este c√≥digo tamb√©m definir√° <code>s</code> para ‚Äútic-tac-toe‚Äù. A macro <code>format!</code> funciona
do mesmo modo que <code>println!</code>, mas em vez de imprimir a sa√≠da para a tela, ela
retorna uma <code>String</code> com o conte√∫do. Esta vers√£o √© muito mais f√°cil de ler, e
tamb√©m n√£o incide ownership em nenhum dos seus par√¢metros.</p>
<a class="header" href="ch08-02-strings.html#indexa√ß√£o-em-strings" id="indexa√ß√£o-em-strings"><h3>Indexa√ß√£o em Strings</h3></a>
<p>Em muitas outras linguagens, acessar caracteres individuais em uma string por
referenciando por √≠ndice √© uma opera√ß√£o v√°lida e comum. Em Rust, no entanto, se
n√≥s tentamos acessar partes de uma <code>String</code> usando sintaxe de indexa√ß√£o, vamos ter um erro.
Ou seja, este c√≥digo:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p>resultar√° neste erro:</p>
<pre><code class="language-text">error: the trait bound `std::string::String: std::ops::Index&lt;_&gt;` is not
satisfied [--explain E0277]
  |&gt;
  |&gt;     let h = s1[0];
  |&gt;             ^^^^^
note: the type `std::string::String` cannot be indexed by `_`
</code></pre>
<p>O erro e a nota contam a hist√≥ria: as strings em Rust n√£o suportam a indexa√ß√£o. Assim
a pr√≥xima pergunta √©, por que n√£o? Para responder a isso, temos que conversar um
pouco sobre como o Rust armazena strings na mem√≥ria.</p>
<a class="header" href="ch08-02-strings.html#representa√ß√£o-interna" id="representa√ß√£o-interna"><h4>Representa√ß√£o Interna</h4></a>
<p>Uma <code>String</code> √© um inv√≥lucro sobre um <code>Vec &lt;u8&gt;</code>. Vejamos alguns dos nossos
exemplos UTF-8, codificadas corretamente, de strings vistas anteriormente. Primeiro, este:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;Hola&quot;).len();
#}</code></pre></pre>
<p>Neste caso, <code>len</code> ter√° valor de quatro, o que significa que o<code>Vec</code> armazena a string
‚ÄùHola‚Äù tem quatro bytes de comprimento: cada uma dessas letras leva um byte quando codificado em
UTF-8. E o que acontece para esse exemplo?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let len = String::from(&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;).len();
#}</code></pre></pre>
<p>Uma pessoa que pergunte pelo comprimento da string pode dizer que ela deva ter 12.No entanto, a resposta de Rust
√© 24. Este √© o n√∫mero de bytes que √© necess√°rio para codificar ‚Äú–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ‚Äú em
UTF-8, uma vez que cada valor escalar Unicode leva dois bytes de armazenamento. Assim sendo,
um √≠ndice nos bytes da string nem sempre se correlaciona com um  valor escalar Unicode v√°lido.</p>
<p>Para demonstrar, considere este c√≥digo inv√°lido do Rust:</p>
<pre><code class="language-rust ignore">let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>Qual deve ser o valor da <code>answer</code>? Seria <code>–ó</code>, a primeira letra? Quando
codificado em UTF-8, o primeiro byte de <code>–ó</code> √© <code>208</code>, e o segundo √© <code>151</code>, ent√£o
a <code>answer</code> deve, na verdade, ser <code>208</code>, mas <code>208</code> n√£o √© um caractere v√°lido em
si. Retornar <code>208</code> provavelmente n√£o √© o que uma pessoa gostaria se eles pedissem
a primeira letra desta string, mas esse √© o √∫nico dado que Rust tem no byte
de √≠ndice 0. O retorno do valor do byte provavelmente n√£o √© o que as pessoas querem, mesmo com
caracteres contendo acentua√ß√£o: <code>&amp;&quot;hello&quot;[0]</code> retornaria <code>104</code>, n√£o<code>h</code>. Para evitar o
retornando um valor inesperado e causando erros que podem n√£o ser descobertos
imediatamente, Rust escolhe n√£o compilar este c√≥digo e previne
mal-entendidos anteriormente.</p>
<a class="header" href="ch08-02-strings.html#bytes-e-valores-escalares-e-clusters-de-grafemas-nossa" id="bytes-e-valores-escalares-e-clusters-de-grafemas-nossa"><h4>Bytes e Valores Escalares e Clusters de Grafemas! Nossa!</h4></a>
<p>Isso leva a outro ponto sobre UTF-8: existem realmente tr√™s maneiras relevantes
de olhar para as strings, da perspectiva do Rust: como bytes, valores escalares e
clusters de grafemas (a coisa mais pr√≥xima do que as pessoas chamariam <em>letras</em>).</p>
<p>Se olharmos para a palavra Hindi ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù escrita na escrita Devanagari, √©
em √∫ltima inst√¢ncia, armazenada como um <code>Vec</code> de valores <code>u8</code> que se parece com isto:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Isso √© 18 bytes, e √© como os computadores de fato armazenam esses dados. Se olharmos para
eles como valores escalares Unicode, que s√£o o tipo <code>char</code> de Rust, aqueles
bytes se parecem com isto:</p>
<pre><code class="language-text">['‡§®', '‡§Æ', '‡§∏', '‡•ç', '‡§§', '‡•á']
</code></pre>
<p>Existem seis valores <code>char</code> aqui, mas o quarto e o sexto n√£o s√£o letras,
Eles s√£o diacr√≠ticos que n√£o fazem sentido por conta pr√≥pria. Finalmente, se olharmos para
eles como clusters de grafemas, ter√≠amos o que uma pessoa chamaria as quatro letras
que comp√µem esta palavra:</p>
<pre><code class="language-text">[&quot;‡§®&quot;, &quot;‡§Æ&quot;, &quot;‡§∏‡•ç&quot;, &quot;‡§§‡•á&quot;]
</code></pre>
<p>Rust fornece diferentes maneiras de interpretar os dados de uma string bruta que os computadores
armazenem para que cada programa possa escolher a interpreta√ß√£o que necessite, n√£o importa
em que idioma humano os dados est√£o.</p>
<p>Uma raz√£o final do Rust n√£o permitir que voc√™ indexe uma <code>String</code> para obter um
caracter √© que as opera√ß√µes de indexa√ß√£o sempre esperam um tempo constante
(O(1)). N√£o √© poss√≠vel garantir que o desempenho com uma <code>String</code>,
entretanto, j√° que o Rust teria que percorrer todo o conte√∫do desde o in√≠cio
at√© o √≠ndice para determinar quantos caracteres v√°lidos havia.</p>
<a class="header" href="ch08-02-strings.html#fatiando-strings" id="fatiando-strings"><h3>Fatiando Strings</h3></a>
<p>Porque n√£o est√° claro qual seria o tipo de retorno da indexa√ß√£o de string, e
muitas vezes √© uma m√° id√©ia indexar uma string, Rust dissuade-o de faz√™-lo
pedindo que voc√™ seja mais espec√≠fico se voc√™ realmente precisar disso. Do jeito que voc√™ pode ser
mais espec√≠fico que a indexa√ß√£o usando <code>[]</code> com um √∫nico n√∫mero √© usando <code>[]</code> com
um intervalo para criar uma fatia de string contendo bytes espec√≠ficos:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;;

let s = &amp;hello[0..4];
#}</code></pre></pre>
<p>Aqui, <code>s</code> ser√° um <code>&amp;str</code> que cont√©m os primeiros quatro bytes da string.
Mais cedo, mencionamos que cada um desses personagens era de dois bytes, de modo que
significa que <code>s</code> ser√° ‚Äú–ó–¥‚Äù.</p>
<p>O que aconteceria se fiz√©ssemos <code>&amp;hello[0..1]</code>? A resposta: entrar√° em p√¢nico
em tempo de execu√ß√£o, da mesma maneira que acessar um √≠ndice inv√°lido em um vetor:</p>
<pre><code class="language-text">thread 'main' panicked at 'index 0 and/or 1 in `–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ` do not lie on
character boundary', ../src/libcore/str/mod.rs:1694
</code></pre>
<p>Voc√™ deve usar isso com cautela, pois isso pode fazer com que seu programa falhe.</p>
<a class="header" href="ch08-02-strings.html#m√©todos-para-interagir-sobre-strings" id="m√©todos-para-interagir-sobre-strings"><h3>M√©todos para Interagir Sobre Strings</h3></a>
<p>Felizmente, existem outras maneiras de acessar elementos em um String.</p>
<p>Se precisarmos realizar opera√ß√µes em valores escalares Unicode individuais, a melhor
maneira de fazer isso √© usar o m√©todo <code>chars</code>. Chamando <code>chars</code> em ‚Äú‡§®‡§Æ‡§∏‡•ç‡§§‡•á‚Äù
√© separado e retorna seis valores do tipo <code>char</code>, e voc√™ pode interar
no resultado para acessar cada elemento:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for c in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
#}</code></pre></pre>
<p>Este c√≥digo ir√° imprimir:</p>
<pre><code class="language-text">‡§®
‡§Æ
‡§∏
‡•ç
‡§§
‡•á
</code></pre>
<p>O m√©todo <code>bytes</code> retorna cada byte bruto, que pode ser apropriado para o seu
dom√≠nio:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for b in &quot;‡§®‡§Æ‡§∏‡•ç‡§§‡•á&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
#}</code></pre></pre>
<p>Este c√≥digo imprimir√° os 18 bytes que comp√µem esse <code>String</code>, come√ßando por:</p>
<pre><code class="language-text">224
164
168
224
// ... etc
</code></pre>
<p>Mas lembre-se de que os valores escalares Unicode v√°lidos podem ser constitu√≠dos por
mais de um byte.</p>
<p>Obter clusters de grafemas de strings √© complexo, ent√£o esta funcionalidade n√£o √©
fornecida pela biblioteca padr√£o. Existem crates dispon√≠veis em crates.io se
Esta √© a funcionalidade que voc√™ precisa.</p>
<a class="header" href="ch08-02-strings.html#as-strings-n√£o-s√£o-t√£o-simples" id="as-strings-n√£o-s√£o-t√£o-simples"><h3>As Strings N√£o s√£o t√£o Simples</h3></a>
<p>Para resumir, as strings s√£o complicadas. Diferentes linguagens de programa√ß√£o fazem
escolhas diferentes sobre como apresentar essa complexidade ao programador. Rust
optou por fazer o tratamento correto dos dados <code>String</code> o comportamento padr√£o
para todos os programas Rust, o que significa que os programadores devem pensar mais
no gerenciamento de dados UTF-8 antecipadamente. Este tradeoff exp√µe mais da complexidade
de strings do que outras linguagens de programa√ß√£o, mas isso ir√° impedi-lo de
ter que lidar com erros envolvendo caracteres n√£o-ASCII mais tarde em seu
ciclo de desenvolvimento.</p>
<p>Vamos mudar para algo um pouco menos complexo: hash maps!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
